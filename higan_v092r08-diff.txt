diff -ru higan_v092r07\emulator\emulator.hpp higan_v092r08\emulator\emulator.hpp
--- higan_v092r07\emulator\emulator.hpp	Fri Apr 12 16:39:08 2013
+++ higan_v092r08\emulator\emulator.hpp	Thu May 02 05:53:47 2013
@@ -3,7 +3,7 @@
 
 namespace Emulator {
   static const char Name[] = "higan";
-  static const char Version[] = "092.07";
+  static const char Version[] = "092.08";
   static const char Author[] = "byuu";
   static const char License[] = "GPLv3";
   static const char Website[] = "http://byuu.org/";
@@ -59,11 +59,11 @@
   }
 
   hook() {}
-  hook(const hook &hook) { callback = hook.callback; }
-  hook(void *function) { callback = function; }
+  hook(const hook& hook) { callback = hook.callback; }
+  hook(void* function) { callback = function; }
   hook(R (*function)(P...)) { callback = function; }
-  template<typename C> hook(R (C::*function)(P...), C *object) { callback = {function, object}; }
-  template<typename C> hook(R (C::*function)(P...) const, C *object) { callback = {function, object}; }
+  template<typename C> hook(R (C::*function)(P...), C* object) { callback = {function, object}; }
+  template<typename C> hook(R (C::*function)(P...) const, C* object) { callback = {function, object}; }
   template<typename L> hook(const L& function) { callback = function; }
 
   hook& operator=(const hook& hook) { callback = hook.callback; return *this; }
diff -ru higan_v092r07\emulator\interface.hpp higan_v092r08\emulator\interface.hpp
--- higan_v092r07\emulator\interface.hpp	Mon Jan 21 01:17:46 2013
+++ higan_v092r08\emulator\interface.hpp	Thu May 02 05:55:49 2013
@@ -23,7 +23,6 @@
     string type;
     bool bootable;  //false for cartridge slots (eg Sufami Turbo cartridges)
   };
-
   vector<Media> media;
 
   struct Device {
@@ -58,21 +57,22 @@
     virtual unsigned dipSettings(const Markup::Node&) { return 0; }
     virtual string path(unsigned) { return ""; }
     virtual string server() { return ""; }
-    virtual void notify(const string &text) { print(text, "\n"); }
-  } *bind;
+    virtual void notify(const string& text) { print(text, "\n"); }
+  };
+  Bind* bind = nullptr;
 
   //callback bindings (provided by user interface)
-  void loadRequest(unsigned id, const string &name, const string &type) { return bind->loadRequest(id, name, type); }
-  void loadRequest(unsigned id, const string &path) { return bind->loadRequest(id, path); }
-  void saveRequest(unsigned id, const string &path) { return bind->saveRequest(id, path); }
+  void loadRequest(unsigned id, const string& name, const string& type) { return bind->loadRequest(id, name, type); }
+  void loadRequest(unsigned id, const string& path) { return bind->loadRequest(id, path); }
+  void saveRequest(unsigned id, const string& path) { return bind->saveRequest(id, path); }
   uint32_t videoColor(unsigned source, uint16_t red, uint16_t green, uint16_t blue) { return bind->videoColor(source, red, green, blue); }
-  void videoRefresh(const uint32_t *data, unsigned pitch, unsigned width, unsigned height) { return bind->videoRefresh(data, pitch, width, height); }
+  void videoRefresh(const uint32_t* data, unsigned pitch, unsigned width, unsigned height) { return bind->videoRefresh(data, pitch, width, height); }
   void audioSample(int16_t lsample, int16_t rsample) { return bind->audioSample(lsample, rsample); }
   int16_t inputPoll(unsigned port, unsigned device, unsigned input) { return bind->inputPoll(port, device, input); }
-  unsigned dipSettings(const Markup::Node &node) { return bind->dipSettings(node); }
+  unsigned dipSettings(const Markup::Node& node) { return bind->dipSettings(node); }
   string path(unsigned group) { return bind->path(group); }
   string server() { return bind->server(); }
-  template<typename... Args> void notify(Args&... args) { return bind->notify({std::forward<Args>(args)...}); }
+  template<typename... Args> void notify(Args&&... args) { return bind->notify({std::forward<Args>(args)...}); }
 
   //information
   virtual string title() = 0;
@@ -85,8 +85,8 @@
   virtual unsigned group(unsigned id) = 0;
   virtual void load(unsigned id) {}
   virtual void save() {}
-  virtual void load(unsigned id, const stream &memory) {}
-  virtual void save(unsigned id, const stream &memory) {}
+  virtual void load(unsigned id, const stream& memory) {}
+  virtual void save(unsigned id, const stream& memory) {}
   virtual void unload() {}
 
   //system interface
@@ -112,8 +112,6 @@
   //debugger functions
   virtual bool tracerEnable(bool) { return false; }
   virtual void exportMemory() {}
-
-  Interface() : bind(nullptr) {}
 };
 
 }
diff -ru higan_v092r07\fc\cpu\serialization.cpp higan_v092r08\fc\cpu\serialization.cpp
--- higan_v092r07\fc\cpu\serialization.cpp	Sat Apr 28 04:46:40 2012
+++ higan_v092r08\fc\cpu\serialization.cpp	Thu May 02 05:51:54 2013
@@ -11,8 +11,12 @@
   s.integer(status.irq_apu_line);
 
   s.integer(status.rdy_line);
-  s.integer(status.rdy_addr.valid);
-  s.integer(status.rdy_addr.value);
+  bool rdy_addr_valid = status.rdy_addr;
+  unsigned rdy_addr_value = 0;
+  if(rdy_addr_valid) rdy_addr_value = status.rdy_addr();
+  s.integer(rdy_addr_valid);
+  s.integer(rdy_addr_value);
+  if(rdy_addr_valid) status.rdy_addr = rdy_addr_value;
 
   s.integer(status.oam_dma_pending);
   s.integer(status.oam_dma_page);
diff -ru higan_v092r07\fc\interface\interface.cpp higan_v092r08\fc\interface\interface.cpp
--- higan_v092r07\fc\interface\interface.cpp	Mon Jan 21 01:19:55 2013
+++ higan_v092r08\fc\interface\interface.cpp	Thu May 02 05:57:40 2013
@@ -2,7 +2,7 @@
 
 namespace Famicom {
 
-Interface *interface = nullptr;
+Interface* interface = nullptr;
 
 string Interface::title() {
   return cartridge.title();
@@ -42,12 +42,12 @@
 }
 
 void Interface::save() {
-  for(auto &memory : cartridge.memory) {
+  for(auto& memory : cartridge.memory) {
     saveRequest(memory.id, memory.name);
   }
 }
 
-void Interface::load(unsigned id, const stream &stream) {
+void Interface::load(unsigned id, const stream& stream) {
   if(id == ID::Manifest) cartridge.information.markup = stream.text();
 
   if(id == ID::ProgramROM) {
@@ -67,7 +67,7 @@
   }
 }
 
-void Interface::save(unsigned id, const stream &stream) {
+void Interface::save(unsigned id, const stream& stream) {
   if(id == ID::ProgramRAM) {
     stream.write(cartridge.board->prgram.data, cartridge.board->prgram.size);
   }
@@ -99,15 +99,15 @@
   return system.serialize();
 }
 
-bool Interface::unserialize(serializer &s) {
+bool Interface::unserialize(serializer& s) {
   return system.unserialize(s);
 }
 
-void Interface::cheatSet(const lstring &list) {
+void Interface::cheatSet(const lstring& list) {
   cheat.reset();
-  for(auto &code : list) {
+  for(auto& code : list) {
     lstring codelist = code.split("+");
-    for(auto &part : codelist) {
+    for(auto& part : codelist) {
       unsigned addr, data, comp;
       if(Cheat::decode(part, addr, data, comp)) cheat.append({addr, data, comp});
     }
@@ -150,8 +150,8 @@
   port.append({0, "Port 1"});
   port.append({1, "Port 2"});
 
-  for(auto &device : this->device) {
-    for(auto &port : this->port) {
+  for(auto& device : this->device) {
+    for(auto& port : this->port) {
       if(device.portmask & (1 << port.id)) {
         port.device.append(device);
       }
diff -ru higan_v092r07\fc\interface\interface.hpp higan_v092r08\fc\interface\interface.hpp
--- higan_v092r07\fc\interface\interface.hpp	Mon Jan 21 01:18:26 2013
+++ higan_v092r08\fc\interface\interface.hpp	Thu May 02 05:56:49 2013
@@ -32,8 +32,8 @@
   unsigned group(unsigned id);
   void load(unsigned id);
   void save();
-  void load(unsigned id, const stream &stream);
-  void save(unsigned id, const stream &stream);
+  void load(unsigned id, const stream& stream);
+  void save(unsigned id, const stream& stream);
   void unload();
 
   void power();
@@ -53,7 +53,7 @@
   vector<Device> device;
 };
 
-extern Interface *interface;
+extern Interface* interface;
 
 #ifndef FC_HPP
 }
diff -ru higan_v092r07\gb\interface\interface.cpp higan_v092r08\gb\interface\interface.cpp
--- higan_v092r07\gb\interface\interface.cpp	Mon Jan 21 01:22:07 2013
+++ higan_v092r08\gb\interface\interface.cpp	Thu May 02 06:01:37 2013
@@ -2,7 +2,7 @@
 
 namespace GameBoy {
 
-Interface *interface = nullptr;
+Interface* interface = nullptr;
 
 void Interface::lcdScanline() {
   if(hook) hook->lcdScanline();
@@ -62,7 +62,7 @@
   }
 }
 
-void Interface::load(unsigned id, const stream &stream) {
+void Interface::load(unsigned id, const stream& stream) {
   if(id == ID::GameBoyBootROM) {
     stream.read(system.bootROM.dmg, min( 256u, stream.size()));
   }
@@ -86,7 +86,7 @@
   }
 }
 
-void Interface::save(unsigned id, const stream &stream) {
+void Interface::save(unsigned id, const stream& stream) {
   if(id == ID::RAM) {
     stream.write(cartridge.ramdata, cartridge.ramsize);
   }
@@ -114,15 +114,15 @@
   return system.serialize();
 }
 
-bool Interface::unserialize(serializer &s) {
+bool Interface::unserialize(serializer& s) {
   return system.unserialize(s);
 }
 
-void Interface::cheatSet(const lstring &list) {
+void Interface::cheatSet(const lstring& list) {
   cheat.reset();
-  for(auto &code : list) {
+  for(auto& code : list) {
     lstring codelist = code.split("+");
-    for(auto &part : codelist) {
+    for(auto& part : codelist) {
       unsigned addr, data, comp;
       if(Cheat::decode(part, addr, data, comp)) cheat.append({addr, data, comp});
     }
diff -ru higan_v092r07\gb\interface\interface.hpp higan_v092r08\gb\interface\interface.hpp
--- higan_v092r07\gb\interface\interface.hpp	Mon Jan 21 01:21:14 2013
+++ higan_v092r08\gb\interface\interface.hpp	Thu May 02 06:01:00 2013
@@ -30,7 +30,8 @@
   struct Hook {
     virtual void lcdScanline() {}
     virtual void joypWrite(bool p15, bool p14) {}
-  } *hook;
+  };
+  Hook* hook = nullptr;
 
   void lcdScanline();
   void joypWrite(bool p15, bool p14);
@@ -44,8 +45,8 @@
   unsigned group(unsigned id);
   void load(unsigned id);
   void save();
-  void load(unsigned id, const stream &stream);
-  void save(unsigned id, const stream &stream);
+  void load(unsigned id, const stream& stream);
+  void save(unsigned id, const stream& stream);
   void unload();
 
   void power();
@@ -65,7 +66,7 @@
   vector<Device> device;
 };
 
-extern Interface *interface;
+extern Interface* interface;
 
 #ifndef GB_HPP
 }
diff -ru higan_v092r07\gba\interface\interface.cpp higan_v092r08\gba\interface\interface.cpp
--- higan_v092r07\gba\interface\interface.cpp	Mon Jan 21 01:24:29 2013
+++ higan_v092r08\gba\interface\interface.cpp	Thu May 02 06:02:50 2013
@@ -2,7 +2,7 @@
 
 namespace GameBoyAdvance {
 
-Interface *interface = nullptr;
+Interface* interface = nullptr;
 
 string Interface::title() {
   return cartridge.title();
@@ -40,12 +40,12 @@
 }
 
 void Interface::save() {
-  for(auto &memory : cartridge.memory) {
+  for(auto& memory : cartridge.memory) {
     interface->saveRequest(memory.id, memory.name);
   }
 }
 
-void Interface::load(unsigned id, const stream &stream) {
+void Interface::load(unsigned id, const stream& stream) {
   if(id == ID::BIOS) {
     stream.read(bios.data, min(bios.size, stream.size()));
   }
@@ -69,7 +69,7 @@
   }
 }
 
-void Interface::save(unsigned id, const stream &stream) {
+void Interface::save(unsigned id, const stream& stream) {
   if(id == ID::RAM) {
     stream.write(cartridge.ram.data, cartridge.ram.size);
   }
@@ -105,7 +105,7 @@
   return system.serialize();
 }
 
-bool Interface::unserialize(serializer &s) {
+bool Interface::unserialize(serializer& s) {
   return system.unserialize(s);
 }
 
diff -ru higan_v092r07\gba\interface\interface.hpp higan_v092r08\gba\interface\interface.hpp
--- higan_v092r07\gba\interface\interface.hpp	Mon Jan 21 01:23:23 2013
+++ higan_v092r08\gba\interface\interface.hpp	Thu May 02 06:02:13 2013
@@ -32,8 +32,8 @@
   unsigned group(unsigned id);
   void load(unsigned id);
   void save();
-  void load(unsigned id, const stream &stream);
-  void save(unsigned id, const stream &stream);
+  void load(unsigned id, const stream& stream);
+  void save(unsigned id, const stream& stream);
   void unload();
 
   void power();
@@ -51,7 +51,7 @@
   vector<Device> device;
 };
 
-extern Interface *interface;
+extern Interface* interface;
 
 #ifndef GBA_HPP
 }
diff -ru higan_v092r07\nall\algorithm.hpp higan_v092r08\nall\algorithm.hpp
--- higan_v092r07\nall\algorithm.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\algorithm.hpp	Thu May 02 05:48:01 2013
@@ -5,13 +5,15 @@
 #undef max
 
 namespace nall {
-  template<typename T, typename U> T min(const T &t, const U &u) {
-    return t < u ? t : u;
-  }
 
-  template<typename T, typename U> T max(const T &t, const U &u) {
-    return t > u ? t : u;
-  }
+template<typename T, typename U> T min(const T& t, const U& u) {
+  return t < u ? t : u;
+}
+
+template<typename T, typename U> T max(const T& t, const U& u) {
+  return t > u ? t : u;
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\any.hpp higan_v092r08\nall\any.hpp
--- higan_v092r07\nall\any.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\any.hpp	Thu May 02 05:48:01 2013
@@ -5,69 +5,73 @@
 #include <nall/traits.hpp>
 
 namespace nall {
-  struct any {
-    bool empty() const { return container; }
-    const std::type_info& type() const { return container ? container->type() : typeid(void); }
-
-    template<typename T> any& operator=(const T& value_) {
-      typedef typename type_if<
-        std::is_array<T>::value,
-        typename std::remove_extent<typename std::add_const<T>::type>::type*,
-        T
-      >::type auto_t;
-
-      if(type() == typeid(auto_t)) {
-        static_cast<holder<auto_t>*>(container)->value = (auto_t)value_;
-      } else {
-        if(container) delete container;
-        container = new holder<auto_t>((auto_t)value_);
-      }
 
-      return *this;
+struct any {
+  bool empty() const { return container; }
+  const std::type_info& type() const { return container ? container->type() : typeid(void); }
+
+  template<typename T> any& operator=(const T& value) {
+    typedef typename type_if<
+      std::is_array<T>::value,
+      typename std::remove_extent<typename std::add_const<T>::type>::type*,
+      T
+    >::type auto_t;
+
+    if(type() == typeid(auto_t)) {
+      static_cast<holder<auto_t>*>(container)->value = (auto_t)value;
+    } else {
+      if(container) delete container;
+      container = new holder<auto_t>((auto_t)value);
     }
 
-    any() : container(nullptr) {}
-    ~any() { if(container) delete container; }
-    template<typename T> any(const T& value_) : container(nullptr) { operator=(value_); }
-
-  private:
-    struct placeholder {
-      virtual const std::type_info& type() const = 0;
-    } *container;
-
-    template<typename T> struct holder : placeholder {
-      T value;
-      const std::type_info& type() const { return typeid(T); }
-      holder(const T& value_) : value(value_) {}
-    };
-
-    template<typename T> friend T any_cast(any&);
-    template<typename T> friend T any_cast(const any&);
-    template<typename T> friend T* any_cast(any*);
-    template<typename T> friend const T* any_cast(const any*);
+    return *this;
+  }
+
+  any() = default;
+  template<typename T> any(const T& value) { operator=(value); }
+  ~any() { if(container) delete container; }
+
+private:
+  struct placeholder {
+    virtual const std::type_info& type() const = 0;
   };
 
-  template<typename T> T any_cast(any &value) {
-    typedef typename std::remove_reference<T>::type nonref;
-    if(value.type() != typeid(nonref)) throw;
-    return static_cast<any::holder<nonref>*>(value.container)->value;
-  }
+  placeholder* container = nullptr;
 
-  template<typename T> T any_cast(const any &value) {
-    typedef const typename std::remove_reference<T>::type nonref;
-    if(value.type() != typeid(nonref)) throw;
-    return static_cast<any::holder<nonref>*>(value.container)->value;
-  }
+  template<typename T> struct holder : placeholder {
+    T value;
+    const std::type_info& type() const { return typeid(T); }
+    holder(const T& value) : value(value) {}
+  };
 
-  template<typename T> T* any_cast(any *value) {
-    if(!value || value->type() != typeid(T)) return nullptr;
-    return &static_cast<any::holder<T>*>(value->container)->value;
-  }
+  template<typename T> friend T any_cast(any&);
+  template<typename T> friend T any_cast(const any&);
+  template<typename T> friend T* any_cast(any*);
+  template<typename T> friend const T* any_cast(const any*);
+};
+
+template<typename T> T any_cast(any& value) {
+  typedef typename std::remove_reference<T>::type nonref;
+  if(value.type() != typeid(nonref)) throw;
+  return static_cast<any::holder<nonref>*>(value.container)->value;
+}
+
+template<typename T> T any_cast(const any& value) {
+  typedef const typename std::remove_reference<T>::type nonref;
+  if(value.type() != typeid(nonref)) throw;
+  return static_cast<any::holder<nonref>*>(value.container)->value;
+}
+
+template<typename T> T* any_cast(any* value) {
+  if(!value || value->type() != typeid(T)) return nullptr;
+  return &static_cast<any::holder<T>*>(value->container)->value;
+}
+
+template<typename T> const T* any_cast(const any* value) {
+  if(!value || value->type() != typeid(T)) return nullptr;
+  return &static_cast<any::holder<T>*>(value->container)->value;
+}
 
-  template<typename T> const T* any_cast(const any *value) {
-    if(!value || value->type() != typeid(T)) return nullptr;
-    return &static_cast<any::holder<T>*>(value->container)->value;
-  }
 }
 
 #endif
diff -ru higan_v092r07\nall\atoi.hpp higan_v092r08\nall\atoi.hpp
--- higan_v092r07\nall\atoi.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\atoi.hpp	Thu May 02 05:48:01 2013
@@ -5,34 +5,28 @@
 
 namespace nall {
 
-//note: this header is intended to form the base for user-defined literals;
-//once they are supported by GCC. eg:
-//unsigned operator "" b(const char *s) { return binary(s); }
-//-> signed data = 1001b;
-//(0b1001 is nicer, but is not part of the C++ standard)
-
-constexpr inline uintmax_t binary_(const char *s, uintmax_t sum = 0) {
+constexpr inline uintmax_t binary_(const char* s, uintmax_t sum = 0) {
   return (
     *s == '0' || *s == '1' ? binary_(s + 1, (sum << 1) | *s - '0') :
     sum
   );
 }
 
-constexpr inline uintmax_t octal_(const char *s, uintmax_t sum = 0) {
+constexpr inline uintmax_t octal_(const char* s, uintmax_t sum = 0) {
   return (
     *s >= '0' && *s <= '7' ? octal_(s + 1, (sum << 3) | *s - '0') :
     sum
   );
 }
 
-constexpr inline uintmax_t decimal_(const char *s, uintmax_t sum = 0) {
+constexpr inline uintmax_t decimal_(const char* s, uintmax_t sum = 0) {
   return (
     *s >= '0' && *s <= '9' ? decimal_(s + 1, (sum * 10) + *s - '0') :
     sum
   );
 }
 
-constexpr inline uintmax_t hex_(const char *s, uintmax_t sum = 0) {
+constexpr inline uintmax_t hex_(const char* s, uintmax_t sum = 0) {
   return (
     *s >= 'A' && *s <= 'F' ? hex_(s + 1, (sum << 4) | *s - 'A' + 10) :
     *s >= 'a' && *s <= 'f' ? hex_(s + 1, (sum << 4) | *s - 'a' + 10) :
@@ -43,7 +37,7 @@
 
 //
 
-constexpr inline uintmax_t binary(const char *s) {
+constexpr inline uintmax_t binary(const char* s) {
   return (
     *s == '0' && *(s + 1) == 'B' ? binary_(s + 2) :
     *s == '0' && *(s + 1) == 'b' ? binary_(s + 2) :
@@ -52,13 +46,13 @@
   );
 }
 
-constexpr inline uintmax_t octal(const char *s) {
+constexpr inline uintmax_t octal(const char* s) {
   return (
     octal_(s)
   );
 }
 
-constexpr inline intmax_t integer(const char *s) {
+constexpr inline intmax_t integer(const char* s) {
   return (
     *s == '+' ? +decimal_(s + 1) :
     *s == '-' ? -decimal_(s + 1) :
@@ -66,13 +60,13 @@
   );
 }
 
-constexpr inline uintmax_t decimal(const char *s) {
+constexpr inline uintmax_t decimal(const char* s) {
   return (
     decimal_(s)
   );
 }
 
-constexpr inline uintmax_t hex(const char *s) {
+constexpr inline uintmax_t hex(const char* s) {
   return (
     *s == '0' && *(s + 1) == 'X' ? hex_(s + 2) :
     *s == '0' && *(s + 1) == 'x' ? hex_(s + 2) :
@@ -81,7 +75,7 @@
   );
 }
 
-constexpr inline intmax_t numeral(const char *s) {
+constexpr inline intmax_t numeral(const char* s) {
   return (
     *s == '0' && *(s + 1) == 'X' ? hex_(s + 2) :
     *s == '0' && *(s + 1) == 'x' ? hex_(s + 2) :
@@ -94,7 +88,7 @@
   );
 }
 
-inline double fp(const char *s) {
+inline double fp(const char* s) {
   return atof(s);
 }
 
diff -ru higan_v092r07\nall\base64.hpp higan_v092r08\nall\base64.hpp
--- higan_v092r07\nall\base64.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\base64.hpp	Thu May 02 05:48:01 2013
@@ -5,114 +5,116 @@
 #include <nall/string.hpp>
 
 namespace nall {
-  struct base64 {
-    static bool encode(char *&output, const uint8_t* input, unsigned inlength) {
-      output = new char[inlength * 8 / 6 + 8]();
-
-      unsigned i = 0, o = 0;
-      while(i < inlength) {
-        switch(i % 3) {
-
-        case 0: {
-          output[o++] = enc(input[i] >> 2);
-          output[o] = enc((input[i] & 3) << 4);
-          break;
-        }
-
-        case 1: {
-          uint8_t prev = dec(output[o]);
-          output[o++] = enc(prev + (input[i] >> 4));
-          output[o] = enc((input[i] & 15) << 2);
-          break;
-        }
-
-        case 2: {
-          uint8_t prev = dec(output[o]);
-          output[o++] = enc(prev + (input[i] >> 6));
-          output[o++] = enc(input[i] & 63);
-          break;
-        }
 
-        }
+struct base64 {
+  static bool encode(char*& output, const uint8_t* input, unsigned inlength) {
+    output = new char[inlength * 8 / 6 + 8]();
+
+    unsigned i = 0, o = 0;
+    while(i < inlength) {
+      switch(i % 3) {
+
+      case 0: {
+        output[o++] = enc(input[i] >> 2);
+        output[o] = enc((input[i] & 3) << 4);
+        break;
+      }
 
-        i++;
+      case 1: {
+        uint8_t prev = dec(output[o]);
+        output[o++] = enc(prev + (input[i] >> 4));
+        output[o] = enc((input[i] & 15) << 2);
+        break;
       }
 
-      return true;
-    }
+      case 2: {
+        uint8_t prev = dec(output[o]);
+        output[o++] = enc(prev + (input[i] >> 6));
+        output[o++] = enc(input[i] & 63);
+        break;
+      }
+
+      }
 
-    static string encode(const string &data) {
-      char *buffer = nullptr;
-      encode(buffer, (const uint8_t*)(const char*)data, data.length());
-      string result = buffer;
-      delete[] buffer;
-      return result;
+      i++;
     }
 
-    static bool decode(uint8_t *&output, unsigned &outlength, const char *input) {
-      unsigned inlength = strlen(input), infix = 0;
-      output = new uint8_t[inlength + 1]();
-
-      unsigned i = 0, o = 0;
-      while(i < inlength) {
-        uint8_t x = dec(input[i]);
-
-        switch(i++ & 3) {
-
-        case 0: {
-          output[o] = x << 2;
-          break;
-        }
-
-        case 1: {
-          output[o++] |= x >> 4;
-          output[o] = (x & 15) << 4;
-          break;
-        }
-
-        case 2: {
-          output[o++] |= x >> 2;
-          output[o] = (x & 3) << 6;
-          break;
-        }
-
-        case 3: {
-          output[o++] |= x;
-          break;
-        }
+    return true;
+  }
+
+  static string encode(const string& data) {
+    char* buffer = nullptr;
+    encode(buffer, (const uint8_t*)(const char*)data, data.length());
+    string result = buffer;
+    delete[] buffer;
+    return result;
+  }
+
+  static bool decode(uint8_t*& output, unsigned& outlength, const char* input) {
+    unsigned inlength = strlen(input), infix = 0;
+    output = new uint8_t[inlength + 1]();
+
+    unsigned i = 0, o = 0;
+    while(i < inlength) {
+      uint8_t x = dec(input[i]);
+
+      switch(i++ & 3) {
 
-        }
+      case 0: {
+        output[o] = x << 2;
+        break;
       }
 
-      outlength = o;
-      return true;
-    }
+      case 1: {
+        output[o++] |= x >> 4;
+        output[o] = (x & 15) << 4;
+        break;
+      }
 
-    static string decode(const string &data) {
-      uint8_t *buffer = nullptr;
-      unsigned size = 0;
-      decode(buffer, size, (const char*)data);
-      string result = (const char*)buffer;
-      delete[] buffer;
-      return result;
-    }
+      case 2: {
+        output[o++] |= x >> 2;
+        output[o] = (x & 3) << 6;
+        break;
+      }
 
-  private:
-    static char enc(uint8_t n) {
-      //base64 for URL encodings (URL = -_, MIME = +/)
-      static char lookup_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
-      return lookup_table[n & 63];
-    }
+      case 3: {
+        output[o++] |= x;
+        break;
+      }
 
-    static uint8_t dec(char n) {
-      if(n >= 'A' && n <= 'Z') return n - 'A';
-      if(n >= 'a' && n <= 'z') return n - 'a' + 26;
-      if(n >= '0' && n <= '9') return n - '0' + 52;
-      if(n == '-') return 62;
-      if(n == '_') return 63;
-      return 0;
+      }
     }
-  };
+
+    outlength = o;
+    return true;
+  }
+
+  static string decode(const string& data) {
+    uint8_t* buffer = nullptr;
+    unsigned size = 0;
+    decode(buffer, size, (const char*)data);
+    string result = (const char*)buffer;
+    delete[] buffer;
+    return result;
+  }
+
+private:
+  static char enc(uint8_t n) {
+    //base64 for URL encodings (URL = -_, MIME = +/)
+    static char lookup_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
+    return lookup_table[n & 63];
+  }
+
+  static uint8_t dec(char n) {
+    if(n >= 'A' && n <= 'Z') return n - 'A';
+    if(n >= 'a' && n <= 'z') return n - 'a' + 26;
+    if(n >= '0' && n <= '9') return n - '0' + 52;
+    if(n == '-') return 62;
+    if(n == '_') return 63;
+    return 0;
+  }
+};
+
 }
 
 #endif
diff -ru higan_v092r07\nall\beat\archive.hpp higan_v092r08\nall\beat\archive.hpp
--- higan_v092r07\nall\beat\archive.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\beat\archive.hpp	Thu May 02 05:48:01 2013
@@ -6,7 +6,7 @@
 namespace nall {
 
 struct beatArchive : beatBase {
-  bool create(const string &beatname, string pathname, const string &metadata = "") {
+  bool create(const string& beatname, string pathname, const string& metadata = "") {
     if(fp.open(beatname, file::mode::write) == false) return false;
     if(pathname.endswith("/") == false) pathname.append("/");
 
@@ -44,7 +44,7 @@
     return true;
   }
 
-  bool unpack(const string &beatname, string pathname) {
+  bool unpack(const string& beatname, string pathname) {
     if(fp.open(beatname, file::mode::read) == false) return false;
     if(pathname.endswith("/") == false) pathname.append("/");
 
diff -ru higan_v092r07\nall\beat\base.hpp higan_v092r08\nall\beat\base.hpp
--- higan_v092r07\nall\beat\base.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\beat\base.hpp	Thu May 02 05:48:01 2013
@@ -8,15 +8,15 @@
   file fp;
   uint32_t checksum;
 
-  void ls(lstring &list, const string &path, const string &basepath) {
+  void ls(lstring& list, const string& path, const string& basepath) {
     lstring paths = directory::folders(path);
-    for(auto &pathname : paths) {
+    for(auto& pathname : paths) {
       list.append(string{path, pathname}.ltrim<1>(basepath));
       ls(list, {path, pathname}, basepath);
     }
 
     lstring files = directory::files(path);
-    for(auto &filename : files) {
+    for(auto& filename : files) {
       list.append(string{path, filename}.ltrim<1>(basepath));
     }
   }
@@ -36,7 +36,7 @@
     }
   }
 
-  void writeString(const string &text) {
+  void writeString(const string& text) {
     unsigned length = text.length();
     for(unsigned n = 0; n < length; n++) write(text[n]);
   }
diff -ru higan_v092r07\nall\beat\delta.hpp higan_v092r08\nall\beat\delta.hpp
--- higan_v092r07\nall\beat\delta.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\beat\delta.hpp	Thu May 02 05:48:01 2013
@@ -10,56 +10,56 @@
 namespace nall {
 
 struct bpsdelta {
-  inline void source(const uint8_t *data, unsigned size);
-  inline void target(const uint8_t *data, unsigned size);
+  inline void source(const uint8_t* data, unsigned size);
+  inline void target(const uint8_t* data, unsigned size);
 
-  inline bool source(const string &filename);
-  inline bool target(const string &filename);
-  inline bool create(const string &filename, const string &metadata = "");
+  inline bool source(const string& filename);
+  inline bool target(const string& filename);
+  inline bool create(const string& filename, const string& metadata = "");
 
 protected:
   enum : unsigned { SourceRead, TargetRead, SourceCopy, TargetCopy };
   enum : unsigned { Granularity = 1 };
 
   struct Node {
-    unsigned offset;
-    Node *next;
-    inline Node() : offset(0), next(nullptr) {}
-    inline ~Node() { if(next) delete next; }
+    unsigned offset = 0;
+    Node* next = nullptr;
+    Node() = default;
+    ~Node() { if(next) delete next; }
   };
 
   filemap sourceFile;
-  const uint8_t *sourceData;
+  const uint8_t* sourceData;
   unsigned sourceSize;
 
   filemap targetFile;
-  const uint8_t *targetData;
+  const uint8_t* targetData;
   unsigned targetSize;
 };
 
-void bpsdelta::source(const uint8_t *data, unsigned size) {
+void bpsdelta::source(const uint8_t* data, unsigned size) {
   sourceData = data;
   sourceSize = size;
 }
 
-void bpsdelta::target(const uint8_t *data, unsigned size) {
+void bpsdelta::target(const uint8_t* data, unsigned size) {
   targetData = data;
   targetSize = size;
 }
 
-bool bpsdelta::source(const string &filename) {
+bool bpsdelta::source(const string& filename) {
   if(sourceFile.open(filename, filemap::mode::read) == false) return false;
   source(sourceFile.data(), sourceFile.size());
   return true;
 }
 
-bool bpsdelta::target(const string &filename) {
+bool bpsdelta::target(const string& filename) {
   if(targetFile.open(filename, filemap::mode::read) == false) return false;
   target(targetFile.data(), targetFile.size());
   return true;
 }
 
-bool bpsdelta::create(const string &filename, const string &metadata) {
+bool bpsdelta::create(const string& filename, const string& metadata) {
   file modifyFile;
   if(modifyFile.open(filename, file::mode::write) == false) return false;
 
@@ -96,7 +96,8 @@
   encode(markupSize);
   for(unsigned n = 0; n < markupSize; n++) write(metadata[n]);
 
-  Node *sourceTree[65536], *targetTree[65536];
+  Node* sourceTree[65536];
+  Node* targetTree[65536];
   for(unsigned n = 0; n < 65536; n++) sourceTree[n] = nullptr, targetTree[n] = nullptr;
 
   //source tree creation
@@ -136,7 +137,7 @@
     }
 
     { //source copy
-      Node *node = sourceTree[symbol];
+      Node* node = sourceTree[symbol];
       while(node) {
         unsigned length = 0, x = node->offset, y = outputOffset;
         while(x < sourceSize && y < targetSize && sourceData[x++] == targetData[y++]) length++;
@@ -146,7 +147,7 @@
     }
 
     { //target copy
-      Node *node = targetTree[symbol];
+      Node* node = targetTree[symbol];
       while(node) {
         unsigned length = 0, x = node->offset, y = outputOffset;
         while(y < targetSize && targetData[x++] == targetData[y++]) length++;
diff -ru higan_v092r07\nall\beat\linear.hpp higan_v092r08\nall\beat\linear.hpp
--- higan_v092r07\nall\beat\linear.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\beat\linear.hpp	Thu May 02 05:48:01 2013
@@ -10,49 +10,49 @@
 namespace nall {
 
 struct bpslinear {
-  inline void source(const uint8_t *data, unsigned size);
-  inline void target(const uint8_t *data, unsigned size);
+  inline void source(const uint8_t* data, unsigned size);
+  inline void target(const uint8_t* data, unsigned size);
 
-  inline bool source(const string &filename);
-  inline bool target(const string &filename);
-  inline bool create(const string &filename, const string &metadata = "");
+  inline bool source(const string& filename);
+  inline bool target(const string& filename);
+  inline bool create(const string& filename, const string& metadata = "");
 
 protected:
   enum : unsigned { SourceRead, TargetRead, SourceCopy, TargetCopy };
   enum : unsigned { Granularity = 1 };
 
   filemap sourceFile;
-  const uint8_t *sourceData;
+  const uint8_t* sourceData;
   unsigned sourceSize;
 
   filemap targetFile;
-  const uint8_t *targetData;
+  const uint8_t* targetData;
   unsigned targetSize;
 };
 
-void bpslinear::source(const uint8_t *data, unsigned size) {
+void bpslinear::source(const uint8_t* data, unsigned size) {
   sourceData = data;
   sourceSize = size;
 }
 
-void bpslinear::target(const uint8_t *data, unsigned size) {
+void bpslinear::target(const uint8_t* data, unsigned size) {
   targetData = data;
   targetSize = size;
 }
 
-bool bpslinear::source(const string &filename) {
+bool bpslinear::source(const string& filename) {
   if(sourceFile.open(filename, filemap::mode::read) == false) return false;
   source(sourceFile.data(), sourceFile.size());
   return true;
 }
 
-bool bpslinear::target(const string &filename) {
+bool bpslinear::target(const string& filename) {
   if(targetFile.open(filename, filemap::mode::read) == false) return false;
   target(targetFile.data(), targetFile.size());
   return true;
 }
 
-bool bpslinear::create(const string &filename, const string &metadata) {
+bool bpslinear::create(const string& filename, const string& metadata) {
   file modifyFile;
   if(modifyFile.open(filename, file::mode::write) == false) return false;
 
diff -ru higan_v092r07\nall\beat\metadata.hpp higan_v092r08\nall\beat\metadata.hpp
--- higan_v092r07\nall\beat\metadata.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\beat\metadata.hpp	Thu May 02 05:48:01 2013
@@ -10,8 +10,8 @@
 namespace nall {
 
 struct bpsmetadata {
-  inline bool load(const string &filename);
-  inline bool save(const string &filename, const string &metadata);
+  inline bool load(const string& filename);
+  inline bool save(const string& filename, const string& metadata);
   inline string metadata() const;
 
 protected:
@@ -19,7 +19,7 @@
   string metadataString;
 };
 
-bool bpsmetadata::load(const string &filename) {
+bool bpsmetadata::load(const string& filename) {
   if(sourceFile.open(filename, file::mode::read) == false) return false;
 
   auto read = [&]() -> uint8_t {
@@ -53,7 +53,7 @@
   return true;
 }
 
-bool bpsmetadata::save(const string &filename, const string &metadata) {
+bool bpsmetadata::save(const string& filename, const string& metadata) {
   file targetFile;
   if(targetFile.open(filename, file::mode::write) == false) return false;
   if(sourceFile.open() == false) return false;
diff -ru higan_v092r07\nall\beat\multi.hpp higan_v092r08\nall\beat\multi.hpp
--- higan_v092r07\nall\beat\multi.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\beat\multi.hpp	Thu May 02 05:48:01 2013
@@ -20,7 +20,7 @@
     OriginTarget = 1,
   };
 
-  bool create(const string &patchName, const string &sourcePath, const string &targetPath, bool delta = false, const string &metadata = "") {
+  bool create(const string& patchName, const string& sourcePath, const string& targetPath, bool delta = false, const string& metadata = "") {
     if(fp.open()) fp.close();
     fp.open(patchName, file::mode::write);
     checksum = ~0;
@@ -33,7 +33,7 @@
     ls(sourceList, sourcePath, sourcePath);
     ls(targetList, targetPath, targetPath);
 
-    for(auto &targetName : targetList) {
+    for(auto& targetName : targetList) {
       if(targetName.endswith("/")) {
         targetName.rtrim<1>("/");
         writeNumber(CreatePath | ((targetName.length() - 1) << 2));
@@ -94,7 +94,7 @@
     return true;
   }
 
-  bool apply(const string &patchName, const string &sourcePath, const string &targetPath) {
+  bool apply(const string& patchName, const string& sourcePath, const string& targetPath) {
     directory::remove(targetPath);  //start with a clean directory
     directory::create(targetPath);
 
@@ -157,15 +157,15 @@
   uint32_t checksum;
 
   //create() functions
-  void ls(lstring &list, const string &path, const string &basepath) {
+  void ls(lstring& list, const string& path, const string& basepath) {
     lstring paths = directory::folders(path);
-    for(auto &pathname : paths) {
+    for(auto& pathname : paths) {
       list.append(string{path, pathname}.ltrim<1>(basepath));
       ls(list, {path, pathname}, basepath);
     }
 
     lstring files = directory::files(path);
-    for(auto &filename : files) {
+    for(auto& filename : files) {
       list.append(string{path, filename}.ltrim<1>(basepath));
     }
   }
@@ -188,7 +188,7 @@
     }
   }
 
-  void writeString(const string &text) {
+  void writeString(const string& text) {
     unsigned length = text.length();
     for(unsigned n = 0; n < length; n++) write(text[n]);
   }
diff -ru higan_v092r07\nall\beat\patch.hpp higan_v092r08\nall\beat\patch.hpp
--- higan_v092r07\nall\beat\patch.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\beat\patch.hpp	Thu May 02 05:48:01 2013
@@ -10,13 +10,13 @@
 namespace nall {
 
 struct bpspatch {
-  inline bool modify(const uint8_t *data, unsigned size);
-  inline void source(const uint8_t *data, unsigned size);
-  inline void target(uint8_t *data, unsigned size);
-
-  inline bool modify(const string &filename);
-  inline bool source(const string &filename);
-  inline bool target(const string &filename);
+  inline bool modify(const uint8_t* data, unsigned size);
+  inline void source(const uint8_t* data, unsigned size);
+  inline void target(uint8_t* data, unsigned size);
+
+  inline bool modify(const string& filename);
+  inline bool source(const string& filename);
+  inline bool target(const string& filename);
 
   inline string metadata() const;
   inline unsigned size() const;
@@ -39,15 +39,15 @@
   enum : unsigned { SourceRead, TargetRead, SourceCopy, TargetCopy };
 
   filemap modifyFile;
-  const uint8_t *modifyData;
+  const uint8_t* modifyData;
   unsigned modifySize;
 
   filemap sourceFile;
-  const uint8_t *sourceData;
+  const uint8_t* sourceData;
   unsigned sourceSize;
 
   filemap targetFile;
-  uint8_t *targetData;
+  uint8_t* targetData;
   unsigned targetSize;
 
   unsigned modifySourceSize;
@@ -56,7 +56,7 @@
   string metadataString;
 };
 
-bool bpspatch::modify(const uint8_t *data, unsigned size) {
+bool bpspatch::modify(const uint8_t* data, unsigned size) {
   if(size < 19) return false;
   modifyData = data;
   modifySize = size;
@@ -86,28 +86,28 @@
   return true;
 }
 
-void bpspatch::source(const uint8_t *data, unsigned size) {
+void bpspatch::source(const uint8_t* data, unsigned size) {
   sourceData = data;
   sourceSize = size;
 }
 
-void bpspatch::target(uint8_t *data, unsigned size) {
+void bpspatch::target(uint8_t* data, unsigned size) {
   targetData = data;
   targetSize = size;
 }
 
-bool bpspatch::modify(const string &filename) {
+bool bpspatch::modify(const string& filename) {
   if(modifyFile.open(filename, filemap::mode::read) == false) return false;
   return modify(modifyFile.data(), modifyFile.size());
 }
 
-bool bpspatch::source(const string &filename) {
+bool bpspatch::source(const string& filename) {
   if(sourceFile.open(filename, filemap::mode::read) == false) return false;
   source(sourceFile.data(), sourceFile.size());
   return true;
 }
 
-bool bpspatch::target(const string &filename) {
+bool bpspatch::target(const string& filename) {
   file fp;
   if(fp.open(filename, file::mode::write) == false) return false;
   fp.truncate(modifyTargetSize);
diff -ru higan_v092r07\nall\bit.hpp higan_v092r08\nall\bit.hpp
--- higan_v092r07\nall\bit.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\bit.hpp	Thu May 02 05:48:01 2013
@@ -4,79 +4,77 @@
 #include <nall/stdint.hpp>
 
 namespace nall {
-  template<unsigned bits>
-  inline uintmax_t uclamp(const uintmax_t x) {
-    enum : uintmax_t { b = 1ull << (bits - 1), y = b * 2 - 1 };
-    return y + ((x - y) & -(x < y));  //min(x, y);
-  }
-
-  template<unsigned bits>
-  inline uintmax_t uclip(const uintmax_t x) {
-    enum : uintmax_t { b = 1ull << (bits - 1), m = b * 2 - 1 };
-    return (x & m);
-  }
-
-  template<unsigned bits>
-  inline intmax_t sclamp(const intmax_t x) {
-    enum : intmax_t { b = 1ull << (bits - 1), m = b - 1 };
-    return (x > m) ? m : (x < -b) ? -b : x;
-  }
-
-  template<unsigned bits>
-  inline intmax_t sclip(const intmax_t x) {
-    enum : uintmax_t { b = 1ull << (bits - 1), m = b * 2 - 1 };
-    return ((x & m) ^ b) - b;
-  }
-
-  namespace bit {
-    constexpr inline uintmax_t mask(const char *s, uintmax_t sum = 0) {
-      return (
-        *s == '0' || *s == '1' ? mask(s + 1, (sum << 1) | 1) :
-        *s == ' ' || *s == '_' ? mask(s + 1, sum) :
-        *s ? mask(s + 1, sum << 1) :
-        sum
-      );
-    }
-
-    constexpr inline uintmax_t test(const char *s, uintmax_t sum = 0) {
-      return (
-        *s == '0' || *s == '1' ? test(s + 1, (sum << 1) | (*s - '0')) :
-        *s == ' ' || *s == '_' ? test(s + 1, sum) :
-        *s ? test(s + 1, sum << 1) :
-        sum
-      );
-    }
-
-    //lowest(0b1110) == 0b0010
-    constexpr inline uintmax_t lowest(const uintmax_t x) {
-      return x & -x;
-    }
-
-    //clear_lowest(0b1110) == 0b1100
-    constexpr inline uintmax_t clear_lowest(const uintmax_t x) {
-      return x & (x - 1);
-    }
-
-    //set_lowest(0b0101) == 0b0111
-    constexpr inline uintmax_t set_lowest(const uintmax_t x) {
-      return x | (x + 1);
-    }
-
-    //count number of bits set in a byte
-    inline unsigned count(uintmax_t x) {
-      unsigned count = 0;
-      do count += x & 1; while(x >>= 1);
-      return count;
-    }
-
-    //round up to next highest single bit:
-    //round(15) == 16, round(16) == 16, round(17) == 32
-    inline uintmax_t round(uintmax_t x) {
-      if((x & (x - 1)) == 0) return x;
-      while(x & (x - 1)) x &= x - 1;
-      return x << 1;
-    }
+
+template<unsigned bits> inline uintmax_t uclamp(const uintmax_t x) {
+  enum : uintmax_t { b = 1ull << (bits - 1), y = b * 2 - 1 };
+  return y + ((x - y) & -(x < y));  //min(x, y);
+}
+
+template<unsigned bits> inline uintmax_t uclip(const uintmax_t x) {
+  enum : uintmax_t { b = 1ull << (bits - 1), m = b * 2 - 1 };
+  return (x & m);
+}
+
+template<unsigned bits> inline intmax_t sclamp(const intmax_t x) {
+  enum : intmax_t { b = 1ull << (bits - 1), m = b - 1 };
+  return (x > m) ? m : (x < -b) ? -b : x;
+}
+
+template<unsigned bits> inline intmax_t sclip(const intmax_t x) {
+  enum : uintmax_t { b = 1ull << (bits - 1), m = b * 2 - 1 };
+  return ((x & m) ^ b) - b;
+}
+
+namespace bit {
+  constexpr inline uintmax_t mask(const char* s, uintmax_t sum = 0) {
+    return (
+      *s == '0' || *s == '1' ? mask(s + 1, (sum << 1) | 1) :
+      *s == ' ' || *s == '_' ? mask(s + 1, sum) :
+      *s ? mask(s + 1, sum << 1) :
+      sum
+    );
+  }
+
+  constexpr inline uintmax_t test(const char* s, uintmax_t sum = 0) {
+    return (
+      *s == '0' || *s == '1' ? test(s + 1, (sum << 1) | (*s - '0')) :
+      *s == ' ' || *s == '_' ? test(s + 1, sum) :
+      *s ? test(s + 1, sum << 1) :
+      sum
+    );
+  }
+
+  //lowest(0b1110) == 0b0010
+  constexpr inline uintmax_t lowest(const uintmax_t x) {
+    return x & -x;
+  }
+
+  //clear_lowest(0b1110) == 0b1100
+  constexpr inline uintmax_t clear_lowest(const uintmax_t x) {
+    return x & (x - 1);
   }
+
+  //set_lowest(0b0101) == 0b0111
+  constexpr inline uintmax_t set_lowest(const uintmax_t x) {
+    return x | (x + 1);
+  }
+
+  //count number of bits set in a byte
+  inline unsigned count(uintmax_t x) {
+    unsigned count = 0;
+    do count += x & 1; while(x >>= 1);
+    return count;
+  }
+
+  //round up to next highest single bit:
+  //round(15) == 16, round(16) == 16, round(17) == 32
+  inline uintmax_t round(uintmax_t x) {
+    if((x & (x - 1)) == 0) return x;
+    while(x & (x - 1)) x &= x - 1;
+    return x << 1;
+  }
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\bmp.hpp higan_v092r08\nall\bmp.hpp
--- higan_v092r07\nall\bmp.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\bmp.hpp	Thu May 02 05:48:01 2013
@@ -9,11 +9,11 @@
 namespace nall {
 
 struct bmp {
-  inline static bool read(const string &filename, uint32_t *&data, unsigned &width, unsigned &height);
-  inline static bool write(const string &filename, const uint32_t *data, unsigned width, unsigned height, unsigned pitch, bool alpha = false);
+  inline static bool read(const string& filename, uint32_t*& data, unsigned& width, unsigned& height);
+  inline static bool write(const string& filename, const uint32_t* data, unsigned width, unsigned height, unsigned pitch, bool alpha = false);
 };
 
-bool bmp::read(const string &filename, uint32_t *&data, unsigned &width, unsigned &height) {
+bool bmp::read(const string& filename, uint32_t*& data, unsigned& width, unsigned& height) {
   file fp;
   if(fp.open(filename, file::mode::read) == false) return false;
   if(fp.size() < 0x36) return false;
@@ -43,7 +43,7 @@
   while(alignedWidth % 4) alignedWidth++, paddingLength++;
 
   for(unsigned y = 0; y < height; y++) {
-    uint32_t *p = noFlip ? data + y * width : data + (height - 1 - y) * width;
+    uint32_t* p = noFlip ? data + y * width : data + (height - 1 - y) * width;
     for(unsigned x = 0; x < width; x++, p++) {
       *p = fp.readl(bytesPerPixel);
       if(bytesPerPixel == 3) *p |= 255 << 24;
@@ -55,7 +55,7 @@
   return true;
 }
 
-bool bmp::write(const string &filename, const uint32_t *data, unsigned width, unsigned height, unsigned pitch, bool alpha) {
+bool bmp::write(const string& filename, const uint32_t* data, unsigned width, unsigned height, unsigned pitch, bool alpha) {
   file fp;
   if(fp.open(filename, file::mode::write) == false) return false;
 
@@ -86,7 +86,7 @@
   fp.writel(0, 4);             //important color count
 
   for(unsigned y = 0; y < height; y++) {
-    const uint32_t *p = (const uint32_t*)((const uint8_t*)data + y * pitch);
+    const uint32_t* p = (const uint32_t*)((const uint8_t*)data + y * pitch);
     for(unsigned x = 0; x < width; x++) fp.writel(*p++, bytesPerPixel);
     if(paddingLength) fp.writel(0, paddingLength);
   }
diff -ru higan_v092r07\nall\compositor.hpp higan_v092r08\nall\compositor.hpp
--- higan_v092r07\nall\compositor.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\compositor.hpp	Thu May 02 05:48:01 2013
@@ -26,7 +26,7 @@
 //Metacity
 
 bool compositor::enabled_metacity() {
-  FILE *fp = popen("gconftool-2 --get /apps/metacity/general/compositing_manager", "r");
+  FILE* fp = popen("gconftool-2 --get /apps/metacity/general/compositing_manager", "r");
   if(!fp) return false;
 
   char buffer[512];
@@ -37,7 +37,7 @@
 }
 
 bool compositor::enable_metacity(bool status) {
-  FILE *fp;
+  FILE* fp;
   if(status) {
     fp = popen("gconftool-2 --set --type bool /apps/metacity/general/compositing_manager true", "r");
   } else {
@@ -51,7 +51,7 @@
 //Xfwm4
 
 bool compositor::enabled_xfwm4() {
-  FILE *fp = popen("xfconf-query -c xfwm4 -p '/general/use_compositing'", "r");
+  FILE* fp = popen("xfconf-query -c xfwm4 -p '/general/use_compositing'", "r");
   if(!fp) return false;
 
   char buffer[512];
@@ -62,7 +62,7 @@
 }
 
 bool compositor::enable_xfwm4(bool status) {
-  FILE *fp;
+  FILE* fp;
   if(status) {
     fp = popen("xfconf-query -c xfwm4 -p '/general/use_compositing' -t 'bool' -s 'true'", "r");
   } else {
@@ -78,7 +78,7 @@
 compositor::Compositor compositor::detect() {
   Compositor result = Compositor::Unknown;
 
-  FILE *fp;
+  FILE* fp;
   char buffer[512];
 
   fp = popen("pidof metacity", "r");
diff -ru higan_v092r07\nall\crc16.hpp higan_v092r08\nall\crc16.hpp
--- higan_v092r07\nall\crc16.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\crc16.hpp	Thu May 02 05:48:01 2013
@@ -4,22 +4,24 @@
 #include <nall/stdint.hpp>
 
 namespace nall {
-  inline uint16_t crc16_adjust(uint16_t crc16, uint8_t data) {
-    for(unsigned n = 0; n < 8; n++) {
-      if((crc16 & 1) ^ (data & 1)) crc16 = (crc16 >> 1) ^ 0x8408;
-      else crc16 >>= 1;
-      data >>= 1;
-    }
-    return crc16;
+
+inline uint16_t crc16_adjust(uint16_t crc16, uint8_t data) {
+  for(unsigned n = 0; n < 8; n++) {
+    if((crc16 & 1) ^ (data & 1)) crc16 = (crc16 >> 1) ^ 0x8408;
+    else crc16 >>= 1;
+    data >>= 1;
   }
+  return crc16;
+}
 
-  inline uint16_t crc16_calculate(const uint8_t *data, unsigned length) {
-    uint16_t crc16 = ~0;
-    for(unsigned n = 0; n < length; n++) {
-      crc16 = crc16_adjust(crc16, data[n]);
-    }
-    return ~crc16;
+inline uint16_t crc16_calculate(const uint8_t* data, unsigned length) {
+  uint16_t crc16 = ~0;
+  for(unsigned n = 0; n < length; n++) {
+    crc16 = crc16_adjust(crc16, data[n]);
   }
+  return ~crc16;
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\crc32.hpp higan_v092r08\nall\crc32.hpp
--- higan_v092r07\nall\crc32.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\crc32.hpp	Thu May 02 05:48:01 2013
@@ -4,63 +4,65 @@
 #include <nall/stdint.hpp>
 
 namespace nall {
-  const uint32_t crc32_table[256] = {
-    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
-    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
-    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
-    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
-    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
-    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
-    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
-    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
-    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
-    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
-    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
-    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
-    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
-    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
-    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
-    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
-    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
-    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
-    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
-    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
-    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
-    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
-    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
-    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
-    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
-    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
-    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
-    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
-    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
-    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
-    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
-    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
-    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
-    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
-    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
-    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
-    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
-    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
-    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
-    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
-    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
-    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
-    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
-  };
 
-  inline uint32_t crc32_adjust(uint32_t crc32, uint8_t input) {
-    return ((crc32 >> 8) & 0x00ffffff) ^ crc32_table[(crc32 ^ input) & 0xff];
-  }
+const uint32_t crc32_table[256] = {
+  0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+  0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+  0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+  0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+  0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+  0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+  0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+  0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+  0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+  0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+  0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+  0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+  0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+  0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+  0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+  0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+  0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+  0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+  0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+  0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+  0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+  0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+  0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+  0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+  0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+  0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+  0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+  0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+  0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+  0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+  0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+  0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+  0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+  0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+  0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+  0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+  0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+  0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+  0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+  0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+  0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+  0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+  0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+inline uint32_t crc32_adjust(uint32_t crc32, uint8_t input) {
+  return ((crc32 >> 8) & 0x00ffffff) ^ crc32_table[(crc32 ^ input) & 0xff];
+}
 
-  inline uint32_t crc32_calculate(const uint8_t *data, unsigned length) {
-    uint32_t crc32 = ~0;
-    for(unsigned i = 0; i < length; i++) {
-      crc32 = crc32_adjust(crc32, data[i]);
-    }
-    return ~crc32;
+inline uint32_t crc32_calculate(const uint8_t* data, unsigned length) {
+  uint32_t crc32 = ~0;
+  for(unsigned i = 0; i < length; i++) {
+    crc32 = crc32_adjust(crc32, data[i]);
   }
+  return ~crc32;
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\directory.hpp higan_v092r08\nall\directory.hpp
--- higan_v092r07\nall\directory.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\directory.hpp	Thu May 02 05:48:01 2013
@@ -18,80 +18,80 @@
 namespace nall {
 
 struct directory {
-  static bool create(const string &pathname, unsigned permissions = 0755);  //recursive
-  static bool remove(const string &pathname);  //recursive
-  static bool exists(const string &pathname);
+  static bool create(const string& pathname, unsigned permissions = 0755);  //recursive
+  static bool remove(const string& pathname);  //recursive
+  static bool exists(const string& pathname);
 
-  static lstring folders(const string &pathname, const string &pattern = "*") {
+  static lstring folders(const string& pathname, const string& pattern = "*") {
     lstring folders = directory::ufolders(pathname, pattern);
     folders.sort();
     return folders;
   }
 
-  static lstring files(const string &pathname, const string &pattern = "*") {
+  static lstring files(const string& pathname, const string& pattern = "*") {
     lstring files = directory::ufiles(pathname, pattern);
     files.sort();
     return files;
   }
 
-  static lstring contents(const string &pathname, const string &pattern = "*") {
+  static lstring contents(const string& pathname, const string& pattern = "*") {
     lstring folders = directory::ufolders(pathname);  //pattern search of contents should only filter files
     lstring files = directory::ufiles(pathname, pattern);
     folders.sort();
     files.sort();
-    for(auto &file : files) folders.append(file);
+    for(auto& file : files) folders.append(file);
     return folders;
   }
 
-  static lstring ifolders(const string &pathname, const string &pattern = "*") {
+  static lstring ifolders(const string& pathname, const string& pattern = "*") {
     lstring folders = ufolders(pathname, pattern);
     folders.isort();
     return folders;
   }
 
-  static lstring ifiles(const string &pathname, const string &pattern = "*") {
+  static lstring ifiles(const string& pathname, const string& pattern = "*") {
     lstring files = ufiles(pathname, pattern);
     files.isort();
     return files;
   }
 
-  static lstring icontents(const string &pathname, const string &pattern = "*") {
+  static lstring icontents(const string& pathname, const string& pattern = "*") {
     lstring folders = directory::ufolders(pathname);  //pattern search of contents should only filter files
     lstring files = directory::ufiles(pathname, pattern);
     folders.isort();
     files.isort();
-    for(auto &file : files) folders.append(file);
+    for(auto& file : files) folders.append(file);
     return folders;
   }
 
 private:
   //internal functions; these return unsorted lists
-  static lstring ufolders(const string &pathname, const string &pattern = "*");
-  static lstring ufiles(const string &pathname, const string &pattern = "*");
+  static lstring ufolders(const string& pathname, const string& pattern = "*");
+  static lstring ufiles(const string& pathname, const string& pattern = "*");
 };
 
 #if defined(PLATFORM_WINDOWS)
-  inline bool directory::create(const string &pathname, unsigned permissions) {
+  inline bool directory::create(const string& pathname, unsigned permissions) {
     string path;
     lstring list = string{pathname}.transform("\\", "/").rtrim<1>("/").split("/");
     bool result = true;
-    for(auto &part : list) {
+    for(auto& part : list) {
       path.append(part, "/");
       result &= (_wmkdir(utf16_t(path)) == 0);
     }
     return result;
   }
 
-  inline bool directory::remove(const string &pathname) {
+  inline bool directory::remove(const string& pathname) {
     lstring list = directory::contents(pathname);
-    for(auto &name : list) {
+    for(auto& name : list) {
       if(name.endswith("/")) directory::remove({pathname, name});
       else file::remove({pathname, name});
     }
     return _wrmdir(utf16_t(pathname)) == 0;
   }
 
-  inline bool directory::exists(const string &pathname) {
+  inline bool directory::exists(const string& pathname) {
     string name = pathname;
     name.trim<1>("\"");
     DWORD result = GetFileAttributes(utf16_t(name));
@@ -99,7 +99,7 @@
     return (result & FILE_ATTRIBUTE_DIRECTORY);
   }
 
-  inline lstring directory::ufolders(const string &pathname, const string &pattern) {
+  inline lstring directory::ufolders(const string& pathname, const string& pattern) {
     lstring list;
     string path = pathname;
     path.transform("/", "\\");
@@ -125,11 +125,11 @@
       }
       FindClose(handle);
     }
-    for(auto &name : list) name.append("/");  //must append after sorting
+    for(auto& name : list) name.append("/");  //must append after sorting
     return list;
   }
 
-  inline lstring directory::ufiles(const string &pathname, const string &pattern) {
+  inline lstring directory::ufiles(const string& pathname, const string& pattern) {
     lstring list;
     string path = pathname;
     path.transform("/", "\\");
@@ -154,37 +154,37 @@
     return list;
   }
 #else
-  inline bool directory::create(const string &pathname, unsigned permissions) {
+  inline bool directory::create(const string& pathname, unsigned permissions) {
     string path;
     lstring list = string{pathname}.rtrim<1>("/").split("/");
     bool result = true;
-    for(auto &part : list) {
+    for(auto& part : list) {
       path.append(part, "/");
       result &= (mkdir(path, permissions) == 0);
     }
     return result;
   }
 
-  inline bool directory::remove(const string &pathname) {
+  inline bool directory::remove(const string& pathname) {
     lstring list = directory::contents(pathname);
-    for(auto &name : list) {
+    for(auto& name : list) {
       if(name.endswith("/")) directory::remove({pathname, name});
       else file::remove({pathname, name});
     }
     return rmdir(pathname) == 0;
   }
 
-  inline bool directory::exists(const string &pathname) {
+  inline bool directory::exists(const string& pathname) {
     DIR *dp = opendir(pathname);
     if(!dp) return false;
     closedir(dp);
     return true;
   }
 
-  inline lstring directory::ufolders(const string &pathname, const string &pattern) {
+  inline lstring directory::ufolders(const string& pathname, const string& pattern) {
     lstring list;
-    DIR *dp;
-    struct dirent *ep;
+    DIR* dp;
+    struct dirent* ep;
     dp = opendir(pathname);
     if(dp) {
       while(ep = readdir(dp)) {
@@ -196,14 +196,14 @@
       }
       closedir(dp);
     }
-    for(auto &name : list) name.append("/");  //must append after sorting
+    for(auto& name : list) name.append("/");  //must append after sorting
     return list;
   }
 
-  inline lstring directory::ufiles(const string &pathname, const string &pattern) {
+  inline lstring directory::ufiles(const string& pathname, const string& pattern) {
     lstring list;
-    DIR *dp;
-    struct dirent *ep;
+    DIR* dp;
+    struct dirent* ep;
     dp = opendir(pathname);
     if(dp) {
       while(ep = readdir(dp)) {
diff -ru higan_v092r07\nall\dl.hpp higan_v092r08\nall\dl.hpp
--- higan_v092r07\nall\dl.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dl.hpp	Thu May 02 05:48:01 2013
@@ -16,102 +16,104 @@
 #endif
 
 namespace nall {
-  struct library {
-    explicit operator bool() const { return open(); }
-    bool open() const { return handle; }
-    bool open(const char*, const char* = "");
-    bool open_absolute(const char*);
-    void* sym(const char*);
-    void close();
-
-    library() : handle(0) {}
-    ~library() { close(); }
-
-    library& operator=(const library&) = delete;
-    library(const library&) = delete;
-
-  private:
-    uintptr_t handle;
-  };
-
-  #if defined(PLATFORM_X)
-  inline bool library::open(const char *name, const char *path) {
-    if(handle) close();
-    handle = (uintptr_t)dlopen(string(path, *path && !strend(path, "/") ? "/" : "", "lib", name, ".so"), RTLD_LAZY);
-    if(!handle) handle = (uintptr_t)dlopen(string("/usr/local/lib/lib", name, ".so"), RTLD_LAZY);
-    return handle;
-  }
-
-  inline bool library::open_absolute(const char *name) {
-    if(handle) close();
-    handle = (uintptr_t)dlopen(name, RTLD_LAZY);
-    return handle;
-  }
-
-  inline void* library::sym(const char *name) {
-    if(!handle) return nullptr;
-    return dlsym((void*)handle, name);
-  }
-
-  inline void library::close() {
-    if(!handle) return;
-    dlclose((void*)handle);
-    handle = 0;
-  }
-  #elif defined(PLATFORM_OSX)
-  inline bool library::open(const char *name, const char *path) {
-    if(handle) close();
-    handle = (uintptr_t)dlopen(string(path, *path && !strend(path, "/") ? "/" : "", "lib", name, ".dylib"), RTLD_LAZY);
-    if(!handle) handle = (uintptr_t)dlopen(string("/usr/local/lib/lib", name, ".dylib"), RTLD_LAZY);
-    return handle;
-  }
-
-  inline bool library::open_absolute(const char *name) {
-    if(handle) close();
-    handle = (uintptr_t)dlopen(name, RTLD_LAZY);
-    return handle;
-  }
-
-  inline void* library::sym(const char *name) {
-    if(!handle) return nullptr;
-    return dlsym((void*)handle, name);
-  }
-
-  inline void library::close() {
-    if(!handle) return;
-    dlclose((void*)handle);
-    handle = 0;
-  }
-  #elif defined(PLATFORM_WINDOWS)
-  inline bool library::open(const char *name, const char *path) {
-    if(handle) close();
-    string filepath(path, *path && !strend(path, "/") && !strend(path, "\\") ? "\\" : "", name, ".dll");
-    handle = (uintptr_t)LoadLibraryW(utf16_t(filepath));
-    return handle;
-  }
-
-  inline bool library::open_absolute(const char *name) {
-    if(handle) close();
-    handle = (uintptr_t)LoadLibraryW(utf16_t(name));
-    return handle;
-  }
-
-  inline void* library::sym(const char *name) {
-    if(!handle) return nullptr;
-    return (void*)GetProcAddress((HMODULE)handle, name);
-  }
-
-  inline void library::close() {
-    if(!handle) return;
-    FreeLibrary((HMODULE)handle);
-    handle = 0;
-  }
-  #else
-  inline bool library::open(const char*, const char*) { return false; }
-  inline bool library::open_absolute(const char*) { return false; }
-  inline void* library::sym(const char*) { return nullptr; }
-  inline void library::close() {}
-  #endif
+
+struct library {
+  explicit operator bool() const { return open(); }
+  bool open() const { return handle; }
+  bool open(const string&, const string& = "");
+  bool open_absolute(const string&);
+  void* sym(const string&);
+  void close();
+
+  library() = default;
+  ~library() { close(); }
+
+  library& operator=(const library&) = delete;
+  library(const library&) = delete;
+
+private:
+  uintptr_t handle = 0;
 };
+
+#if defined(PLATFORM_X)
+inline bool library::open(const string& name, const string& path) {
+  if(handle) close();
+  handle = (uintptr_t)dlopen(string(path, !path.empty() && !path.endswith("/") ? "/" : "", "lib", name, ".so"), RTLD_LAZY);
+  if(!handle) handle = (uintptr_t)dlopen(string("/usr/local/lib/lib", name, ".so"), RTLD_LAZY);
+  return handle;
+}
+
+inline bool library::open_absolute(const string& name) {
+  if(handle) close();
+  handle = (uintptr_t)dlopen(name, RTLD_LAZY);
+  return handle;
+}
+
+inline void* library::sym(const string& name) {
+  if(!handle) return nullptr;
+  return dlsym((void*)handle, name);
+}
+
+inline void library::close() {
+  if(!handle) return;
+  dlclose((void*)handle);
+  handle = 0;
+}
+#elif defined(PLATFORM_OSX)
+inline bool library::open(const string& name, const string& path) {
+  if(handle) close();
+  handle = (uintptr_t)dlopen(string(path, !path.empty() && !path.endswith("/") ? "/" : "", "lib", name, ".dylib"), RTLD_LAZY);
+  if(!handle) handle = (uintptr_t)dlopen(string("/usr/local/lib/lib", name, ".dylib"), RTLD_LAZY);
+  return handle;
+}
+
+inline bool library::open_absolute(const string& name) {
+  if(handle) close();
+  handle = (uintptr_t)dlopen(name, RTLD_LAZY);
+  return handle;
+}
+
+inline void* library::sym(const string& name) {
+  if(!handle) return nullptr;
+  return dlsym((void*)handle, name);
+}
+
+inline void library::close() {
+  if(!handle) return;
+  dlclose((void*)handle);
+  handle = 0;
+}
+#elif defined(PLATFORM_WINDOWS)
+inline bool library::open(const string& name, const string& path) {
+  if(handle) close();
+  string filepath(path, !path.empty() && !path.endswith("/") && !path.endswith("\\") ? "/" : "", name, ".dll");
+  handle = (uintptr_t)LoadLibraryW(utf16_t(filepath));
+  return handle;
+}
+
+inline bool library::open_absolute(const string& name) {
+  if(handle) close();
+  handle = (uintptr_t)LoadLibraryW(utf16_t(name));
+  return handle;
+}
+
+inline void* library::sym(const string& name) {
+  if(!handle) return nullptr;
+  return (void*)GetProcAddress((HMODULE)handle, name);
+}
+
+inline void library::close() {
+  if(!handle) return;
+  FreeLibrary((HMODULE)handle);
+  handle = 0;
+}
+#else
+inline bool library::open(const string&, const string&) { return false; }
+inline bool library::open_absolute(const string&) { return false; }
+inline void* library::sym(const string&) { return nullptr; }
+inline void library::close() {}
+#endif
+
+}
 
 #endif
diff -ru higan_v092r07\nall\dsp\buffer.hpp higan_v092r08\nall\dsp\buffer.hpp
--- higan_v092r07\nall\dsp\buffer.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\buffer.hpp	Thu May 02 05:48:01 2013
@@ -1,7 +1,7 @@
 #ifdef NALL_DSP_INTERNAL_HPP
 
 struct Buffer {
-  double **sample = nullptr;
+  double** sample = nullptr;
   uint16_t rdoffset = 0;
   uint16_t wroffset = 0;
   unsigned channels = 0;
diff -ru higan_v092r07\nall\dsp\core.hpp higan_v092r08\nall\dsp\core.hpp
--- higan_v092r07\nall\dsp\core.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\core.hpp	Thu May 02 05:48:01 2013
@@ -12,13 +12,13 @@
 struct DSP;
 
 struct Resampler {
-  DSP &dsp;
+  DSP& dsp;
   real frequency;
 
   virtual void setFrequency() = 0;
   virtual void clear() = 0;
   virtual void sample() = 0;
-  Resampler(DSP &dsp) : dsp(dsp) {}
+  Resampler(DSP& dsp) : dsp(dsp) {}
 };
 
 struct DSP {
@@ -70,7 +70,7 @@
     real intensityInverse;
   } settings;
 
-  Resampler *resampler = nullptr;
+  Resampler* resampler = nullptr;
   inline void write(real channel[]);
 
   #include "buffer.hpp"
diff -ru higan_v092r07\nall\dsp\resample\average.hpp higan_v092r08\nall\dsp\resample\average.hpp
--- higan_v092r07\nall\dsp\resample\average.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\average.hpp	Thu May 02 05:48:01 2013
@@ -5,7 +5,7 @@
   inline void clear();
   inline void sample();
   inline void sampleLinear();
-  ResampleAverage(DSP &dsp) : Resampler(dsp) {}
+  ResampleAverage(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\cosine.hpp higan_v092r08\nall\dsp\resample\cosine.hpp
--- higan_v092r07\nall\dsp\resample\cosine.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\cosine.hpp	Thu May 02 05:48:01 2013
@@ -4,7 +4,7 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  ResampleCosine(DSP &dsp) : Resampler(dsp) {}
+  ResampleCosine(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\cubic.hpp higan_v092r08\nall\dsp\resample\cubic.hpp
--- higan_v092r07\nall\dsp\resample\cubic.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\cubic.hpp	Thu May 02 05:48:01 2013
@@ -4,7 +4,7 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  ResampleCubic(DSP &dsp) : Resampler(dsp) {}
+  ResampleCubic(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\hermite.hpp higan_v092r08\nall\dsp\resample\hermite.hpp
--- higan_v092r07\nall\dsp\resample\hermite.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\hermite.hpp	Thu May 02 05:48:01 2013
@@ -4,7 +4,7 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  ResampleHermite(DSP &dsp) : Resampler(dsp) {}
+  ResampleHermite(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\linear.hpp higan_v092r08\nall\dsp\resample\linear.hpp
--- higan_v092r07\nall\dsp\resample\linear.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\linear.hpp	Thu May 02 05:48:01 2013
@@ -4,7 +4,7 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  ResampleLinear(DSP &dsp) : Resampler(dsp) {}
+  ResampleLinear(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\nearest.hpp higan_v092r08\nall\dsp\resample\nearest.hpp
--- higan_v092r07\nall\dsp\resample\nearest.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\nearest.hpp	Thu May 02 05:48:01 2013
@@ -4,7 +4,7 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  ResampleNearest(DSP &dsp) : Resampler(dsp) {}
+  ResampleNearest(DSP& dsp) : Resampler(dsp) {}
 
   real fraction;
   real step;
diff -ru higan_v092r07\nall\dsp\resample\sinc.hpp higan_v092r08\nall\dsp\resample\sinc.hpp
--- higan_v092r07\nall\dsp\resample\sinc.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\dsp\resample\sinc.hpp	Thu May 02 05:48:01 2013
@@ -6,11 +6,11 @@
   inline void setFrequency();
   inline void clear();
   inline void sample();
-  inline ResampleSinc(DSP &dsp);
+  inline ResampleSinc(DSP& dsp);
 
 private:
   inline void remakeSinc();
-  SincResample *sinc_resampler[8];
+  SincResample* sinc_resampler[8];
 };
 
 void ResampleSinc::setFrequency() {
@@ -38,7 +38,7 @@
   dsp.buffer.rdoffset++;
 }
 
-ResampleSinc::ResampleSinc(DSP &dsp) : Resampler(dsp) {
+ResampleSinc::ResampleSinc(DSP& dsp) : Resampler(dsp) {
   for(unsigned n = 0; n < 8; n++) sinc_resampler[n] = nullptr;
 }
 
diff -ru higan_v092r07\nall\emulation\super-famicom-usart.hpp higan_v092r08\nall\emulation\super-famicom-usart.hpp
--- higan_v092r07\nall\emulation\super-famicom-usart.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\emulation\super-famicom-usart.hpp	Thu May 02 05:48:01 2013
@@ -83,7 +83,7 @@
   usart_sigint = true;
 }
 
-int main(int argc, char **argv) {
+int main(int argc, char** argv) {
   setpriority(PRIO_PROCESS, 0, -20);  //requires superuser privileges; otherwise priority = +0
   signal(SIGINT, sigint);
 
diff -ru higan_v092r07\nall\file.hpp higan_v092r08\nall\file.hpp
--- higan_v092r07\nall\file.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\file.hpp	Thu May 02 05:48:01 2013
@@ -9,346 +9,348 @@
 #include <nall/stream/memory.hpp>
 
 namespace nall {
-  inline FILE* fopen_utf8(const string &utf8_filename, const char *mode) {
+
+inline FILE* fopen_utf8(const string& filename, const string& mode) {
+  #if !defined(_WIN32)
+  return fopen(filename, mode);
+  #else
+  return _wfopen(utf16_t(filename), utf16_t(mode));
+  #endif
+}
+
+struct file {
+  enum class mode : unsigned { read, write, modify, append, readwrite = modify, writeread = append };
+  enum class index : unsigned { absolute, relative };
+  enum class time : unsigned { create, modify, access };
+
+  static bool copy(const string& sourcename, const string& targetname) {
+    file rd, wr;
+    if(rd.open(sourcename, mode::read) == false) return false;
+    if(wr.open(targetname, mode::write) == false) return false;
+    for(unsigned n = 0; n < rd.size(); n++) wr.write(rd.read());
+    return true;
+  }
+
+  static bool move(const string& sourcename, const string& targetname) {
     #if !defined(_WIN32)
-    return fopen(utf8_filename, mode);
+    return rename(sourcename, targetname) == 0;
     #else
-    return _wfopen(utf16_t(utf8_filename), utf16_t(mode));
+    return _wrename(utf16_t(sourcename), utf16_t(targetname)) == 0;
     #endif
   }
 
-  struct file {
-    enum class mode : unsigned { read, write, modify, append, readwrite = modify, writeread = append };
-    enum class index : unsigned { absolute, relative };
-    enum class time : unsigned { create, modify, access };
-
-    static bool copy(const string &sourcename, const string &targetname) {
-      file rd, wr;
-      if(rd.open(sourcename, mode::read) == false) return false;
-      if(wr.open(targetname, mode::write) == false) return false;
-      for(unsigned n = 0; n < rd.size(); n++) wr.write(rd.read());
-      return true;
-    }
-
-    static bool move(const string &sourcename, const string &targetname) {
-      #if !defined(_WIN32)
-      return rename(sourcename, targetname) == 0;
-      #else
-      return _wrename(utf16_t(sourcename), utf16_t(targetname)) == 0;
-      #endif
-    }
-
-    static bool remove(const string &filename) {
-      return unlink(filename) == 0;
-    }
-
-    static bool truncate(const string &filename, unsigned size) {
-      #if !defined(_WIN32)
-      return truncate(filename, size) == 0;
-      #else
-      bool result = false;
-      FILE *fp = fopen(filename, "rb+");
-      if(fp) {
-        result = _chsize(fileno(fp), size) == 0;
-        fclose(fp);
-      }
-      return result;
-      #endif
-    }
-
-    static vector<uint8_t> read(const string &filename) {
-      vector<uint8_t> memory;
-      file fp;
-      if(fp.open(filename, mode::read)) {
-        memory.resize(fp.size());
-        fp.read(memory.data(), memory.size());
-      }
-      return memory;
-    }
+  static bool remove(const string& filename) {
+    return unlink(filename) == 0;
+  }
 
-    static bool read(const string &filename, uint8_t *data, unsigned size) {
-      file fp;
-      if(fp.open(filename, mode::read) == false) return false;
-      fp.read(data, size);
-      fp.close();
-      return true;
+  static bool truncate(const string& filename, unsigned size) {
+    #if !defined(_WIN32)
+    return truncate(filename, size) == 0;
+    #else
+    bool result = false;
+    FILE* fp = fopen(filename, "rb+");
+    if(fp) {
+      result = _chsize(fileno(fp), size) == 0;
+      fclose(fp);
     }
+    return result;
+    #endif
+  }
 
-    static bool write(const string &filename, const string &text) {
-      file fp;
-      if(fp.open(filename, mode::write) == false) return false;
-      fp.print(text);
-      fp.close();
-      return true;
+  static vector<uint8_t> read(const string& filename) {
+    vector<uint8_t> memory;
+    file fp;
+    if(fp.open(filename, mode::read)) {
+      memory.resize(fp.size());
+      fp.read(memory.data(), memory.size());
     }
+    return memory;
+  }
 
-    static bool write(const string &filename, const vector<uint8_t> &buffer) {
-      file fp;
-      if(fp.open(filename, mode::write) == false) return false;
-      fp.write(buffer.data(), buffer.size());
-      fp.close();
-      return true;
-    }
+  static bool read(const string& filename, uint8_t* data, unsigned size) {
+    file fp;
+    if(fp.open(filename, mode::read) == false) return false;
+    fp.read(data, size);
+    fp.close();
+    return true;
+  }
 
-    static bool write(const string &filename, const uint8_t *data, unsigned size) {
-      file fp;
-      if(fp.open(filename, mode::write) == false) return false;
-      fp.write(data, size);
-      fp.close();
-      return true;
-    }
+  static bool write(const string& filename, const string& text) {
+    file fp;
+    if(fp.open(filename, mode::write) == false) return false;
+    fp.print(text);
+    fp.close();
+    return true;
+  }
 
-    static bool create(const string &filename) {
-      //create an empty file (will replace existing files)
-      file fp;
-      if(fp.open(filename, mode::write) == false) return false;
-      fp.close();
-      return true;
-    }
+  static bool write(const string& filename, const vector<uint8_t>& buffer) {
+    file fp;
+    if(fp.open(filename, mode::write) == false) return false;
+    fp.write(buffer.data(), buffer.size());
+    fp.close();
+    return true;
+  }
 
-    static string sha256(const string &filename) {
-      auto buffer = read(filename);
-      return nall::sha256(buffer.data(), buffer.size());
-    }
+  static bool write(const string& filename, const uint8_t* data, unsigned size) {
+    file fp;
+    if(fp.open(filename, mode::write) == false) return false;
+    fp.write(data, size);
+    fp.close();
+    return true;
+  }
 
-    uint8_t read() {
-      if(!fp) return 0xff;                       //file not open
-      if(file_mode == mode::write) return 0xff;  //reads not permitted
-      if(file_offset >= file_size) return 0xff;  //cannot read past end of file
-      buffer_sync();
-      return buffer[(file_offset++) & buffer_mask];
-    }
+  static bool create(const string& filename) {
+    //create an empty file (will replace existing files)
+    file fp;
+    if(fp.open(filename, mode::write) == false) return false;
+    fp.close();
+    return true;
+  }
 
-    uintmax_t readl(unsigned length = 1) {
-      uintmax_t data = 0;
-      for(int i = 0; i < length; i++) {
-        data |= (uintmax_t)read() << (i << 3);
-      }
-      return data;
-    }
+  static string sha256(const string& filename) {
+    auto buffer = read(filename);
+    return nall::sha256(buffer.data(), buffer.size());
+  }
 
-    uintmax_t readm(unsigned length = 1) {
-      uintmax_t data = 0;
-      while(length--) {
-        data <<= 8;
-        data |= read();
-      }
-      return data;
-    }
+  uint8_t read() {
+    if(!fp) return 0xff;                       //file not open
+    if(file_mode == mode::write) return 0xff;  //reads not permitted
+    if(file_offset >= file_size) return 0xff;  //cannot read past end of file
+    buffer_sync();
+    return buffer[(file_offset++) & buffer_mask];
+  }
 
-    void read(uint8_t *buffer, unsigned length) {
-      while(length--) *buffer++ = read();
+  uintmax_t readl(unsigned length = 1) {
+    uintmax_t data = 0;
+    for(int i = 0; i < length; i++) {
+      data |= (uintmax_t)read() << (i << 3);
     }
+    return data;
+  }
 
-    void write(uint8_t data) {
-      if(!fp) return;                      //file not open
-      if(file_mode == mode::read) return;  //writes not permitted
-      buffer_sync();
-      buffer[(file_offset++) & buffer_mask] = data;
-      buffer_dirty = true;
-      if(file_offset > file_size) file_size = file_offset;
+  uintmax_t readm(unsigned length = 1) {
+    uintmax_t data = 0;
+    while(length--) {
+      data <<= 8;
+      data |= read();
     }
+    return data;
+  }
 
-    void writel(uintmax_t data, unsigned length = 1) {
-      while(length--) {
-        write(data);
-        data >>= 8;
-      }
-    }
+  void read(uint8_t* buffer, unsigned length) {
+    while(length--) *buffer++ = read();
+  }
 
-    void writem(uintmax_t data, unsigned length = 1) {
-      for(int i = length - 1; i >= 0; i--) {
-        write(data >> (i << 3));
-      }
-    }
+  void write(uint8_t data) {
+    if(!fp) return;                      //file not open
+    if(file_mode == mode::read) return;  //writes not permitted
+    buffer_sync();
+    buffer[(file_offset++) & buffer_mask] = data;
+    buffer_dirty = true;
+    if(file_offset > file_size) file_size = file_offset;
+  }
 
-    void write(const uint8_t *buffer, unsigned length) {
-      while(length--) write(*buffer++);
+  void writel(uintmax_t data, unsigned length = 1) {
+    while(length--) {
+      write(data);
+      data >>= 8;
     }
+  }
 
-    template<typename... Args> void print(Args... args) {
-      string data(args...);
-      const char *p = data;
-      while(*p) write(*p++);
+  void writem(uintmax_t data, unsigned length = 1) {
+    for(int i = length - 1; i >= 0; i--) {
+      write(data >> (i << 3));
     }
+  }
 
-    void flush() {
-      buffer_flush();
-      fflush(fp);
-    }
+  void write(const uint8_t* buffer, unsigned length) {
+    while(length--) write(*buffer++);
+  }
 
-    void seek(int offset, index index_ = index::absolute) {
-      if(!fp) return;  //file not open
-      buffer_flush();
+  template<typename... Args> void print(Args... args) {
+    string data(args...);
+    const char* p = data;
+    while(*p) write(*p++);
+  }
 
-      uintmax_t req_offset = file_offset;
-      switch(index_) {
-        case index::absolute: req_offset  = offset; break;
-        case index::relative: req_offset += offset; break;
-      }
+  void flush() {
+    buffer_flush();
+    fflush(fp);
+  }
 
-      if(req_offset < 0) req_offset = 0;  //cannot seek before start of file
-      if(req_offset > file_size) {
-        if(file_mode == mode::read) {     //cannot seek past end of file
-          req_offset = file_size;
-        } else {                          //pad file to requested location
-          file_offset = file_size;
-          while(file_size < req_offset) write(0x00);
-        }
-      }
+  void seek(int offset, index index_ = index::absolute) {
+    if(!fp) return;  //file not open
+    buffer_flush();
 
-      file_offset = req_offset;
+    uintmax_t req_offset = file_offset;
+    switch(index_) {
+    case index::absolute: req_offset  = offset; break;
+    case index::relative: req_offset += offset; break;
     }
 
-    unsigned offset() const {
-      if(!fp) return 0;  //file not open
-      return file_offset;
-    }
-
-    unsigned size() const {
-      if(!fp) return 0;  //file not open
-      return file_size;
-    }
-
-    bool truncate(unsigned size) {
-      if(!fp) return false;  //file not open
-      #if !defined(_WIN32)
-      return ftruncate(fileno(fp), size) == 0;
-      #else
-      return _chsize(fileno(fp), size) == 0;
-      #endif
-    }
-
-    bool end() {
-      if(!fp) return true;  //file not open
-      return file_offset >= file_size;
-    }
-
-    static bool exists(const string &filename) {
-      #if !defined(_WIN32)
-      struct stat64 data;
-      if(stat64(filename, &data) != 0) return false;
-      #else
-      struct __stat64 data;
-      if(_wstat64(utf16_t(filename), &data) != 0) return false;
-      #endif
-      //return true if this is a file, and false if this is a directory
-      return !(data.st_mode & S_IFDIR);
-    }
-
-    static uintmax_t size(const string &filename) {
-      #if !defined(_WIN32)
-      struct stat64 data;
-      stat64(filename, &data);
-      #else
-      struct __stat64 data;
-      _wstat64(utf16_t(filename), &data);
-      #endif
-      return S_ISREG(data.st_mode) ? data.st_size : 0u;
-    }
-
-    static time_t timestamp(const string &filename, file::time mode = file::time::create) {
-      #if !defined(_WIN32)
-      struct stat64 data;
-      stat64(filename, &data);
-      #else
-      struct __stat64 data;
-      _wstat64(utf16_t(filename), &data);
-      #endif
-      switch(mode) { default:
-        case file::time::create: return data.st_ctime;
-        case file::time::modify: return data.st_mtime;
-        case file::time::access: return data.st_atime;
+    if(req_offset < 0) req_offset = 0;  //cannot seek before start of file
+    if(req_offset > file_size) {
+      if(file_mode == mode::read) {     //cannot seek past end of file
+        req_offset = file_size;
+      } else {                          //pad file to requested location
+        file_offset = file_size;
+        while(file_size < req_offset) write(0x00);
       }
     }
 
-    bool open() const {
-      return fp;
-    }
+    file_offset = req_offset;
+  }
 
-    explicit operator bool() const {
-      return open();
-    }
+  unsigned offset() const {
+    if(!fp) return 0;  //file not open
+    return file_offset;
+  }
 
-    bool open(const string &filename, mode mode_) {
-      if(fp) return false;
-
-      switch(file_mode = mode_) {
-        #if !defined(_WIN32)
-        case mode::read:      fp = fopen(filename, "rb" ); break;
-        case mode::write:     fp = fopen(filename, "wb+"); break;  //need read permission for buffering
-        case mode::readwrite: fp = fopen(filename, "rb+"); break;
-        case mode::writeread: fp = fopen(filename, "wb+"); break;
-        #else
-        case mode::read:      fp = _wfopen(utf16_t(filename), L"rb" ); break;
-        case mode::write:     fp = _wfopen(utf16_t(filename), L"wb+"); break;
-        case mode::readwrite: fp = _wfopen(utf16_t(filename), L"rb+"); break;
-        case mode::writeread: fp = _wfopen(utf16_t(filename), L"wb+"); break;
-        #endif
-      }
-      if(!fp) return false;
-      buffer_offset = -1;  //invalidate buffer
-      file_offset = 0;
-      fseek(fp, 0, SEEK_END);
-      file_size = ftell(fp);
-      fseek(fp, 0, SEEK_SET);
-      return true;
-    }
+  unsigned size() const {
+    if(!fp) return 0;  //file not open
+    return file_size;
+  }
 
-    void close() {
-      if(!fp) return;
-      buffer_flush();
-      fclose(fp);
-      fp = nullptr;
-    }
+  bool truncate(unsigned size) {
+    if(!fp) return false;  //file not open
+    #if !defined(_WIN32)
+    return ftruncate(fileno(fp), size) == 0;
+    #else
+    return _chsize(fileno(fp), size) == 0;
+    #endif
+  }
 
-    file() {
-    }
+  bool end() {
+    if(!fp) return true;  //file not open
+    return file_offset >= file_size;
+  }
 
-    file(const string &filename, mode mode_) {
-      open(filename, mode_);
-    }
+  static bool exists(const string& filename) {
+    #if !defined(_WIN32)
+    struct stat64 data;
+    if(stat64(filename, &data) != 0) return false;
+    #else
+    struct __stat64 data;
+    if(_wstat64(utf16_t(filename), &data) != 0) return false;
+    #endif
+    //return true if this is a file, and false if this is a directory
+    return !(data.st_mode & S_IFDIR);
+  }
 
-    ~file() {
-      close();
+  static uintmax_t size(const string& filename) {
+    #if !defined(_WIN32)
+    struct stat64 data;
+    stat64(filename, &data);
+    #else
+    struct __stat64 data;
+    _wstat64(utf16_t(filename), &data);
+    #endif
+    return S_ISREG(data.st_mode) ? data.st_size : 0u;
+  }
+
+  static time_t timestamp(const string& filename, file::time mode = file::time::create) {
+    #if !defined(_WIN32)
+    struct stat64 data;
+    stat64(filename, &data);
+    #else
+    struct __stat64 data;
+    _wstat64(utf16_t(filename), &data);
+    #endif
+    switch(mode) { default:
+    case file::time::create: return data.st_ctime;
+    case file::time::modify: return data.st_mtime;
+    case file::time::access: return data.st_atime;
     }
+  }
 
-    file& operator=(const file&) = delete;
-    file(const file&) = delete;
+  bool open() const {
+    return fp;
+  }
 
-  private:
-    enum { buffer_size = 1 << 12, buffer_mask = buffer_size - 1 };
-    char buffer[buffer_size] = {0};
-    int buffer_offset = -1;  //invalidate buffer
-    bool buffer_dirty = false;
-    FILE *fp = nullptr;
-    unsigned file_offset = 0;
-    unsigned file_size = 0;
-    mode file_mode = mode::read;
+  explicit operator bool() const {
+    return open();
+  }
 
-    void buffer_sync() {
-      if(!fp) return;  //file not open
-      if(buffer_offset != (file_offset & ~buffer_mask)) {
-        buffer_flush();
-        buffer_offset = file_offset & ~buffer_mask;
-        fseek(fp, buffer_offset, SEEK_SET);
-        unsigned length = (buffer_offset + buffer_size) <= file_size ? buffer_size : (file_size & buffer_mask);
-        if(length) unsigned unused = fread(buffer, 1, length, fp);
-      }
+  bool open(const string& filename, mode mode_) {
+    if(fp) return false;
+
+    switch(file_mode = mode_) {
+    #if !defined(_WIN32)
+    case mode::read:      fp = fopen(filename, "rb" ); break;
+    case mode::write:     fp = fopen(filename, "wb+"); break;  //need read permission for buffering
+    case mode::readwrite: fp = fopen(filename, "rb+"); break;
+    case mode::writeread: fp = fopen(filename, "wb+"); break;
+    #else
+    case mode::read:      fp = _wfopen(utf16_t(filename), L"rb" ); break;
+    case mode::write:     fp = _wfopen(utf16_t(filename), L"wb+"); break;
+    case mode::readwrite: fp = _wfopen(utf16_t(filename), L"rb+"); break;
+    case mode::writeread: fp = _wfopen(utf16_t(filename), L"wb+"); break;
+    #endif
     }
+    if(!fp) return false;
+    buffer_offset = -1;  //invalidate buffer
+    file_offset = 0;
+    fseek(fp, 0, SEEK_END);
+    file_size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+    return true;
+  }
+
+  void close() {
+    if(!fp) return;
+    buffer_flush();
+    fclose(fp);
+    fp = nullptr;
+  }
 
-    void buffer_flush() {
-      if(!fp) return;                      //file not open
-      if(file_mode == mode::read) return;  //buffer cannot be written to
-      if(buffer_offset < 0) return;        //buffer unused
-      if(buffer_dirty == false) return;    //buffer unmodified since read
+  file() {
+  }
+
+  file(const string& filename, mode mode_) {
+    open(filename, mode_);
+  }
+
+  ~file() {
+    close();
+  }
+
+  file& operator=(const file&) = delete;
+  file(const file&) = delete;
+
+private:
+  enum { buffer_size = 1 << 12, buffer_mask = buffer_size - 1 };
+  char buffer[buffer_size] = {0};
+  int buffer_offset = -1;  //invalidate buffer
+  bool buffer_dirty = false;
+  FILE *fp = nullptr;
+  unsigned file_offset = 0;
+  unsigned file_size = 0;
+  mode file_mode = mode::read;
+
+  void buffer_sync() {
+    if(!fp) return;  //file not open
+    if(buffer_offset != (file_offset & ~buffer_mask)) {
+      buffer_flush();
+      buffer_offset = file_offset & ~buffer_mask;
       fseek(fp, buffer_offset, SEEK_SET);
       unsigned length = (buffer_offset + buffer_size) <= file_size ? buffer_size : (file_size & buffer_mask);
-      if(length) unsigned unused = fwrite(buffer, 1, length, fp);
-      buffer_offset = -1;                  //invalidate buffer
-      buffer_dirty = false;
+      if(length) unsigned unused = fread(buffer, 1, length, fp);
     }
-  };
+  }
+
+  void buffer_flush() {
+    if(!fp) return;                      //file not open
+    if(file_mode == mode::read) return;  //buffer cannot be written to
+    if(buffer_offset < 0) return;        //buffer unused
+    if(buffer_dirty == false) return;    //buffer unmodified since read
+    fseek(fp, buffer_offset, SEEK_SET);
+    unsigned length = (buffer_offset + buffer_size) <= file_size ? buffer_size : (file_size & buffer_mask);
+    if(length) unsigned unused = fwrite(buffer, 1, length, fp);
+    buffer_offset = -1;                  //invalidate buffer
+    buffer_dirty = false;
+  }
+};
+
 }
 
 #endif
diff -ru higan_v092r07\nall\filemap.hpp higan_v092r08\nall\filemap.hpp
--- higan_v092r07\nall\filemap.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\filemap.hpp	Thu May 02 05:48:01 2013
@@ -18,197 +18,198 @@
 #endif
 
 namespace nall {
-  class filemap {
-  public:
-    enum class mode : unsigned { read, write, readwrite, writeread };
-
-    explicit operator bool() const { return open(); }
-    bool open() const { return p_open(); }
-    bool open(const char *filename, mode mode_) { return p_open(filename, mode_); }
-    void close() { return p_close(); }
-    unsigned size() const { return p_size; }
-    uint8_t* data() { return p_handle; }
-    const uint8_t* data() const { return p_handle; }
-    filemap() : p_size(0), p_handle(nullptr) { p_ctor(); }
-    filemap(const char *filename, mode mode_) : p_size(0), p_handle(nullptr) { p_ctor(); p_open(filename, mode_); }
-    ~filemap() { p_dtor(); }
-
-  private:
-    unsigned p_size;
-    uint8_t *p_handle;
-
-    #if defined(_WIN32)
-    //=============
-    //MapViewOfFile
-    //=============
-
-    HANDLE p_filehandle, p_maphandle;
-
-    bool p_open() const {
-      return p_handle;
-    }
-
-    bool p_open(const char *filename, mode mode_) {
-      if(file::exists(filename) && file::size(filename) == 0) {
-        p_handle = nullptr;
-        p_size = 0;
-        return true;
-      }
-
-      int desired_access, creation_disposition, flprotect, map_access;
-
-      switch(mode_) {
-        default: return false;
-        case mode::read:
-          desired_access = GENERIC_READ;
-          creation_disposition = OPEN_EXISTING;
-          flprotect = PAGE_READONLY;
-          map_access = FILE_MAP_READ;
-          break;
-        case mode::write:
-          //write access requires read access
-          desired_access = GENERIC_WRITE;
-          creation_disposition = CREATE_ALWAYS;
-          flprotect = PAGE_READWRITE;
-          map_access = FILE_MAP_ALL_ACCESS;
-          break;
-        case mode::readwrite:
-          desired_access = GENERIC_READ | GENERIC_WRITE;
-          creation_disposition = OPEN_EXISTING;
-          flprotect = PAGE_READWRITE;
-          map_access = FILE_MAP_ALL_ACCESS;
-          break;
-        case mode::writeread:
-          desired_access = GENERIC_READ | GENERIC_WRITE;
-          creation_disposition = CREATE_NEW;
-          flprotect = PAGE_READWRITE;
-          map_access = FILE_MAP_ALL_ACCESS;
-          break;
-      }
-
-      p_filehandle = CreateFileW(utf16_t(filename), desired_access, FILE_SHARE_READ, nullptr,
-        creation_disposition, FILE_ATTRIBUTE_NORMAL, nullptr);
-      if(p_filehandle == INVALID_HANDLE_VALUE) return false;
-
-      p_size = GetFileSize(p_filehandle, nullptr);
-
-      p_maphandle = CreateFileMapping(p_filehandle, nullptr, flprotect, 0, p_size, nullptr);
-      if(p_maphandle == INVALID_HANDLE_VALUE) {
-        CloseHandle(p_filehandle);
-        p_filehandle = INVALID_HANDLE_VALUE;
-        return false;
-      }
-
-      p_handle = (uint8_t*)MapViewOfFile(p_maphandle, map_access, 0, 0, p_size);
-      return p_handle;
-    }
-
-    void p_close() {
-      if(p_handle) {
-        UnmapViewOfFile(p_handle);
-        p_handle = nullptr;
-      }
-
-      if(p_maphandle != INVALID_HANDLE_VALUE) {
-        CloseHandle(p_maphandle);
-        p_maphandle = INVALID_HANDLE_VALUE;
-      }
-
-      if(p_filehandle != INVALID_HANDLE_VALUE) {
-        CloseHandle(p_filehandle);
-        p_filehandle = INVALID_HANDLE_VALUE;
-      }
-    }
 
-    void p_ctor() {
+struct filemap {
+  enum class mode : unsigned { read, write, readwrite, writeread };
+
+  explicit operator bool() const { return open(); }
+  bool open() const { return p_open(); }
+  bool open(const string& filename, mode mode_) { return p_open(filename, mode_); }
+  void close() { return p_close(); }
+  unsigned size() const { return p_size; }
+  uint8_t* data() { return p_handle; }
+  const uint8_t* data() const { return p_handle; }
+  filemap() { p_ctor(); }
+  filemap(const string& filename, mode mode_) { p_ctor(); p_open(filename, mode_); }
+  ~filemap() { p_dtor(); }
+
+private:
+  uint8_t *p_handle = nullptr;
+  unsigned p_size = 0;
+
+  #if defined(_WIN32)
+  //=============
+  //MapViewOfFile
+  //=============
+
+  HANDLE p_filehandle, p_maphandle;
+
+  bool p_open() const {
+    return p_handle;
+  }
+
+  bool p_open(const string& filename, mode mode_) {
+    if(file::exists(filename) && file::size(filename) == 0) {
+      p_handle = nullptr;
+      p_size = 0;
+      return true;
+    }
+
+    int desired_access, creation_disposition, flprotect, map_access;
+
+    switch(mode_) {
+    default: return false;
+    case mode::read:
+      desired_access = GENERIC_READ;
+      creation_disposition = OPEN_EXISTING;
+      flprotect = PAGE_READONLY;
+      map_access = FILE_MAP_READ;
+      break;
+    case mode::write:
+      //write access requires read access
+      desired_access = GENERIC_WRITE;
+      creation_disposition = CREATE_ALWAYS;
+      flprotect = PAGE_READWRITE;
+      map_access = FILE_MAP_ALL_ACCESS;
+      break;
+    case mode::readwrite:
+      desired_access = GENERIC_READ | GENERIC_WRITE;
+      creation_disposition = OPEN_EXISTING;
+      flprotect = PAGE_READWRITE;
+      map_access = FILE_MAP_ALL_ACCESS;
+      break;
+    case mode::writeread:
+      desired_access = GENERIC_READ | GENERIC_WRITE;
+      creation_disposition = CREATE_NEW;
+      flprotect = PAGE_READWRITE;
+      map_access = FILE_MAP_ALL_ACCESS;
+      break;
+    }
+
+    p_filehandle = CreateFileW(utf16_t(filename), desired_access, FILE_SHARE_READ, nullptr,
+      creation_disposition, FILE_ATTRIBUTE_NORMAL, nullptr);
+    if(p_filehandle == INVALID_HANDLE_VALUE) return false;
+
+    p_size = GetFileSize(p_filehandle, nullptr);
+
+    p_maphandle = CreateFileMapping(p_filehandle, nullptr, flprotect, 0, p_size, nullptr);
+    if(p_maphandle == INVALID_HANDLE_VALUE) {
+      CloseHandle(p_filehandle);
       p_filehandle = INVALID_HANDLE_VALUE;
-      p_maphandle  = INVALID_HANDLE_VALUE;
+      return false;
+    }
+
+    p_handle = (uint8_t*)MapViewOfFile(p_maphandle, map_access, 0, 0, p_size);
+    return p_handle;
+  }
+
+  void p_close() {
+    if(p_handle) {
+      UnmapViewOfFile(p_handle);
+      p_handle = nullptr;
     }
 
-    void p_dtor() {
-      close();
+    if(p_maphandle != INVALID_HANDLE_VALUE) {
+      CloseHandle(p_maphandle);
+      p_maphandle = INVALID_HANDLE_VALUE;
     }
 
-    #else
-    //====
-    //mmap
-    //====
-
-    int p_fd;
-
-    bool p_open() const {
-      return p_handle;
-    }
-
-    bool p_open(const char *filename, mode mode_) {
-      if(file::exists(filename) && file::size(filename) == 0) {
-        p_handle = nullptr;
-        p_size = 0;
-        return true;
-      }
-
-      int open_flags, mmap_flags;
-
-      switch(mode_) {
-        default: return false;
-        case mode::read:
-          open_flags = O_RDONLY;
-          mmap_flags = PROT_READ;
-          break;
-        case mode::write:
-          open_flags = O_RDWR | O_CREAT;  //mmap() requires read access
-          mmap_flags = PROT_WRITE;
-          break;
-        case mode::readwrite:
-          open_flags = O_RDWR;
-          mmap_flags = PROT_READ | PROT_WRITE;
-          break;
-        case mode::writeread:
-          open_flags = O_RDWR | O_CREAT;
-          mmap_flags = PROT_READ | PROT_WRITE;
-          break;
-      }
-
-      p_fd = ::open(filename, open_flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
-      if(p_fd < 0) return false;
-
-      struct stat p_stat;
-      fstat(p_fd, &p_stat);
-      p_size = p_stat.st_size;
-
-      p_handle = (uint8_t*)mmap(nullptr, p_size, mmap_flags, MAP_SHARED, p_fd, 0);
-      if(p_handle == MAP_FAILED) {
-        p_handle = nullptr;
-        ::close(p_fd);
-        p_fd = -1;
-        return false;
-      }
-
-      return p_handle;
-    }
-
-    void p_close() {
-      if(p_handle) {
-        munmap(p_handle, p_size);
-        p_handle = nullptr;
-      }
-
-      if(p_fd >= 0) {
-        ::close(p_fd);
-        p_fd = -1;
-      }
+    if(p_filehandle != INVALID_HANDLE_VALUE) {
+      CloseHandle(p_filehandle);
+      p_filehandle = INVALID_HANDLE_VALUE;
     }
+  }
 
-    void p_ctor() {
+  void p_ctor() {
+    p_filehandle = INVALID_HANDLE_VALUE;
+    p_maphandle  = INVALID_HANDLE_VALUE;
+  }
+
+  void p_dtor() {
+    close();
+  }
+
+  #else
+  //====
+  //mmap
+  //====
+
+  int p_fd;
+
+  bool p_open() const {
+    return p_handle;
+  }
+
+  bool p_open(const string& filename, mode mode_) {
+    if(file::exists(filename) && file::size(filename) == 0) {
+      p_handle = nullptr;
+      p_size = 0;
+      return true;
+    }
+
+    int open_flags, mmap_flags;
+
+    switch(mode_) {
+    default: return false;
+    case mode::read:
+      open_flags = O_RDONLY;
+      mmap_flags = PROT_READ;
+      break;
+    case mode::write:
+      open_flags = O_RDWR | O_CREAT;  //mmap() requires read access
+      mmap_flags = PROT_WRITE;
+      break;
+    case mode::readwrite:
+      open_flags = O_RDWR;
+      mmap_flags = PROT_READ | PROT_WRITE;
+      break;
+    case mode::writeread:
+      open_flags = O_RDWR | O_CREAT;
+      mmap_flags = PROT_READ | PROT_WRITE;
+      break;
+    }
+
+    p_fd = ::open(filename, open_flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
+    if(p_fd < 0) return false;
+
+    struct stat p_stat;
+    fstat(p_fd, &p_stat);
+    p_size = p_stat.st_size;
+
+    p_handle = (uint8_t*)mmap(nullptr, p_size, mmap_flags, MAP_SHARED, p_fd, 0);
+    if(p_handle == MAP_FAILED) {
+      p_handle = nullptr;
+      ::close(p_fd);
       p_fd = -1;
+      return false;
     }
 
-    void p_dtor() {
-      p_close();
+    return p_handle;
+  }
+
+  void p_close() {
+    if(p_handle) {
+      munmap(p_handle, p_size);
+      p_handle = nullptr;
+    }
+
+    if(p_fd >= 0) {
+      ::close(p_fd);
+      p_fd = -1;
     }
+  }
+
+  void p_ctor() {
+    p_fd = -1;
+  }
+
+  void p_dtor() {
+    p_close();
+  }
+
+  #endif
+};
 
-    #endif
-  };
 }
 
 #endif
diff -ru higan_v092r07\nall\function.hpp higan_v092r08\nall\function.hpp
--- higan_v092r07\nall\function.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\function.hpp	Thu May 02 05:48:01 2013
@@ -2,59 +2,63 @@
 #define NALL_FUNCTION_HPP
 
 namespace nall {
-  template<typename T> class function;
 
-  template<typename R, typename... P> class function<R (P...)> {
-    struct container {
-      virtual R operator()(P... p) const = 0;
-      virtual container* copy() const = 0;
-      virtual ~container() {}
-    } *callback;
-
-    struct global : container {
-      R (*function)(P...);
-      R operator()(P... p) const { return function(std::forward<P>(p)...); }
-      container* copy() const { return new global(function); }
-      global(R (*function)(P...)) : function(function) {}
-    };
-
-    template<typename C> struct member : container {
-      R (C::*function)(P...);
-      C *object;
-      R operator()(P... p) const { return (object->*function)(std::forward<P>(p)...); }
-      container* copy() const { return new member(function, object); }
-      member(R (C::*function)(P...), C *object) : function(function), object(object) {}
-    };
-
-    template<typename L> struct lambda : container {
-      mutable L object;
-      R operator()(P... p) const { return object(std::forward<P>(p)...); }
-      container* copy() const { return new lambda(object); }
-      lambda(const L& object) : object(object) {}
-    };
-
-  public:
-    explicit operator bool() const { return callback; }
-    R operator()(P... p) const { return (*callback)(std::forward<P>(p)...); }
-    void reset() { if(callback) { delete callback; callback = nullptr; } }
-
-    function& operator=(const function &source) {
-      if(this != &source) {
-        if(callback) { delete callback; callback = nullptr; }
-        if(source.callback) callback = source.callback->copy();
-      }
-      return *this;
-    }
+template<typename T> class function;
+
+template<typename R, typename... P> class function<R (P...)> {
+  struct container {
+    virtual R operator()(P... p) const = 0;
+    virtual container* copy() const = 0;
+    virtual ~container() {}
+  };
+
+  container* callback = nullptr;
+
+  struct global : container {
+    R (*function)(P...);
+    R operator()(P... p) const { return function(std::forward<P>(p)...); }
+    container* copy() const { return new global(function); }
+    global(R (*function)(P...)) : function(function) {}
+  };
 
-    function(const function &source) : callback(nullptr) { operator=(source); }
-    function() : callback(nullptr) {}
-    function(void *function) : callback(nullptr) { if(function) callback = new global((R (*)(P...))function); }
-    function(R (*function)(P...)) { callback = new global(function); }
-    template<typename C> function(R (C::*function)(P...), C *object) { callback = new member<C>(function, object); }
-    template<typename C> function(R (C::*function)(P...) const, C *object) { callback = new member<C>((R (C::*)(P...))function, object); }
-    template<typename L> function(const L& object) { callback = new lambda<L>(object); }
-    ~function() { if(callback) delete callback; }
+  template<typename C> struct member : container {
+    R (C::*function)(P...);
+    C* object;
+    R operator()(P... p) const { return (object->*function)(std::forward<P>(p)...); }
+    container* copy() const { return new member(function, object); }
+    member(R (C::*function)(P...), C* object) : function(function), object(object) {}
   };
+
+  template<typename L> struct lambda : container {
+    mutable L object;
+    R operator()(P... p) const { return object(std::forward<P>(p)...); }
+    container* copy() const { return new lambda(object); }
+    lambda(const L& object) : object(object) {}
+  };
+
+public:
+  explicit operator bool() const { return callback; }
+  R operator()(P... p) const { return (*callback)(std::forward<P>(p)...); }
+  void reset() { if(callback) { delete callback; callback = nullptr; } }
+
+  function& operator=(const function& source) {
+    if(this != &source) {
+      if(callback) { delete callback; callback = nullptr; }
+      if(source.callback) callback = source.callback->copy();
+    }
+    return *this;
+  }
+
+  function() = default;
+  function(const function &source) { operator=(source); }
+  function(void* function) { if(function) callback = new global((R (*)(P...))function); }
+  function(R (*function)(P...)) { callback = new global(function); }
+  template<typename C> function(R (C::*function)(P...), C* object) { callback = new member<C>(function, object); }
+  template<typename C> function(R (C::*function)(P...) const, C* object) { callback = new member<C>((R (C::*)(P...))function, object); }
+  template<typename L> function(const L& object) { callback = new lambda<L>(object); }
+  ~function() { if(callback) delete callback; }
+};
+
 }
 
 #endif
diff -ru higan_v092r07\nall\group.hpp higan_v092r08\nall\group.hpp
--- higan_v092r07\nall\group.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\group.hpp	Thu May 02 05:48:01 2013
@@ -1,132 +1,62 @@
 #ifndef NALL_GROUP_HPP
 #define NALL_GROUP_HPP
 
-//group: a vector of unique references
+//group
+//vector of unique references
 
-#include <stdlib.h>
-#include <algorithm>
-#include <initializer_list>
-#include <utility>
-#include <nall/bit.hpp>
-#include <nall/traits.hpp>
+#include <nall/vector.hpp>
 
 namespace nall {
 
-template<typename TR> struct group {
-  struct exception_out_of_bounds{};
-  typedef typename std::remove_reference<TR>::type T;
-
-protected:
-  T** pool = nullptr;
-  unsigned poolsize = 0;
-  unsigned objectsize = 0;
-
-public:
-  unsigned size() const { return objectsize; }
-  unsigned capacity() const { return poolsize; }
-
-  void reset() {
-    if(pool) free(pool);
-    pool = nullptr;
-    poolsize = 0;
-    objectsize = 0;
-  }
-
-  void reserve(unsigned size) {
-    if(size == poolsize) return;
-    pool = (T**)realloc(pool, sizeof(T*) * size);
-    poolsize = size;
-    objectsize = min(objectsize, size);
-  }
-
-  void resize(unsigned size) {
-    if(size > poolsize) reserve(bit::round(size));  //amortize growth
-    objectsize = size;
-  }
+template<typename T> struct group : protected vector<T*> {
+  group& operator=(const group& source) { vector<T*>::operator=(source); return *this; }
+  group& operator=(group&& source) { vector<T*>::operator=(std::move(source)); return *this; }
+  template<typename... Args> group(Args&&... args) { construct(std::forward<Args>(args)...); }
 
-  bool append(T& data) {
-    if(find(data)) return false;
-    unsigned offset = objectsize++;
-    if(offset >= poolsize) resize(offset + 1);
-    pool[offset] = &data;
-    return true;
-  }
+  bool empty() const { return vector<T*>::empty(); }
+  unsigned size() const { return vector<T*>::size(); }
+  void reset() { vector<T*>::reset(); }
 
-  template<typename... Args>
-  bool append(T& data, Args&&... args) {
-    bool result = append(data);
-    append(std::forward<Args>(args)...);
-    return result;
-  }
+  T& first() const { return *vector<T*>::operator[](0); }
 
-  bool remove(T& data) {
-    if(auto position = find(data)) {
-      for(signed i = position(); i < objectsize - 1; i++) pool[i] = pool[i + 1];
-      resize(objectsize - 1);
-      return true;
-    }
-    return false;
+  //return true if at least one item was appended
+  template<typename... Args> bool append(T& value, Args&&... args) {
+    bool result = append(value);
+    return append(std::forward<Args>(args)...) | result;
   }
 
-  optional<unsigned> find(const T& data) {
-    for(unsigned n = 0; n < objectsize; n++) if(pool[n] == &data) return {true, n};
-    return {false, 0u};
+  bool append(T& value) {
+    if(vector<T*>::find(&value)) return false;
+    return vector<T*>::append(&value), true;
   }
 
-  template<typename... Args> group(Args&&... args) {
-    construct(std::forward<Args>(args)...);
+  //return true if at least one item was removed
+  template<typename... Args> bool remove(T& value, Args&&... args) {
+    bool result = remove(value);
+    return remove(std::forward<Args>(args)...) | result;
   }
 
-  ~group() {
-    reset();
-  }
-
-  group& operator=(const group& source) {
-    if(&source == this) return *this;
-    reset();
-    reserve(source.poolsize);
-    resize(source.objectsize);
-    memcpy(pool, source.pool, sizeof(T*) * objectsize);
-    return *this;
-  }
-
-  group& operator=(const group&& source) {
-    if(&source == this) return *this;
-    reset();
-    pool = source.pool;
-    poolsize = source.poolsize;
-    objectsize = source.objectsize;
-    source.pool = nullptr;
-    source.reset();
-    return *this;
-  }
-
-  T& operator[](unsigned position) const {
-    if(position >= objectsize) throw exception_out_of_bounds();
-    return *pool[position];
+  bool remove(T& value) {
+    if(auto position = vector<T*>::find(&value)) return vector<T*>::remove(position()), true;
+    return false;
   }
 
-  struct iterator {
-    bool operator!=(const iterator& source) const { return position != source.position; }
-    T& operator*() { return source.operator[](position); }
-    iterator& operator++() { position++; return *this; }
-    iterator(const group& source, unsigned position) : source(source), position(position) {}
-  private:
-    const group& source;
-    unsigned position;
+  struct iterator : protected vector<T*>::const_iterator {
+    T& operator*() const { return *vector<T*>::const_iterator::operator*(); }
+    bool operator!=(const iterator& source) const { return vector<T*>::const_iterator::operator!=(source); }
+    iterator& operator++() { vector<T*>::const_iterator::operator++(); return *this; }
+    iterator(const group& source, unsigned position) : vector<T*>::const_iterator(source, position) {}
   };
 
-  iterator begin() { return iterator(*this, 0); }
-  iterator end() { return iterator(*this, objectsize); }
   const iterator begin() const { return iterator(*this, 0); }
-  const iterator end() const { return iterator(*this, objectsize); }
+  const iterator end() const { return iterator(*this, size()); }
 
 private:
   void construct() {}
-  void construct(const group& source) { operator=(source); }
-  void construct(const group&& source) { operator=(std::move(source)); }
-  template<typename... Args> void construct(T& data, Args&&... args) {
-    append(data);
+  void construct(const group& source) { vector<T*>::operator=(source); }
+  void construct(group&& source) { vector<T*>::operator=(std::move(source)); }
+  template<typename... Args> void construct(T& value, Args&&... args) {
+    append(value);
     construct(std::forward<Args>(args)...);
   }
 };
diff -ru higan_v092r07\nall\gzip.hpp higan_v092r08\nall\gzip.hpp
--- higan_v092r07\nall\gzip.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\gzip.hpp	Thu May 02 05:48:01 2013
@@ -8,24 +8,24 @@
 
 struct gzip {
   string filename;
-  uint8_t *data;
-  unsigned size;
+  uint8_t* data = nullptr;
+  unsigned size = 0;
 
-  inline bool decompress(const string &filename);
-  inline bool decompress(const uint8_t *data, unsigned size);
+  inline bool decompress(const string& filename);
+  inline bool decompress(const uint8_t* data, unsigned size);
 
   inline gzip();
   inline ~gzip();
 };
 
-bool gzip::decompress(const string &filename) {
+bool gzip::decompress(const string& filename) {
   if(auto memory = file::read(filename)) {
     return decompress(memory.data(), memory.size());
   }
   return false;
 }
 
-bool gzip::decompress(const uint8_t *data, unsigned size) {
+bool gzip::decompress(const uint8_t* data, unsigned size) {
   if(size < 18) return false;
   if(data[0] != 0x1f) return false;
   if(data[1] != 0x8b) return false;
@@ -73,7 +73,7 @@
   return inflate(this->data, this->size, data + p, size - p - 8);
 }
 
-gzip::gzip() : data(nullptr) {
+gzip::gzip() {
 }
 
 gzip::~gzip() {
diff -ru higan_v092r07\nall\http.hpp higan_v092r08\nall\http.hpp
--- higan_v092r07\nall\http.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\http.hpp	Thu May 02 05:48:01 2013
@@ -19,11 +19,11 @@
 
 struct http {
   string hostname;
-  addrinfo *serverinfo;
+  addrinfo* serverinfo;
   int serversocket;
   string header;
 
-  inline void download(const string &path, uint8_t *&data, unsigned &size) {
+  inline void download(const string& path, uint8_t*& data, unsigned& size) {
     data = nullptr;
     size = 0;
 
@@ -59,11 +59,11 @@
     return true;
   }
 
-  inline bool send(const string &data) {
+  inline bool send(const string& data) {
     return send((const uint8_t*)(const char*)data, data.length());
   }
 
-  inline bool send(const uint8_t *data, unsigned size) {
+  inline bool send(const uint8_t* data, unsigned size) {
     while(size) {
       int length = ::send(serversocket, (const char*)data, size, 0);
       if(length == -1) return false;
@@ -97,7 +97,7 @@
     return output;
   }
 
-  inline void downloadContent(uint8_t *&data, unsigned &size) {
+  inline void downloadContent(uint8_t*& data, unsigned& size) {
     unsigned capacity = 0;
 
     if(header.iposition("\r\nTransfer-Encoding: chunked\r\n")) {
diff -ru higan_v092r07\nall\image.hpp higan_v092r08\nall\image.hpp
--- higan_v092r07\nall\image.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\image.hpp	Thu May 02 05:48:01 2013
@@ -11,67 +11,72 @@
 namespace nall {
 
 struct image {
-  uint8_t *data;
-  unsigned width;
-  unsigned height;
-  unsigned pitch;
-
-  bool endian;  //0 = little, 1 = big
-  unsigned depth;
-  unsigned stride;
+  uint8_t* data = nullptr;
+  unsigned width = 0;
+  unsigned height = 0;
+  unsigned pitch = 0;
+
+  bool endian = 0;
+  unsigned depth = 32;
+  unsigned stride = 4;
 
   struct Channel {
     uint64_t mask;
     unsigned depth;
     unsigned shift;
 
-    inline bool operator==(const Channel &source) {
+    inline bool operator==(const Channel& source) {
       return mask == source.mask && depth == source.depth && shift == source.shift;
     }
 
-    inline bool operator!=(const Channel &source) {
+    inline bool operator!=(const Channel& source) {
       return !operator==(source);
     }
-  } alpha, red, green, blue;
+  };
+
+  Channel alpha = {255u << 24, 8u, 24};
+  Channel red   = {255u << 16, 8u, 16};
+  Channel green = {255u <<  8, 8u,  8};
+  Channel blue  = {255u <<  0, 8u,  0};
 
   typedef double (*interpolation)(double, double, double, double, double);
   static inline unsigned bitDepth(uint64_t color);
   static inline unsigned bitShift(uint64_t color);
   static inline uint64_t normalize(uint64_t color, unsigned sourceDepth, unsigned targetDepth);
 
-  inline bool operator==(const image &source);
-  inline bool operator!=(const image &source);
+  inline bool operator==(const image& source);
+  inline bool operator!=(const image& source);
 
-  inline image& operator=(const image &source);
-  inline image& operator=(image &&source);
-  inline image(const image &source);
-  inline image(image &&source);
+  inline image& operator=(const image& source);
+  inline image& operator=(image&& source);
+  inline image(const image& source);
+  inline image(image&& source);
   inline image(bool endian, unsigned depth, uint64_t alphaMask, uint64_t redMask, uint64_t greenMask, uint64_t blueMask);
-  inline image(const string &filename);
-  inline image(const uint8_t *data, unsigned size);
+  inline image(const string& filename);
+  inline image(const uint8_t* data, unsigned size);
   inline image();
   inline ~image();
 
-  inline uint64_t read(const uint8_t *data) const;
-  inline void write(uint8_t *data, uint64_t value) const;
+  inline uint64_t read(const uint8_t* data) const;
+  inline void write(uint8_t* data, uint64_t value) const;
 
   inline void free();
   inline bool empty() const;
   inline void allocate(unsigned width, unsigned height);
   inline void clear(uint64_t color);
-  inline bool load(const string &filename);
-//inline bool loadBMP(const uint8_t *data, unsigned size);
-  inline bool loadPNG(const uint8_t *data, unsigned size);
+  inline bool load(const string& filename);
+//inline bool loadBMP(const uint8_t* data, unsigned size);
+  inline bool loadPNG(const uint8_t* data, unsigned size);
   inline void scale(unsigned width, unsigned height, interpolation op);
   inline void transform(bool endian, unsigned depth, uint64_t alphaMask, uint64_t redMask, uint64_t greenMask, uint64_t blueMask);
   inline void alphaBlend(uint64_t alphaColor);
 
 protected:
-  inline uint64_t interpolate(double mu, const uint64_t *s, interpolation op);
+  inline uint64_t interpolate(double mu, const uint64_t* s, interpolation op);
   inline void scaleX(unsigned width, interpolation op);
   inline void scaleY(unsigned height, interpolation op);
-  inline bool loadBMP(const string &filename);
-  inline bool loadPNG(const string &filename);
+  inline bool loadBMP(const string& filename);
+  inline bool loadPNG(const string& filename);
 };
 
 //static
@@ -100,7 +105,7 @@
 
 //public
 
-bool image::operator==(const image &source) {
+bool image::operator==(const image& source) {
   if(width != source.width) return false;
   if(height != source.height) return false;
   if(pitch != source.pitch) return false;
@@ -116,11 +121,11 @@
   return memcmp(data, source.data, width * height * stride) == 0;
 }
 
-bool image::operator!=(const image &source) {
+bool image::operator!=(const image& source) {
   return !operator==(source);
 }
 
-image& image::operator=(const image &source) {
+image& image::operator=(const image& source) {
   free();
 
   width = source.width;
@@ -140,7 +145,7 @@
   return *this;
 }
 
-image& image::operator=(image &&source) {
+image& image::operator=(image&& source) {
   free();
 
   width = source.width;
@@ -160,79 +165,41 @@
   return *this;
 }
 
-image::image(const image &source) : data(nullptr) {
+image::image(const image& source) {
   operator=(source);
 }
 
-image::image(image &&source) : data(nullptr) {
+image::image(image&& source) {
   operator=(std::forward<image>(source));
 }
 
-image::image(bool endian, unsigned depth, uint64_t alphaMask, uint64_t redMask, uint64_t greenMask, uint64_t blueMask) : data(nullptr) {
-  width = 0, height = 0, pitch = 0;
-
+image::image(bool endian, unsigned depth, uint64_t alphaMask, uint64_t redMask, uint64_t greenMask, uint64_t blueMask) {
   this->endian = endian;
   this->depth = depth;
   this->stride = (depth / 8) + ((depth & 7) > 0);
 
-  alpha.mask = alphaMask, red.mask = redMask, green.mask = greenMask, blue.mask = blueMask;
-  alpha.depth = bitDepth(alpha.mask), alpha.shift = bitShift(alpha.mask);
-  red.depth = bitDepth(red.mask), red.shift = bitShift(red.mask);
-  green.depth = bitDepth(green.mask), green.shift = bitShift(green.mask);
-  blue.depth = bitDepth(blue.mask), blue.shift = bitShift(blue.mask);
-}
-
-image::image(const string &filename) : data(nullptr) {
-  width = 0, height = 0, pitch = 0;
-
-  this->endian = 0;
-  this->depth = 32;
-  this->stride = 4;
-
-  alpha.mask = 255u << 24, red.mask = 255u << 16, green.mask = 255u << 8, blue.mask = 255u << 0;
-  alpha.depth = bitDepth(alpha.mask), alpha.shift = bitShift(alpha.mask);
-  red.depth = bitDepth(red.mask), red.shift = bitShift(red.mask);
-  green.depth = bitDepth(green.mask), green.shift = bitShift(green.mask);
-  blue.depth = bitDepth(blue.mask), blue.shift = bitShift(blue.mask);
+  alpha = {alphaMask, bitDepth(alphaMask), bitShift(alphaMask)};
+  red = {redMask, bitDepth(redMask), bitShift(redMask)};
+  green = {greenMask, bitDepth(greenMask), bitShift(greenMask)};
+  blue = {blueMask, bitDepth(blueMask), bitShift(blueMask)};
+}
 
+image::image(const string& filename) {
   load(filename);
 }
 
-image::image(const uint8_t *data, unsigned size) : data(nullptr) {
-  width = 0, height = 0, pitch = 0;
-
-  this->endian = 0;
-  this->depth = 32;
-  this->stride = 4;
-
-  alpha.mask = 255u << 24, red.mask = 255u << 16, green.mask = 255u << 8, blue.mask = 255u << 0;
-  alpha.depth = bitDepth(alpha.mask), alpha.shift = bitShift(alpha.mask);
-  red.depth = bitDepth(red.mask), red.shift = bitShift(red.mask);
-  green.depth = bitDepth(green.mask), green.shift = bitShift(green.mask);
-  blue.depth = bitDepth(blue.mask), blue.shift = bitShift(blue.mask);
-
+image::image(const uint8_t* data, unsigned size) {
   loadPNG(data, size);
 }
 
-image::image() : data(nullptr) {
-  width = 0, height = 0, pitch = 0;
-
-  this->endian = 0;
-  this->depth = 32;
-  this->stride = 4;
-
-  alpha.mask = 255u << 24, red.mask = 255u << 16, green.mask = 255u << 8, blue.mask = 255u << 0;
-  alpha.depth = bitDepth(alpha.mask), alpha.shift = bitShift(alpha.mask);
-  red.depth = bitDepth(red.mask), red.shift = bitShift(red.mask);
-  green.depth = bitDepth(green.mask), green.shift = bitShift(green.mask);
-  blue.depth = bitDepth(blue.mask), blue.shift = bitShift(blue.mask);
+image::image() {
 }
 
 image::~image() {
   free();
 }
 
-uint64_t image::read(const uint8_t *data) const {
+uint64_t image::read(const uint8_t* data) const {
   uint64_t result = 0;
   if(endian == 0) {
     for(signed n = stride - 1; n >= 0; n--) result = (result << 8) | data[n];
@@ -242,7 +209,7 @@
   return result;
 }
 
-void image::write(uint8_t *data, uint64_t value) const {
+void image::write(uint8_t* data, uint64_t value) const {
   if(endian == 0) {
     for(signed n = 0; n < stride; n++) { data[n] = value; value >>= 8; }
   } else {
@@ -278,7 +245,7 @@
   }
 }
 
-bool image::load(const string &filename) {
+bool image::load(const string& filename) {
   if(loadBMP(filename) == true) return true;
   if(loadPNG(filename) == true) return true;
   return false;
@@ -295,8 +262,8 @@
 
   #pragma omp parallel for
   for(unsigned y = 0; y < height; y++) {
-    uint8_t *dp = output.data + output.pitch * y;
-    uint8_t *sp = data + pitch * y;
+    uint8_t* dp = output.data + output.pitch * y;
+    uint8_t* sp = data + pitch * y;
     for(unsigned x = 0; x < width; x++) {
       uint64_t color = read(sp);
       sp += stride;
@@ -326,7 +293,7 @@
 
   #pragma omp parallel for
   for(unsigned y = 0; y < height; y++) {
-    uint8_t *dp = data + pitch * y;
+    uint8_t* dp = data + pitch * y;
     for(unsigned x = 0; x < width; x++) {
       uint64_t color = read(dp);
 
@@ -349,7 +316,7 @@
 
 //protected
 
-uint64_t image::interpolate(double mu, const uint64_t *s, double (*op)(double, double, double, double, double)) {
+uint64_t image::interpolate(double mu, const uint64_t* s, double (*op)(double, double, double, double, double)) {
   uint64_t aa = (s[0] & alpha.mask) >> alpha.shift, ar = (s[0] & red.mask) >> red.shift,
            ag = (s[0] & green.mask) >> green.shift, ab = (s[0] & blue.mask) >> blue.shift;
   uint64_t ba = (s[1] & alpha.mask) >> alpha.shift, br = (s[1] & red.mask) >> red.shift,
@@ -373,18 +340,18 @@
 }
 
 void image::scaleX(unsigned outputWidth, interpolation op) {
-  uint8_t *outputData = new uint8_t[outputWidth * height * stride];
+  uint8_t* outputData = new uint8_t[outputWidth * height * stride];
   unsigned outputPitch = outputWidth * stride;
   double step = (double)width / (double)outputWidth;
-  const uint8_t *terminal = data + pitch * height;
+  const uint8_t* terminal = data + pitch * height;
 
   #pragma omp parallel for
   for(unsigned y = 0; y < height; y++) {
-    uint8_t *dp = outputData + outputPitch * y;
-    uint8_t *sp = data + pitch * y;
+    uint8_t* dp = outputData + outputPitch * y;
+    uint8_t* sp = data + pitch * y;
 
     double fraction = 0.0;
-    uint64_t s[4] = { sp < terminal ? read(sp) : 0 };  //B,C (0,1) = center of kernel { 0, 0, 1, 2 }
+    uint64_t s[4] = {sp < terminal ? read(sp) : 0};  //B,C (0,1) = center of kernel { 0, 0, 1, 2 }
     s[1] = s[0];
     s[2] = sp + stride < terminal ? read(sp += stride) : s[1];
     s[3] = sp + stride < terminal ? read(sp += stride) : s[2];
@@ -410,17 +377,17 @@
 }
 
 void image::scaleY(unsigned outputHeight, interpolation op) {
-  uint8_t *outputData = new uint8_t[width * outputHeight * stride];
+  uint8_t* outputData = new uint8_t[width * outputHeight * stride];
   double step = (double)height / (double)outputHeight;
-  const uint8_t *terminal = data + pitch * height;
+  const uint8_t* terminal = data + pitch * height;
 
   #pragma omp parallel for
   for(unsigned x = 0; x < width; x++) {
-    uint8_t *dp = outputData + stride * x;
-    uint8_t *sp = data + stride * x;
+    uint8_t* dp = outputData + stride * x;
+    uint8_t* sp = data + stride * x;
 
     double fraction = 0.0;
-    uint64_t s[4] = { sp < terminal ? read(sp) : 0 };
+    uint64_t s[4] = {sp < terminal ? read(sp) : 0};
     s[1] = s[0];
     s[2] = sp + pitch < terminal ? read(sp += pitch) : s[1];
     s[3] = sp + pitch < terminal ? read(sp += pitch) : s[2];
@@ -444,14 +411,14 @@
   height = outputHeight;
 }
 
-bool image::loadBMP(const string &filename) {
-  uint32_t *outputData;
+bool image::loadBMP(const string& filename) {
+  uint32_t* outputData;
   unsigned outputWidth, outputHeight;
   if(bmp::read(filename, outputData, outputWidth, outputHeight) == false) return false;
 
   allocate(outputWidth, outputHeight);
-  const uint32_t *sp = outputData;
-  uint8_t *dp = data;
+  const uint32_t* sp = outputData;
+  uint8_t* dp = data;
 
   for(unsigned y = 0; y < outputHeight; y++) {
     for(unsigned x = 0; x < outputWidth; x++) {
@@ -469,13 +436,13 @@
   return true;
 }
 
-bool image::loadPNG(const uint8_t *pngData, unsigned pngSize) {
+bool image::loadPNG(const uint8_t* pngData, unsigned pngSize) {
   png source;
   if(source.decode(pngData, pngSize) == false) return false;
 
   allocate(source.info.width, source.info.height);
-  const uint8_t *sp = source.data;
-  uint8_t *dp = data;
+  const uint8_t* sp = source.data;
+  uint8_t* dp = data;
 
   auto decode = [&]() -> uint64_t {
     uint64_t p, r, g, b, a;
@@ -528,7 +495,7 @@
   return true;
 }
 
-bool image::loadPNG(const string &filename) {
+bool image::loadPNG(const string& filename) {
   filemap map;
   if(map.open(filename, filemap::mode::read) == false) return false;
   return loadPNG(map.data(), map.size());
diff -ru higan_v092r07\nall\inflate.hpp higan_v092r08\nall\inflate.hpp
--- higan_v092r07\nall\inflate.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\inflate.hpp	Thu May 02 05:48:01 2013
@@ -7,14 +7,14 @@
 
 namespace puff {
   inline int puff(
-    unsigned char *dest, unsigned long *destlen,
-    unsigned char *source, unsigned long *sourcelen
+    unsigned char* dest, unsigned long* destlen,
+    unsigned char* source, unsigned long* sourcelen
   );
 }
 
 inline bool inflate(
-  uint8_t *target, unsigned targetLength,
-  const uint8_t *source, unsigned sourceLength
+  uint8_t* target, unsigned targetLength,
+  const uint8_t* source, unsigned sourceLength
 ) {
   unsigned long tl = targetLength, sl = sourceLength;
   int result = puff::puff((unsigned char*)target, &tl, (unsigned char*)source, &sl);
@@ -23,15 +23,6 @@
 
 namespace puff {
 
-//zlib/contrib/puff.c
-//version 2.1*
-//author: Mark Adler
-//license: zlib
-//ported by: byuu
-
-//* I have corrected a bug in fixed(), where it was accessing uninitialized
-//  memory: calling construct() with lencode prior to initializing lencode.count
-
 enum {
   MAXBITS   =  15,
   MAXLCODES = 286,
@@ -41,11 +32,11 @@
 };
 
 struct state {
-  unsigned char *out;
+  unsigned char* out;
   unsigned long outlen;
   unsigned long outcnt;
 
-  unsigned char *in;
+  unsigned char* in;
   unsigned long inlen;
   unsigned long incnt;
   int bitbuf;
@@ -55,11 +46,11 @@
 };
 
 struct huffman {
-  short *count;
-  short *symbol;
+  short* count;
+  short* symbol;
 };
 
-inline int bits(state *s, int need) {
+inline int bits(state* s, int need) {
   long val;
 
   val = s->bitbuf;
@@ -75,7 +66,7 @@
   return (int)(val & ((1L << need) - 1));
 }
 
-inline int stored(state *s) {
+inline int stored(state* s) {
   unsigned len;
 
   s->bitbuf = 0;
@@ -100,9 +91,9 @@
   return 0;
 }
 
-inline int decode(state *s, huffman *h) {
+inline int decode(state* s, huffman* h) {
   int len, code, first, count, index, bitbuf, left;
-  short *next;
+  short* next;
 
   bitbuf = s->bitbuf;
   left = s->bitcnt;
@@ -135,7 +126,7 @@
   return -10;
 }
 
-inline int construct(huffman *h, short *length, int n) {
+inline int construct(huffman* h, short* length, int n) {
   int symbol, len, left;
   short offs[MAXBITS + 1];
 
@@ -160,7 +151,7 @@
   return left;
 }
 
-inline int codes(state *s, huffman *lencode, huffman *distcode) {
+inline int codes(state* s, huffman* lencode, huffman* distcode) {
   int symbol, len;
   unsigned dist;
   static const short lens[29] = {
@@ -222,7 +213,7 @@
   return 0;
 }
 
-inline int fixed(state *s) {
+inline int fixed(state* s) {
   static int virgin = 1;
   static short lencnt[MAXBITS + 1], lensym[FIXLCODES];
   static short distcnt[MAXBITS + 1], distsym[MAXDCODES];
@@ -252,7 +243,7 @@
   return codes(s, &lencode, &distcode);
 }
 
-inline int dynamic(state *s) {
+inline int dynamic(state* s) {
   int nlen, ndist, ncode, index, err;
   short lengths[MAXCODES];
   short lencnt[MAXBITS + 1], lensym[MAXLCODES];
@@ -313,8 +304,8 @@
 }
 
 inline int puff(
-  unsigned char *dest, unsigned long *destlen,
-  unsigned char *source, unsigned long *sourcelen
+  unsigned char* dest, unsigned long* destlen,
+  unsigned char* source, unsigned long* sourcelen
 ) {
   state s;
   int last, type, err;
diff -ru higan_v092r07\nall\input.hpp higan_v092r08\nall\input.hpp
--- higan_v092r07\nall\input.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\input.hpp	Thu May 02 05:48:01 2013
@@ -88,7 +88,7 @@
     return false;
   }
 
-  static uint16_t decode(const char *name) {
+  static uint16_t decode(const char* name) {
     string s(name);
     if(!strbegin(name, "KB")) return 0;
     s.ltrim("KB");
@@ -110,7 +110,7 @@
         break;
       }
     }
-    return { "KB", ID, "::", KeyboardScancodeName[index] };
+    return {"KB", ID, "::", KeyboardScancodeName[index]};
   }
 
   uint16_t operator[](Scancode code) const { return Base + ID * Size + code; }
@@ -185,7 +185,7 @@
     return false;
   }
 
-  static uint16_t decode(const char *name) {
+  static uint16_t decode(const char* name) {
     string s(name);
     if(!strbegin(name, "MS")) return 0;
     s.ltrim("MS");
@@ -207,7 +207,7 @@
         break;
       }
     }
-    return { "MS", ID, "::", MouseScancodeName[index] };
+    return {"MS", ID, "::", MouseScancodeName[index]};
   }
 
   uint16_t operator[](Scancode code) const { return Base + ID * Size + code; }
@@ -309,7 +309,7 @@
     return false;
   }
 
-  static uint16_t decode(const char *name) {
+  static uint16_t decode(const char* name) {
     string s(name);
     if(!strbegin(name, "JP")) return 0;
     s.ltrim("JP");
@@ -330,7 +330,7 @@
         index = code - (Base + Size * i);
       }
     }
-    return { "JP", ID, "::", JoypadScancodeName[index] };
+    return {"JP", ID, "::", JoypadScancodeName[index]};
   }
 
   uint16_t operator[](Scancode code) const { return Base + ID * Size + code; }
@@ -356,7 +356,7 @@
 struct Scancode {
   enum { None = 0, Limit = Joypad::Base + Joypad::Size * Joypad::Count };
 
-  static uint16_t decode(const char *name) {
+  static uint16_t decode(const char* name) {
     uint16_t code;
     code = Keyboard::decode(name);
     if(code) return code;
diff -ru higan_v092r07\nall\intrinsics.hpp higan_v092r08\nall\intrinsics.hpp
--- higan_v092r07\nall\intrinsics.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\intrinsics.hpp	Thu May 02 05:48:01 2013
@@ -1,6 +1,8 @@
 #ifndef NALL_INTRINSICS_HPP
 #define NALL_INTRINSICS_HPP
 
+namespace nall {
+
 struct Intrinsics {
   enum class Compiler : unsigned { Clang, GCC, VisualC, Unknown };
   enum class Platform : unsigned { X, OSX, Windows, Unknown };
@@ -62,5 +64,7 @@
   #define ARCH_UNKNOWN
   Intrinsics::Endian Intrinsics::endian() { return Intrinsics::Endian::Unknown; }
 #endif
+
+}
 
 #endif
diff -ru higan_v092r07\nall\invoke.hpp higan_v092r08\nall\invoke.hpp
--- higan_v092r07\nall\invoke.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\invoke.hpp	Thu May 02 05:48:01 2013
@@ -20,21 +20,20 @@
 
 #if defined(PLATFORM_WINDOWS)
 
-template<typename... Args>
-inline void invoke(const string &name, Args&&... args) {
+template<typename... Args> inline void invoke(const string& name, Args&&... args) {
   lstring argl(std::forward<Args>(args)...);
-  for(auto &arg : argl) if(arg.position(" ")) arg = {"\"", arg, "\""};
+  for(auto& arg : argl) if(arg.position(" ")) arg = {"\"", arg, "\""};
   string arguments = argl.concatenate(" ");
   ShellExecuteW(NULL, NULL, utf16_t(name), utf16_t(arguments), NULL, SW_SHOWNORMAL);
 }
 
 #elif defined(PLATFORM_X)
 
-template<typename... Args>
-inline void invoke(const string &name, Args&&... args) {
+template<typename... Args> inline void invoke(const string& name, Args&&... args) {
   pid_t pid = fork();
   if(pid == 0) {
-    const char *argv[1 + sizeof...(args) + 1], **argp = argv;
+    const char* argv[1 + sizeof...(args) + 1];
+    const char** argp = argv;
     lstring argl(std::forward<Args>(args)...);
     *argp++ = (const char*)name;
     for(auto &arg : argl) *argp++ = (const char*)arg;
@@ -49,8 +48,7 @@
 
 #else
 
-template<typename... Args>
-inline void invoke(const string &name, Args&&... args) {
+template<typename... Args> inline void invoke(const string& name, Args&&... args) {
 }
 
 #endif
diff -ru higan_v092r07\nall\ips.hpp higan_v092r08\nall\ips.hpp
--- higan_v092r07\nall\ips.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\ips.hpp	Thu May 02 05:48:01 2013
@@ -9,17 +9,17 @@
 
 struct ips {
   inline bool apply();
-  inline void source(const uint8_t *data, unsigned size);
-  inline void modify(const uint8_t *data, unsigned size);
+  inline void source(const uint8_t* data, unsigned size);
+  inline void modify(const uint8_t* data, unsigned size);
   inline ips();
   inline ~ips();
 
-  uint8_t *data;
-  unsigned size;
-  const uint8_t *sourceData;
-  unsigned sourceSize;
-  const uint8_t *modifyData;
-  unsigned modifySize;
+  uint8_t* data = nullptr;
+  unsigned size = 0;
+  const uint8_t* sourceData = nullptr;
+  unsigned sourceSize = 0;
+  const uint8_t* modifyData = nullptr;
+  unsigned modifySize = 0;
 };
 
 bool ips::apply() {
@@ -78,15 +78,15 @@
   return false;
 }
 
-void ips::source(const uint8_t *data, unsigned size) {
+void ips::source(const uint8_t* data, unsigned size) {
   sourceData = data, sourceSize = size;
 }
 
-void ips::modify(const uint8_t *data, unsigned size) {
+void ips::modify(const uint8_t* data, unsigned size) {
   modifyData = data, modifySize = size;
 }
 
-ips::ips() : data(nullptr), sourceData(nullptr), modifyData(nullptr) {
+ips::ips() {
 }
 
 ips::~ips() {
diff -ru higan_v092r07\nall\map.hpp higan_v092r08\nall\map.hpp
--- higan_v092r07\nall\map.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\map.hpp	Thu May 02 05:48:01 2013
@@ -1,115 +1,57 @@
 #ifndef NALL_MAP_HPP
 #define NALL_MAP_HPP
 
-#include <nall/vector.hpp>
+#include <nall/set.hpp>
 
 namespace nall {
 
-template<typename LHS, typename RHS>
-struct map {
-  struct pair {
-    LHS name;
-    RHS data;
+template<typename T, typename U> struct map {
+  struct node_t {
+    T key;
+    U value;
+    bool operator< (const node_t& source) const { return key <  source.key; }
+    bool operator==(const node_t& source) const { return key == source.key; }
+    node_t() = default;
+    node_t(const T& key) : key(key) {}
+    node_t(const T& key, const U& value) : key(key), value(value) {}
   };
 
-  inline void reset() {
-    list.reset();
+  optional<U> find(const T& key) const {
+    if(auto node = root.find({key})) return {true, node().value};
+    return false;
   }
 
-  inline unsigned size() const {
-    return list.size();
-  }
-
-  //O(log n) find
-  inline optional<unsigned> find(const LHS &name) const {
-    signed first = 0, last = size() - 1;
-    while(first <= last) {
-      signed middle = (first + last) / 2;
-           if(name < list[middle].name) last  = middle - 1;  //search lower half
-      else if(list[middle].name < name) first = middle + 1;  //search upper half
-      else return { true, (unsigned)middle };                //match found
-    }
-    return { false, 0u };
-  }
-
-  //O(n) insert + O(log n) find
-  inline RHS& insert(const LHS &name, const RHS &data) {
-    if(auto position = find(name)) {
-      list[position()].data = data;
-      return list[position()].data;
-    }
-    signed offset = size();
-    for(unsigned n = 0; n < size(); n++) {
-      if(name < list[n].name) { offset = n; break; }
-    }
-    list.insert(offset, { name, data });
-    return list[offset].data;
-  }
-
-  //O(log n) find
-  inline void modify(const LHS &name, const RHS &data) {
-    if(auto position = find(name)) list[position()].data = data;
-  }
-
-  //O(n) remove + O(log n) find
-  inline void remove(const LHS &name) {
-    if(auto position = find(name)) list.remove(position());
-  }
-
-  //O(log n) find
-  inline RHS& operator[](const LHS &name) {
-    if(auto position = find(name)) return list[position()].data;
-    throw;
-  }
-
-  inline const RHS& operator[](const LHS &name) const {
-    if(auto position = find(name)) return list[position()].data;
-    throw;
-  }
-
-  inline RHS& operator()(const LHS &name) {
-    if(auto position = find(name)) return list[position()].data;
-    return insert(name, RHS());
-  }
-
-  inline const RHS& operator()(const LHS &name, const RHS &data) const {
-    if(auto position = find(name)) return list[position()].data;
-    return data;
-  }
-
-  inline pair* begin() { return list.begin(); }
-  inline pair* end() { return list.end(); }
-  inline const pair* begin() const { return list.begin(); }
-  inline const pair* end() const { return list.end(); }
+  void insert(const T& key, const U& value) { root.insert({key, value}); }
+  void remove(const T& key) { root.remove({key}); }
+  unsigned size() const { return root.size(); }
+  void reset() { root.reset(); }
+
+  typename set<node_t>::iterator begin() { return root.begin(); }
+  typename set<node_t>::iterator end() { return root.end(); }
+  const typename set<node_t>::iterator begin() const { return root.begin(); }
+  const typename set<node_t>::iterator end() const { return root.end(); }
 
 protected:
-  vector<pair> list;
+  set<node_t> root;
 };
 
-template<typename LHS, typename RHS>
-struct bidirectional_map {
-  const map<LHS, RHS> &lhs;
-  const map<RHS, LHS> &rhs;
-
-  inline void reset() {
-    llist.reset();
-    rlist.reset();
-  }
-
-  inline unsigned size() const {
-    return llist.size();
-  }
-
-  inline void insert(const LHS &ldata, const RHS &rdata) {
-    llist.insert(ldata, rdata);
-    rlist.insert(rdata, ldata);
-  }
-
-  inline bidirectional_map() : lhs(llist), rhs(rlist) {}
+template<typename T, typename U> struct bimap {
+  optional<U> find(const T& key) const { return tmap.find(key); }
+  optional<T> find(const U& key) const { return umap.find(key); }
+  void insert(const T& key, const U& value) { tmap.insert(key, value); umap.insert(value, key); }
+  void remove(const T& key) { if(auto p = tmap.find(key)) { umap.remove(p().value); tmap.remove(key); } }
+  void remove(const U& key) { if(auto p = umap.find(key)) { tmap.remove(p().value); umap.remove(key); } }
+  unsigned size() const { return tmap.size(); }
+  void reset() { tmap.reset(); umap.reset(); }
+
+  typename set<typename map<T, U>::node_t>::iterator begin() { return tmap.begin(); }
+  typename set<typename map<T, U>::node_t>::iterator end() { return tmap.end(); }
+  const typename set<typename map<T, U>::node_t>::iterator begin() const { return tmap.begin(); }
+  const typename set<typename map<T, U>::node_t>::iterator end() const { return tmap.end(); }
 
 protected:
-  map<LHS, RHS> llist;
-  map<RHS, LHS> rlist;
+  map<T, U> tmap;
+  map<U, T> umap;
 };
 
 }
diff -ru higan_v092r07\nall\matrix.hpp higan_v092r08\nall\matrix.hpp
--- higan_v092r07\nall\matrix.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\matrix.hpp	Thu May 02 05:48:01 2013
@@ -5,8 +5,7 @@
 
 namespace Matrix {
 
-template<typename T>
-inline void Multiply(T *output, const T *xdata, unsigned xrows, unsigned xcols, const T *ydata, unsigned yrows, unsigned ycols) {
+template<typename T> inline void Multiply(T* output, const T* xdata, unsigned xrows, unsigned xcols, const T* ydata, unsigned yrows, unsigned ycols) {
   if(xcols != yrows) return;
 
   for(unsigned y = 0; y < xrows; y++) {
@@ -20,8 +19,7 @@
   }
 }
 
-template<typename T>
-inline vector<T> Multiply(const T *xdata, unsigned xrows, unsigned xcols, const T *ydata, unsigned yrows, unsigned ycols) {
+template<typename T> inline vector<T> Multiply(const T* xdata, unsigned xrows, unsigned xcols, const T* ydata, unsigned yrows, unsigned ycols) {
   vector<T> output;
   output.resize(xrows * ycols);
   Multiply(output.data(), xdata, xrows, xcols, ydata, yrows, ycols);
diff -ru higan_v092r07\nall\mosaic\bitstream.hpp higan_v092r08\nall\mosaic\bitstream.hpp
--- higan_v092r07\nall\mosaic\bitstream.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\mosaic\bitstream.hpp	Thu May 02 05:48:00 2013
@@ -5,25 +5,25 @@
 
 struct bitstream {
   filemap fp;
-  uint8_t *data;
-  unsigned size;
-  bool readonly;
-  bool endian;
+  uint8_t* data = nullptr;
+  unsigned size = 0;
+  bool readonly = false;
+  bool endian = 1;
 
-  inline bool read(uint64_t addr) const {
+  bool read(uint64_t addr) const {
     if(data == nullptr || (addr >> 3) >= size) return 0;
     unsigned mask = endian == 0 ? (0x01 << (addr & 7)) : (0x80 >> (addr & 7));
     return data[addr >> 3] & mask;
   }
 
-  inline void write(uint64_t addr, bool value) {
+  void write(uint64_t addr, bool value) {
     if(data == nullptr || readonly == true || (addr >> 3) >= size) return;
     unsigned mask = endian == 0 ? (0x01 << (addr & 7)) : (0x80 >> (addr & 7));
     if(value == 0) data[addr >> 3] &= ~mask;
     if(value == 1) data[addr >> 3] |=  mask;
   }
 
-  inline bool open(const string &filename) {
+  bool open(const string& filename) {
     readonly = false;
     if(fp.open(filename, filemap::mode::readwrite) == false) {
       readonly = true;
@@ -36,15 +36,15 @@
     return true;
   }
 
-  inline void close() {
+  void close() {
     fp.close();
     data = nullptr;
   }
 
-  inline bitstream() : data(nullptr), endian(1) {
+  bitstream() {
   }
 
-  inline ~bitstream() {
+  ~bitstream() {
     close();
   }
 };
diff -ru higan_v092r07\nall\mosaic\context.hpp higan_v092r08\nall\mosaic\context.hpp
--- higan_v092r07\nall\mosaic\context.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\mosaic\context.hpp	Thu May 02 05:48:01 2013
@@ -36,9 +36,9 @@
   unsigned paddingColor;
   vector<unsigned> palette;
 
-  inline unsigned objectWidth() const { return blockWidth * tileWidth * mosaicWidth + paddingWidth; }
-  inline unsigned objectHeight() const { return blockHeight * tileHeight * mosaicHeight + paddingHeight; }
-  inline unsigned objectSize() const {
+  unsigned objectWidth() const { return blockWidth * tileWidth * mosaicWidth + paddingWidth; }
+  unsigned objectHeight() const { return blockHeight * tileHeight * mosaicHeight + paddingHeight; }
+  unsigned objectSize() const {
     unsigned size = blockStride * tileWidth * tileHeight * mosaicWidth * mosaicHeight
                   + blockOffset * tileHeight * mosaicWidth * mosaicHeight
                   + tileStride * mosaicWidth * mosaicHeight
@@ -46,23 +46,23 @@
     return max(1u, size);
   }
 
-  inline unsigned eval(const string &expression) {
+  unsigned eval(const string& expression) {
     intmax_t result;
     if(fixedpoint::eval(expression, result) == false) return 0u;
     return result;
   }
 
-  inline void eval(vector<unsigned> &buffer, const string &expression_) {
+  void eval(vector<unsigned>& buffer, const string& expression_) {
     string expression = expression_;
     bool function = false;
-    for(auto &c : expression) {
+    for(auto& c : expression) {
       if(c == '(') function = true;
       if(c == ')') function = false;
       if(c == ',' && function == true) c = ';';
     }
 
     lstring list = expression.split(",");
-    for(auto &item : list) {
+    for(auto& item : list) {
       item.trim();
       if(item.wildcard("f(?*) ?*")) {
         item.ltrim<1>("f(");
@@ -95,7 +95,7 @@
           item = part(1, "");
         }
         item.trim();
-        for(auto &c : item) {
+        for(auto& c : item) {
           if(c >= 'A' && c <= 'Z') buffer.append(offset + c - 'A' +  0);
           if(c >= 'a' && c <= 'z') buffer.append(offset + c - 'a' + 26);
           if(c >= '0' && c <= '9') buffer.append(offset + c - '0' + 52);
@@ -112,11 +112,11 @@
     }
   }
 
-  inline void parse(const string &data) {
+  void parse(const string& data) {
     reset();
 
     lstring lines = data.split("\n");
-    for(auto &line : lines) {
+    for(auto& line : lines) {
       lstring part = line.split<1>(":");
       if(part.size() != 2) continue;
       part[0].trim();
@@ -158,14 +158,14 @@
     sanitize();
   }
 
-  inline bool load(const string &filename) {
+  bool load(const string& filename) {
     string filedata;
     if(filedata.readfile(filename) == false) return false;
     parse(filedata);
     return true;
   }
 
-  inline void sanitize() {
+  void sanitize() {
     if(depth < 1) depth = 1;
     if(depth > 24) depth = 24;
 
@@ -179,7 +179,7 @@
     if(mosaicHeight < 1) mosaicHeight = 1;
   }
 
-  inline void reset() {
+  void reset() {
     offset = 0;
     width = 0;
     height = 0;
@@ -213,7 +213,7 @@
     palette.reset();
   }
 
-  inline context() {
+  context() {
     reset();
   }
 };
diff -ru higan_v092r07\nall\mosaic\parser.hpp higan_v092r08\nall\mosaic\parser.hpp
--- higan_v092r07\nall\mosaic\parser.hpp	Fri Apr 12 16:38:13 2013
+++ higan_v092r08\nall\mosaic\parser.hpp	Thu May 02 05:48:01 2013
@@ -7,14 +7,14 @@
   image canvas;
 
   //export from bitstream to canvas
-  inline void load(bitstream &stream, uint64_t offset, context &ctx, unsigned width, unsigned height) {
+  void load(bitstream& stream, uint64_t offset, context& ctx, unsigned width, unsigned height) {
     canvas.allocate(width, height);
     canvas.clear(ctx.paddingColor);
     parse(1, stream, offset, ctx, width, height);
   }
 
   //import from canvas to bitstream
-  inline bool save(bitstream &stream, uint64_t offset, context &ctx) {
+  bool save(bitstream& stream, uint64_t offset, context& ctx) {
     if(stream.readonly) return false;
     parse(0, stream, offset, ctx, canvas.width, canvas.height);
     return true;
@@ -24,21 +24,21 @@
   }
 
 private:
-  inline uint32_t read(unsigned x, unsigned y) const {
+  uint32_t read(unsigned x, unsigned y) const {
     unsigned addr = y * canvas.width + x;
     if(addr >= canvas.width * canvas.height) return 0u;
     uint32_t *buffer = (uint32_t*)canvas.data;
     return buffer[addr];
   }
 
-  inline void write(unsigned x, unsigned y, uint32_t data) {
+  void write(unsigned x, unsigned y, uint32_t data) {
     unsigned addr = y * canvas.width + x;
     if(addr >= canvas.width * canvas.height) return;
     uint32_t *buffer = (uint32_t*)canvas.data;
     buffer[addr] = data;
   }
 
-  inline void parse(bool load, bitstream &stream, uint64_t offset, context &ctx, unsigned width, unsigned height) {
+  void parse(bool load, bitstream& stream, uint64_t offset, context& ctx, unsigned width, unsigned height) {
     stream.endian = ctx.endian;
     unsigned canvasWidth = width / (ctx.mosaicWidth * ctx.tileWidth * ctx.blockWidth + ctx.paddingWidth);
     unsigned canvasHeight = height / (ctx.mosaicHeight * ctx.tileHeight * ctx.blockHeight + ctx.paddingHeight);
diff -ru higan_v092r07\nall\nall.hpp higan_v092r08\nall\nall.hpp
--- higan_v092r07\nall\nall.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\nall.hpp	Thu May 02 05:48:01 2013
@@ -35,6 +35,7 @@
 #include <nall/property.hpp>
 #include <nall/random.hpp>
 #include <nall/serializer.hpp>
+#include <nall/set.hpp>
 #include <nall/sha256.hpp>
 #include <nall/sort.hpp>
 #include <nall/stdint.hpp>
diff -ru higan_v092r07\nall\png.hpp higan_v092r08\nall\png.hpp
--- higan_v092r07\nall\png.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\png.hpp	Thu May 02 05:48:01 2013
@@ -10,16 +10,16 @@
 namespace nall {
 
 struct png {
-  //colorType:
-  //0 = L
-  //2 = R,G,B
-  //3 = P
-  //4 = L,A
-  //6 = R,G,B,A
   struct Info {
     unsigned width;
     unsigned height;
     unsigned bitDepth;
+    //colorType:
+    //0 = L (luma)
+    //2 = R,G,B
+    //3 = P (palette)
+    //4 = L,A
+    //6 = R,G,B,A
     unsigned colorType;
     unsigned compressionMethod;
     unsigned filterType;
@@ -31,13 +31,13 @@
     uint8_t palette[256][3];
   } info;
 
-  uint8_t *data;
-  unsigned size;
+  uint8_t* data = nullptr;
+  unsigned size = 0;
 
-  inline bool decode(const string &filename);
-  inline bool decode(const uint8_t *sourceData, unsigned sourceSize);
-  inline unsigned readbits(const uint8_t *&data);
-  unsigned bitpos;
+  inline bool decode(const string& filename);
+  inline bool decode(const uint8_t* sourceData, unsigned sourceSize);
+  inline unsigned readbits(const uint8_t*& data);
+  unsigned bitpos = 0;
 
   inline png();
   inline ~png();
@@ -52,24 +52,24 @@
 
   inline unsigned interlace(unsigned pass, unsigned index);
   inline unsigned inflateSize();
-  inline bool deinterlace(const uint8_t *&inputData, unsigned pass);
-  inline bool filter(uint8_t *outputData, const uint8_t *inputData, unsigned width, unsigned height);
-  inline unsigned read(const uint8_t *data, unsigned length);
+  inline bool deinterlace(const uint8_t*& inputData, unsigned pass);
+  inline bool filter(uint8_t* outputData, const uint8_t* inputData, unsigned width, unsigned height);
+  inline unsigned read(const uint8_t* data, unsigned length);
 };
 
-bool png::decode(const string &filename) {
+bool png::decode(const string& filename) {
   if(auto memory = file::read(filename)) {
     return decode(memory.data(), memory.size());
   }
   return false;
 }
 
-bool png::decode(const uint8_t *sourceData, unsigned sourceSize) {
+bool png::decode(const uint8_t* sourceData, unsigned sourceSize) {
   if(sourceSize < 8) return false;
   if(read(sourceData + 0, 4) != 0x89504e47) return false;
   if(read(sourceData + 4, 4) != 0x0d0a1a0a) return false;
 
-  uint8_t *compressedData = nullptr;
+  uint8_t* compressedData = nullptr;
   unsigned compressedSize = 0;
 
   unsigned offset = 8;
@@ -102,8 +102,9 @@
       default: return false;
       }
 
-      if(info.colorType == 2 || info.colorType == 4 || info.colorType == 6)
+      if(info.colorType == 2 || info.colorType == 4 || info.colorType == 6) {
         if(info.bitDepth != 8 && info.bitDepth != 16) return false;
+      }
       if(info.colorType == 3 && info.bitDepth == 16) return false;
 
       info.bytesPerPixel = (info.bytesPerPixel + 7) / 8;
@@ -200,7 +201,7 @@
   return size;
 }
 
-bool png::deinterlace(const uint8_t *&inputData, unsigned pass) {
+bool png::deinterlace(const uint8_t*& inputData, unsigned pass) {
   unsigned xd = interlace(pass, 0), yd = interlace(pass, 1);
   unsigned xo = interlace(pass, 2), yo = interlace(pass, 3);
   unsigned width  = (info.width  + (xd - xo - 1)) / xd;
@@ -208,12 +209,12 @@
   if(width == 0 || height == 0) return true;
 
   unsigned outputSize = width * height * info.bytesPerPixel;
-  uint8_t *outputData = new uint8_t[outputSize];
+  uint8_t* outputData = new uint8_t[outputSize];
   bool result = filter(outputData, inputData, width, height);
 
-  const uint8_t *rd = outputData;
+  const uint8_t* rd = outputData;
   for(unsigned y = yo; y < info.height; y += yd) {
-    uint8_t *wr = data + y * info.pitch;
+    uint8_t* wr = data + y * info.pitch;
     for(unsigned x = xo; x < info.width; x += xd) {
       for(unsigned b = 0; b < info.bytesPerPixel; b++) {
         wr[x * info.bytesPerPixel + b] = *rd++;
@@ -226,9 +227,9 @@
   return result;
 }
 
-bool png::filter(uint8_t *outputData, const uint8_t *inputData, unsigned width, unsigned height) {
-  uint8_t *wr = outputData;
-  const uint8_t *rd = inputData;
+bool png::filter(uint8_t* outputData, const uint8_t* inputData, unsigned width, unsigned height) {
+  uint8_t* wr = outputData;
+  const uint8_t* rd = inputData;
   int bpp = info.bytesPerPixel, pitch = width * bpp;
   for(int y = 0; y < height; y++) {
     uint8_t filter = *rd++;
@@ -289,13 +290,13 @@
   return true;
 }
 
-unsigned png::read(const uint8_t *data, unsigned length) {
+unsigned png::read(const uint8_t* data, unsigned length) {
   unsigned result = 0;
   while(length--) result = (result << 8) | (*data++);
   return result;
 }
 
-unsigned png::readbits(const uint8_t *&data) {
+unsigned png::readbits(const uint8_t*& data) {
   unsigned result = 0;
   switch(info.bitDepth) {
   case 1:
@@ -324,8 +325,7 @@
   return result;
 }
 
-png::png() : data(nullptr) {
-  bitpos = 0;
+png::png() {
 }
 
 png::~png() {
diff -ru higan_v092r07\nall\priority-queue.hpp higan_v092r08\nall\priority-queue.hpp
--- higan_v092r07\nall\priority-queue.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\priority-queue.hpp	Thu May 02 05:48:01 2013
@@ -7,103 +7,104 @@
 #include <nall/utility.hpp>
 
 namespace nall {
-  template<typename type_t> void priority_queue_nocallback(type_t) {}
 
-  //priority queue implementation using binary min-heap array;
-  //does not require normalize() function.
-  //O(1)     find   (tick)
-  //O(log n) append (enqueue)
-  //O(log n) remove (dequeue)
-  template<typename type_t> class priority_queue {
-  public:
-    inline void tick(unsigned ticks) {
-      basecounter += ticks;
-      while(heapsize && gte(basecounter, heap[0].counter)) callback(dequeue());
-    }
-
-    //counter is relative to current time (eg enqueue(64, ...) fires in 64 ticks);
-    //counter cannot exceed std::numeric_limits<unsigned>::max() >> 1.
-    void enqueue(unsigned counter, type_t event) {
-      unsigned child = heapsize++;
-      counter += basecounter;
-
-      while(child) {
-        unsigned parent = (child - 1) >> 1;
-        if(gte(counter, heap[parent].counter)) break;
-
-        heap[child].counter = heap[parent].counter;
-        heap[child].event = heap[parent].event;
-        child = parent;
-      }
-
-      heap[child].counter = counter;
-      heap[child].event = event;
-    }
+template<typename type_t> void priority_queue_nocallback(type_t) {}
 
-    type_t dequeue() {
-      type_t event(heap[0].event);
-      unsigned parent = 0;
-      unsigned counter = heap[--heapsize].counter;
-
-      while(true) {
-        unsigned child = (parent << 1) + 1;
-        if(child >= heapsize) break;
-        if(child + 1 < heapsize && gte(heap[child].counter, heap[child + 1].counter)) child++;
-        if(gte(heap[child].counter, counter)) break;
-
-        heap[parent].counter = heap[child].counter;
-        heap[parent].event = heap[child].event;
-        parent = child;
-      }
-
-      heap[parent].counter = counter;
-      heap[parent].event = heap[heapsize].event;
-      return event;
-    }
-
-    void reset() {
-      basecounter = 0;
-      heapsize = 0;
-    }
+//priority queue implementation using binary min-heap array;
+//does not require normalize() function.
+//O(1)     find   (tick)
+//O(log n) append (enqueue)
+//O(log n) remove (dequeue)
+template<typename type_t> struct priority_queue {
+  inline void tick(unsigned ticks) {
+    basecounter += ticks;
+    while(heapsize && gte(basecounter, heap[0].counter)) callback(dequeue());
+  }
+
+  //counter is relative to current time (eg enqueue(64, ...) fires in 64 ticks);
+  //counter cannot exceed std::numeric_limits<unsigned>::max() >> 1.
+  void enqueue(unsigned counter, type_t event) {
+    unsigned child = heapsize++;
+    counter += basecounter;
+
+    while(child) {
+      unsigned parent = (child - 1) >> 1;
+      if(gte(counter, heap[parent].counter)) break;
+
+      heap[child].counter = heap[parent].counter;
+      heap[child].event = heap[parent].event;
+      child = parent;
+    }
+
+    heap[child].counter = counter;
+    heap[child].event = event;
+  }
+
+  type_t dequeue() {
+    type_t event(heap[0].event);
+    unsigned parent = 0;
+    unsigned counter = heap[--heapsize].counter;
+
+    while(true) {
+      unsigned child = (parent << 1) + 1;
+      if(child >= heapsize) break;
+      if(child + 1 < heapsize && gte(heap[child].counter, heap[child + 1].counter)) child++;
+      if(gte(heap[child].counter, counter)) break;
+
+      heap[parent].counter = heap[child].counter;
+      heap[parent].event = heap[child].event;
+      parent = child;
+    }
+
+    heap[parent].counter = counter;
+    heap[parent].event = heap[heapsize].event;
+    return event;
+  }
+
+  void reset() {
+    basecounter = 0;
+    heapsize = 0;
+  }
+
+  void serialize(serializer& s) {
+    s.integer(basecounter);
+    s.integer(heapsize);
+    for(unsigned n = 0; n < heapcapacity; n++) {
+      s.integer(heap[n].counter);
+      s.integer(heap[n].event);
+    }
+  }
+
+  priority_queue(unsigned size, function<void (type_t)> callback = &priority_queue_nocallback<type_t>)
+  : callback(callback) {
+    heap = new heap_t[size];
+    heapcapacity = size;
+    reset();
+  }
+
+  ~priority_queue() {
+    delete[] heap;
+  }
+
+  priority_queue& operator=(const priority_queue&) = delete;
+  priority_queue(const priority_queue&) = delete;
+
+private:
+  function<void (type_t)> callback;
+  unsigned basecounter;
+  unsigned heapsize;
+  unsigned heapcapacity;
+  struct heap_t {
+    unsigned counter;
+    type_t event;
+  } *heap;
+
+  //return true if x is greater than or equal to y
+  inline bool gte(unsigned x, unsigned y) {
+    return x - y < (std::numeric_limits<unsigned>::max() >> 1);
+  }
+};
 
-    void serialize(serializer &s) {
-      s.integer(basecounter);
-      s.integer(heapsize);
-      for(unsigned n = 0; n < heapcapacity; n++) {
-        s.integer(heap[n].counter);
-        s.integer(heap[n].event);
-      }
-    }
-
-    priority_queue(unsigned size, function<void (type_t)> callback_ = &priority_queue_nocallback<type_t>)
-    : callback(callback_) {
-      heap = new heap_t[size];
-      heapcapacity = size;
-      reset();
-    }
-
-    ~priority_queue() {
-      delete[] heap;
-    }
-
-    priority_queue& operator=(const priority_queue&) = delete;
-    priority_queue(const priority_queue&) = delete;
-
-  private:
-    function<void (type_t)> callback;
-    unsigned basecounter;
-    unsigned heapsize;
-    unsigned heapcapacity;
-    struct heap_t {
-      unsigned counter;
-      type_t event;
-    } *heap;
-
-    //return true if x is greater than or equal to y
-    inline bool gte(unsigned x, unsigned y) {
-      return x - y < (std::numeric_limits<unsigned>::max() >> 1);
-    }
-  };
 }
 
 #endif
diff -ru higan_v092r07\nall\property.hpp higan_v092r08\nall\property.hpp
--- higan_v092r07\nall\property.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\property.hpp	Thu May 02 05:48:01 2013
@@ -1,83 +1,44 @@
 #ifndef NALL_PROPERTY_HPP
 #define NALL_PROPERTY_HPP
 
-//nall::property implements ownership semantics into container classes
-//example: property<owner>::readonly<type> implies that only owner has full
-//access to type; and all other code has readonly access.
-//
-//property can be used either of two ways:
-//struct foo {
-//  property<foo>::readonly<bool> x;
-//  property<foo>::readwrite<int> y;
-//};
-//-or-
-//struct foo : property<foo> {
-//  readonly<bool> x;
-//  readwrite<int> y;
-//};
-
-//return types are const T& (byref) instead of T (byval) to avoid major speed
-//penalties for objects with expensive copy constructors
-
-//operator-> provides access to underlying object type:
-//readonly<Object> foo;
-//foo->bar();
-//... will call Object::bar();
-
-//operator='s reference is constant so as to avoid leaking a reference handle
-//that could bypass access restrictions
-
-//both constant and non-constant operators are provided, though it may be
-//necessary to cast first, for instance:
-//struct foo : property<foo> { readonly<int> bar; } object;
-//int main() { int value = const_cast<const foo&>(object); }
-
-//writeonly is useful for objects that have non-const reads, but const writes.
-//however, to avoid leaking handles, the interface is very restricted. the only
-//way to write is via operator=, which requires conversion via eg copy
-//constructor. example:
-//struct foo {
-//  foo(bool value) { ... }
-//};
-//writeonly<foo> bar;
-//bar = true;
-
 namespace nall {
-  template<typename C> struct property {
-    template<typename T> struct readonly {
-      const T* operator->() const { return &value; }
-      const T& operator()() const { return value; }
-      operator const T&() const { return value; }
-    private:
-      T* operator->() { return &value; }
-      operator T&() { return value; }
-      const T& operator=(const T& value_) { return value = value_; }
-      T value;
-      friend C;
-    };
 
-    template<typename T> struct writeonly {
-      void operator=(const T& value_) { value = value_; }
-    private:
-      const T* operator->() const { return &value; }
-      const T& operator()() const { return value; }
-      operator const T&() const { return value; }
-      T* operator->() { return &value; }
-      operator T&() { return value; }
-      T value;
-      friend C;
-    };
+template<typename C> struct property {
+  template<typename T> struct readonly {
+    const T* operator->() const { return &value; }
+    const T& operator()() const { return value; }
+    operator const T&() const { return value; }
+  private:
+    T* operator->() { return &value; }
+    operator T&() { return value; }
+    const T& operator=(const T& value_) { return value = value_; }
+    T value;
+    friend C;
+  };
 
-    template<typename T> struct readwrite {
-      const T* operator->() const { return &value; }
-      const T& operator()() const { return value; }
-      operator const T&() const { return value; }
-      T* operator->() { return &value; }
-      operator T&() { return value; }
-      const T& operator=(const T& value_) { return value = value_; }
-      T value;
-    };
+  template<typename T> struct writeonly {
+    void operator=(const T& value_) { value = value_; }
+  private:
+    const T* operator->() const { return &value; }
+    const T& operator()() const { return value; }
+    operator const T&() const { return value; }
+    T* operator->() { return &value; }
+    operator T&() { return value; }
+    T value;
+    friend C;
   };
+
+  template<typename T> struct readwrite {
+    const T* operator->() const { return &value; }
+    const T& operator()() const { return value; }
+    operator const T&() const { return value; }
+    T* operator->() { return &value; }
+    operator T&() { return value; }
+    const T& operator=(const T& value_) { return value = value_; }
+    T value;
+  };
+};
+
 }
 
 #endif
diff -ru higan_v092r07\nall\public-cast.hpp higan_v092r08\nall\public-cast.hpp
--- higan_v092r07\nall\public-cast.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\public-cast.hpp	Thu May 02 05:48:01 2013
@@ -14,19 +14,21 @@
 //Class::Reference may be a function, object or variable
 
 namespace nall {
-  template<typename T, typename T::type... P> struct public_cast;
 
-  template<typename T> struct public_cast<T> {
-    static typename T::type value;
-  };
+template<typename T, typename T::type... P> struct public_cast;
 
-  template<typename T> typename T::type public_cast<T>::value;
+template<typename T> struct public_cast<T> {
+  static typename T::type value;
+};
 
-  template<typename T, typename T::type P> struct public_cast<T, P> {
-    static typename T::type value;
-  };
+template<typename T> typename T::type public_cast<T>::value;
+
+template<typename T, typename T::type P> struct public_cast<T, P> {
+  static typename T::type value;
+};
+
+template<typename T, typename T::type P> typename T::type public_cast<T, P>::value = public_cast<T>::value = P;
 
-  template<typename T, typename T::type P> typename T::type public_cast<T, P>::value = public_cast<T>::value = P;
 }
 
 #endif
diff -ru higan_v092r07\nall\random.hpp higan_v092r08\nall\random.hpp
--- higan_v092r07\nall\random.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\random.hpp	Thu May 02 05:48:01 2013
@@ -1,28 +1,32 @@
 #ifndef NALL_RANDOM_HPP
 #define NALL_RANDOM_HPP
 
+//pseudo-random number generator
+//very low-quality, but very fast (based on CRC32 polynomial)
+
 namespace nall {
-  //pseudo-random number generator
-  inline unsigned prng() {
-    static unsigned n = 0;
-    return n = (n >> 1) ^ (((n & 1) - 1) & 0xedb88320);
+
+inline unsigned prng() {
+  static unsigned n = 0;
+  return n = (n >> 1) ^ (((n & 1) - 1) & 0xedb88320);
+}
+
+struct random_lfsr {
+  inline void seed(unsigned seed__) {
+    seed_ = seed__;
+  }
+
+  inline unsigned operator()() {
+    return seed_ = (seed_ >> 1) ^ (((seed_ & 1) - 1) & 0xedb88320);
+  }
+
+  random_lfsr() : seed_(0) {
   }
 
-  struct random_lfsr {
-    inline void seed(unsigned seed__) {
-      seed_ = seed__;
-    }
-
-    inline unsigned operator()() {
-      return seed_ = (seed_ >> 1) ^ (((seed_ & 1) - 1) & 0xedb88320);
-    }
-
-    random_lfsr() : seed_(0) {
-    }
-
-  private:
-    unsigned seed_;
-  };
+private:
+  unsigned seed_;
+};
+
 }
 
 #endif
diff -ru higan_v092r07\nall\serial.hpp higan_v092r08\nall\serial.hpp
--- higan_v092r07\nall\serial.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\serial.hpp	Thu May 02 05:48:01 2013
@@ -1,110 +1,118 @@
 #ifndef NALL_SERIAL_HPP
 #define NALL_SERIAL_HPP
 
+#include <nall/intrinsics.hpp>
+#include <nall/stdint.hpp>
+#include <nall/string.hpp>
+
+#if !defined(PLATFORM_X) && !defined(PLATFORM_OSX)
+  #error "nall/serial: unsupported platform"
+#endif
+
 #include <sys/ioctl.h>
 #include <fcntl.h>
 #include <termios.h>
 #include <unistd.h>
 
-#include <nall/stdint.hpp>
-
 namespace nall {
-  struct serial {
-    bool readable() {
-      if(port_open == false) return false;
-      fd_set fdset;
-      FD_ZERO(&fdset);
-      FD_SET(port, &fdset);
-      timeval timeout;
-      timeout.tv_sec = 0;
-      timeout.tv_usec = 0;
-      int result = select(FD_SETSIZE, &fdset, nullptr, nullptr, &timeout);
-      if(result < 1) return false;
-      return FD_ISSET(port, &fdset);
-    }
 
-    //-1 on error, otherwise return bytes read
-    int read(uint8_t *data, unsigned length) {
-      if(port_open == false) return -1;
-      return ::read(port, (void*)data, length);
-    }
-
-    bool writable() {
-      if(port_open == false) return false;
-      fd_set fdset;
-      FD_ZERO(&fdset);
-      FD_SET(port, &fdset);
-      timeval timeout;
-      timeout.tv_sec = 0;
-      timeout.tv_usec = 0;
-      int result = select(FD_SETSIZE, nullptr, &fdset, nullptr, &timeout);
-      if(result < 1) return false;
-      return FD_ISSET(port, &fdset);
-    }
-
-    //-1 on error, otherwise return bytes written
-    int write(const uint8_t *data, unsigned length) {
-      if(port_open == false) return -1;
-      return ::write(port, (void*)data, length);
-    }
-
-    bool open(const char *portname, unsigned rate, bool flowcontrol) {
-      close();
-
-      port = ::open(portname, O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK);
-      if(port == -1) return false;
-
-      if(ioctl(port, TIOCEXCL) == -1) { close(); return false; }
-      if(fcntl(port, F_SETFL, 0) == -1) { close(); return false; }
-      if(tcgetattr(port, &original_attr) == -1) { close(); return false; }
-
-      termios attr = original_attr;
-      cfmakeraw(&attr);
-      cfsetspeed(&attr, rate);
-
-      attr.c_lflag &=~ (ECHO | ECHONL | ISIG | ICANON | IEXTEN);
-      attr.c_iflag &=~ (BRKINT | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY);
-      attr.c_iflag |=  (IGNBRK | IGNPAR);
-      attr.c_oflag &=~ (OPOST);
-      attr.c_cflag &=~ (CSIZE | CSTOPB | PARENB | CLOCAL);
-      attr.c_cflag |=  (CS8 | CREAD);
-      if(flowcontrol == false) {
-        attr.c_cflag &= ~CRTSCTS;
-      } else {
-        attr.c_cflag |=  CRTSCTS;
-      }
-      attr.c_cc[VTIME] = attr.c_cc[VMIN] = 0;
-
-      if(tcsetattr(port, TCSANOW, &attr) == -1) { close(); return false; }
-      return port_open = true;
-    }
-
-    void close() {
-      if(port != -1) {
-        tcdrain(port);
-        if(port_open == true) {
-          tcsetattr(port, TCSANOW, &original_attr);
-          port_open = false;
-        }
-        ::close(port);
-        port = -1;
+struct serial {
+  bool readable() {
+    if(port_open == false) return false;
+    fd_set fdset;
+    FD_ZERO(&fdset);
+    FD_SET(port, &fdset);
+    timeval timeout;
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    int result = select(FD_SETSIZE, &fdset, nullptr, nullptr, &timeout);
+    if(result < 1) return false;
+    return FD_ISSET(port, &fdset);
+  }
+
+  //-1 on error, otherwise return bytes read
+  int read(uint8_t* data, unsigned length) {
+    if(port_open == false) return -1;
+    return ::read(port, (void*)data, length);
+  }
+
+  bool writable() {
+    if(port_open == false) return false;
+    fd_set fdset;
+    FD_ZERO(&fdset);
+    FD_SET(port, &fdset);
+    timeval timeout;
+    timeout.tv_sec = 0;
+    timeout.tv_usec = 0;
+    int result = select(FD_SETSIZE, nullptr, &fdset, nullptr, &timeout);
+    if(result < 1) return false;
+    return FD_ISSET(port, &fdset);
+  }
+
+  //-1 on error, otherwise return bytes written
+  int write(const uint8_t* data, unsigned length) {
+    if(port_open == false) return -1;
+    return ::write(port, (void*)data, length);
+  }
+
+  bool open(const string& portname, unsigned rate, bool flowcontrol) {
+    close();
+
+    port = ::open(portname, O_RDWR | O_NOCTTY | O_NDELAY | O_NONBLOCK);
+    if(port == -1) return false;
+
+    if(ioctl(port, TIOCEXCL) == -1) { close(); return false; }
+    if(fcntl(port, F_SETFL, 0) == -1) { close(); return false; }
+    if(tcgetattr(port, &original_attr) == -1) { close(); return false; }
+
+    termios attr = original_attr;
+    cfmakeraw(&attr);
+    cfsetspeed(&attr, rate);
+
+    attr.c_lflag &=~ (ECHO | ECHONL | ISIG | ICANON | IEXTEN);
+    attr.c_iflag &=~ (BRKINT | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY);
+    attr.c_iflag |=  (IGNBRK | IGNPAR);
+    attr.c_oflag &=~ (OPOST);
+    attr.c_cflag &=~ (CSIZE | CSTOPB | PARENB | CLOCAL);
+    attr.c_cflag |=  (CS8 | CREAD);
+    if(flowcontrol == false) {
+      attr.c_cflag &= ~CRTSCTS;
+    } else {
+      attr.c_cflag |=  CRTSCTS;
+    }
+    attr.c_cc[VTIME] = attr.c_cc[VMIN] = 0;
+
+    if(tcsetattr(port, TCSANOW, &attr) == -1) { close(); return false; }
+    return port_open = true;
+  }
+
+  void close() {
+    if(port != -1) {
+      tcdrain(port);
+      if(port_open == true) {
+        tcsetattr(port, TCSANOW, &original_attr);
+        port_open = false;
       }
-    }
-
-    serial() {
+      ::close(port);
       port = -1;
-      port_open = false;
     }
+  }
 
-    ~serial() {
-      close();
-    }
+  serial() {
+    port = -1;
+    port_open = false;
+  }
+
+  ~serial() {
+    close();
+  }
+
+private:
+  int port;
+  bool port_open;
+  termios original_attr;
+};
 
-  private:
-    int port;
-    bool port_open;
-    termios original_attr;
-  };
 }
 
 #endif
diff -ru higan_v092r07\nall\serializer.hpp higan_v092r08\nall\serializer.hpp
--- higan_v092r07\nall\serializer.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\serializer.hpp	Thu May 02 05:48:01 2013
@@ -1,145 +1,141 @@
 #ifndef NALL_SERIALIZER_HPP
 #define NALL_SERIALIZER_HPP
 
+//serializer: a class designed to save and restore the state of classes.
+//
+//benefits:
+//- data() will be portable in size (it is not necessary to specify type sizes.)
+//- data() will be portable in endianness (always stored internally as little-endian.)
+//- one serialize function can both save and restore class states.
+//
+//caveats:
+//- only plain-old-data can be stored. complex classes must provide serialize(serializer&);
+//- floating-point usage is not portable across platforms
+
 #include <type_traits>
 #include <utility>
 #include <nall/stdint.hpp>
 #include <nall/utility.hpp>
 
 namespace nall {
-  //serializer: a class designed to save and restore the state of classes.
-  //
-  //benefits:
-  //- data() will be portable in size (it is not necessary to specify type sizes.)
-  //- data() will be portable in endianness (always stored internally as little-endian.)
-  //- one serialize function can both save and restore class states.
-  //
-  //caveats:
-  //- only plain-old-data can be stored. complex classes must provide serialize(serializer&);
-  //- floating-point usage is not portable across platforms
-
-  class serializer {
-  public:
-    enum mode_t { Load, Save, Size };
-
-    mode_t mode() const {
-      return imode;
-    }
-
-    const uint8_t* data() const {
-      return idata;
-    }
-
-    unsigned size() const {
-      return isize;
-    }
-
-    unsigned capacity() const {
-      return icapacity;
-    }
-
-    template<typename T> void floatingpoint(T &value) {
-      enum { size = sizeof(T) };
-      //this is rather dangerous, and not cross-platform safe;
-      //but there is no standardized way to export FP-values
-      uint8_t *p = (uint8_t*)&value;
-      if(imode == Save) {
-        for(unsigned n = 0; n < size; n++) idata[isize++] = p[n];
-      } else if(imode == Load) {
-        for(unsigned n = 0; n < size; n++) p[n] = idata[isize++];
-      } else {
-        isize += size;
-      }
-    }
-
-    template<typename T> void integer(T &value) {
-      enum { size = std::is_same<bool, T>::value ? 1 : sizeof(T) };
-      if(imode == Save) {
-        for(unsigned n = 0; n < size; n++) idata[isize++] = (uintmax_t)value >> (n << 3);
-      } else if(imode == Load) {
-        value = 0;
-        for(unsigned n = 0; n < size; n++) value |= (uintmax_t)idata[isize++] << (n << 3);
-      } else if(imode == Size) {
-        isize += size;
-      }
-    }
-
-    template<typename T> void array(T &array) {
-      enum { size = sizeof(T) / sizeof(typename std::remove_extent<T>::type) };
-      for(unsigned n = 0; n < size; n++) integer(array[n]);
-    }
-
-    template<typename T> void array(T array, unsigned size) {
-      for(unsigned n = 0; n < size; n++) integer(array[n]);
-    }
 
-    //copy
-    serializer& operator=(const serializer &s) {
-      if(idata) delete[] idata;
-
-      imode = s.imode;
-      idata = new uint8_t[s.icapacity];
-      isize = s.isize;
-      icapacity = s.icapacity;
-
-      memcpy(idata, s.idata, s.icapacity);
-      return *this;
-    }
-
-    serializer(const serializer &s) : idata(nullptr) {
-      operator=(s);
-    }
-
-    //move
-    serializer& operator=(serializer &&s) {
-      if(idata) delete[] idata;
-
-      imode = s.imode;
-      idata = s.idata;
-      isize = s.isize;
-      icapacity = s.icapacity;
-
-      s.idata = nullptr;
-      return *this;
-    }
-
-    serializer(serializer &&s) {
-      operator=(std::move(s));
-    }
-
-    //construction
-    serializer() {
-      imode = Size;
-      idata = nullptr;
-      isize = 0;
-      icapacity = 0;
-    }
-
-    serializer(unsigned capacity) {
-      imode = Save;
-      idata = new uint8_t[capacity]();
-      isize = 0;
-      icapacity = capacity;
-    }
-
-    serializer(const uint8_t *data, unsigned capacity) {
-      imode = Load;
-      idata = new uint8_t[capacity];
-      isize = 0;
-      icapacity = capacity;
-      memcpy(idata, data, capacity);
-    }
-
-    ~serializer() {
-      if(idata) delete[] idata;
-    }
+struct serializer {
+  enum mode_t { Load, Save, Size };
 
-  private:
-    mode_t imode;
-    uint8_t *idata;
-    unsigned isize;
-    unsigned icapacity;
-  };
+  mode_t mode() const {
+    return imode;
+  }
+
+  const uint8_t* data() const {
+    return idata;
+  }
+
+  unsigned size() const {
+    return isize;
+  }
+
+  unsigned capacity() const {
+    return icapacity;
+  }
+
+  template<typename T> void floatingpoint(T& value) {
+    enum { size = sizeof(T) };
+    //this is rather dangerous, and not cross-platform safe;
+    //but there is no standardized way to export FP-values
+    uint8_t* p = (uint8_t*)&value;
+    if(imode == Save) {
+      for(unsigned n = 0; n < size; n++) idata[isize++] = p[n];
+    } else if(imode == Load) {
+      for(unsigned n = 0; n < size; n++) p[n] = idata[isize++];
+    } else {
+      isize += size;
+    }
+  }
+
+  template<typename T> void integer(T& value) {
+    enum { size = std::is_same<bool, T>::value ? 1 : sizeof(T) };
+    if(imode == Save) {
+      for(unsigned n = 0; n < size; n++) idata[isize++] = (uintmax_t)value >> (n << 3);
+    } else if(imode == Load) {
+      value = 0;
+      for(unsigned n = 0; n < size; n++) value |= (uintmax_t)idata[isize++] << (n << 3);
+    } else if(imode == Size) {
+      isize += size;
+    }
+  }
+
+  template<typename T> void array(T& array) {
+    enum { size = sizeof(T) / sizeof(typename std::remove_extent<T>::type) };
+    for(unsigned n = 0; n < size; n++) integer(array[n]);
+  }
+
+  template<typename T> void array(T array, unsigned size) {
+    for(unsigned n = 0; n < size; n++) integer(array[n]);
+  }
+
+  //copy
+  serializer& operator=(const serializer& s) {
+    if(idata) delete[] idata;
+
+    imode = s.imode;
+    idata = new uint8_t[s.icapacity];
+    isize = s.isize;
+    icapacity = s.icapacity;
+
+    memcpy(idata, s.idata, s.icapacity);
+    return *this;
+  }
+
+  serializer(const serializer& s) {
+    operator=(s);
+  }
+
+  //move
+  serializer& operator=(serializer&& s) {
+    if(idata) delete[] idata;
+
+    imode = s.imode;
+    idata = s.idata;
+    isize = s.isize;
+    icapacity = s.icapacity;
+
+    s.idata = nullptr;
+    return *this;
+  }
+
+  serializer(serializer&& s) {
+    operator=(std::move(s));
+  }
+
+  //construction
+  serializer() = default;
+
+  serializer(unsigned capacity) {
+    imode = Save;
+    idata = new uint8_t[capacity]();
+    isize = 0;
+    icapacity = capacity;
+  }
+
+  serializer(const uint8_t* data, unsigned capacity) {
+    imode = Load;
+    idata = new uint8_t[capacity];
+    isize = 0;
+    icapacity = capacity;
+    memcpy(idata, data, capacity);
+  }
+
+  //destruction
+  ~serializer() {
+    if(idata) delete[] idata;
+  }
+
+private:
+  mode_t imode = Size;
+  uint8_t* idata = nullptr;
+  unsigned isize = 0;
+  unsigned icapacity = 0;
+};
 
 };
 
Only in higan_v092r08\nall: set.hpp
diff -ru higan_v092r07\nall\sha256.hpp higan_v092r08\nall\sha256.hpp
--- higan_v092r07\nall\sha256.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\sha256.hpp	Thu May 02 05:48:01 2013
@@ -6,140 +6,142 @@
 #include <nall/stdint.hpp>
 
 namespace nall {
-  #define PTR(t, a) ((t*)(a))
 
-  #define SWAP32(x) ((uint32_t)(           \
-    (((uint32_t)(x) & 0x000000ff) << 24) | \
-    (((uint32_t)(x) & 0x0000ff00) <<  8) | \
-    (((uint32_t)(x) & 0x00ff0000) >>  8) | \
-    (((uint32_t)(x) & 0xff000000) >> 24)   \
-  ))
-
-  #define ST32(a, d) *PTR(uint32_t, a) = (d)
-  #define ST32BE(a, d) ST32(a, SWAP32(d))
-
-  #define LD32(a) *PTR(uint32_t, a)
-  #define LD32BE(a) SWAP32(LD32(a))
-
-  #define LSL32(x, n) ((uint32_t)(x) << (n))
-  #define LSR32(x, n) ((uint32_t)(x) >> (n))
-  #define ROR32(x, n) (LSR32(x, n) | LSL32(x, 32 - (n)))
-
-  //first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
-  static const uint32_t T_H[8] = {
-    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
-  };
-
-  //first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311
-  static const uint32_t T_K[64] = {
-    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
-    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
-    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
-    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
-    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
-    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
-    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
-    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
-  };
-
-  struct sha256_ctx {
-    uint8_t in[64];
-    unsigned inlen;
-
-    uint32_t w[64];
-    uint32_t h[8];
-    uint64_t len;
-  };
-
-  inline void sha256_init(sha256_ctx *p) {
-    memset(p, 0, sizeof(sha256_ctx));
-    memcpy(p->h, T_H, sizeof(T_H));
+#define PTR(t, a) ((t*)(a))
+
+#define SWAP32(x) ((uint32_t)(           \
+  (((uint32_t)(x) & 0x000000ff) << 24) | \
+  (((uint32_t)(x) & 0x0000ff00) <<  8) | \
+  (((uint32_t)(x) & 0x00ff0000) >>  8) | \
+  (((uint32_t)(x) & 0xff000000) >> 24)   \
+))
+
+#define ST32(a, d) *PTR(uint32_t, a) = (d)
+#define ST32BE(a, d) ST32(a, SWAP32(d))
+
+#define LD32(a) *PTR(uint32_t, a)
+#define LD32BE(a) SWAP32(LD32(a))
+
+#define LSL32(x, n) ((uint32_t)(x) << (n))
+#define LSR32(x, n) ((uint32_t)(x) >> (n))
+#define ROR32(x, n) (LSR32(x, n) | LSL32(x, 32 - (n)))
+
+//first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
+static const uint32_t T_H[8] = {
+  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
+};
+
+//first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311
+static const uint32_t T_K[64] = {
+  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
+};
+
+struct sha256_ctx {
+  uint8_t in[64];
+  unsigned inlen;
+
+  uint32_t w[64];
+  uint32_t h[8];
+  uint64_t len;
+};
+
+inline void sha256_init(sha256_ctx* p) {
+  memset(p, 0, sizeof(sha256_ctx));
+  memcpy(p->h, T_H, sizeof(T_H));
+}
+
+static void sha256_block(sha256_ctx* p) {
+  unsigned i;
+  uint32_t s0, s1;
+  uint32_t a, b, c, d, e, f, g, h;
+  uint32_t t1, t2, maj, ch;
+
+  for(i = 0; i < 16; i++) p->w[i] = LD32BE(p->in + i * 4);
+
+  for(i = 16; i < 64; i++) {
+    s0 = ROR32(p->w[i - 15],  7) ^ ROR32(p->w[i - 15], 18) ^ LSR32(p->w[i - 15],  3);
+    s1 = ROR32(p->w[i -  2], 17) ^ ROR32(p->w[i -  2], 19) ^ LSR32(p->w[i -  2], 10);
+    p->w[i] = p->w[i - 16] + s0 + p->w[i - 7] + s1;
   }
 
-  static void sha256_block(sha256_ctx *p) {
-    unsigned i;
-    uint32_t s0, s1;
-    uint32_t a, b, c, d, e, f, g, h;
-    uint32_t t1, t2, maj, ch;
-
-    for(i = 0; i < 16; i++) p->w[i] = LD32BE(p->in + i * 4);
-
-    for(i = 16; i < 64; i++) {
-      s0 = ROR32(p->w[i - 15],  7) ^ ROR32(p->w[i - 15], 18) ^ LSR32(p->w[i - 15],  3);
-      s1 = ROR32(p->w[i -  2], 17) ^ ROR32(p->w[i -  2], 19) ^ LSR32(p->w[i -  2], 10);
-      p->w[i] = p->w[i - 16] + s0 + p->w[i - 7] + s1;
-    }
-
-    a = p->h[0]; b = p->h[1]; c = p->h[2]; d = p->h[3];
-    e = p->h[4]; f = p->h[5]; g = p->h[6]; h = p->h[7];
-
-    for(i = 0; i < 64; i++) {
-      s0 = ROR32(a, 2) ^ ROR32(a, 13) ^ ROR32(a, 22);
-      maj = (a & b) ^ (a & c) ^ (b & c);
-      t2 = s0 + maj;
-      s1 = ROR32(e, 6) ^ ROR32(e, 11) ^ ROR32(e, 25);
-      ch = (e & f) ^ (~e & g);
-      t1 = h + s1 + ch + T_K[i] + p->w[i];
-
-      h = g; g = f; f = e; e = d + t1;
-      d = c; c = b; b = a; a = t1 + t2;
-    }
+  a = p->h[0]; b = p->h[1]; c = p->h[2]; d = p->h[3];
+  e = p->h[4]; f = p->h[5]; g = p->h[6]; h = p->h[7];
 
-    p->h[0] += a; p->h[1] += b; p->h[2] += c; p->h[3] += d;
-    p->h[4] += e; p->h[5] += f; p->h[6] += g; p->h[7] += h;
+  for(i = 0; i < 64; i++) {
+    s0 = ROR32(a, 2) ^ ROR32(a, 13) ^ ROR32(a, 22);
+    maj = (a & b) ^ (a & c) ^ (b & c);
+    t2 = s0 + maj;
+    s1 = ROR32(e, 6) ^ ROR32(e, 11) ^ ROR32(e, 25);
+    ch = (e & f) ^ (~e & g);
+    t1 = h + s1 + ch + T_K[i] + p->w[i];
 
-    //next block
-    p->inlen = 0;
+    h = g; g = f; f = e; e = d + t1;
+    d = c; c = b; b = a; a = t1 + t2;
   }
 
-  inline void sha256_chunk(sha256_ctx *p, const uint8_t *s, unsigned len) {
-    unsigned l;
-    p->len += len;
-
-    while(len) {
-      l = 64 - p->inlen;
-      l = (len < l) ? len : l;
-
-      memcpy(p->in + p->inlen, s, l);
-      s += l;
-      p->inlen += l;
-      len -= l;
+  p->h[0] += a; p->h[1] += b; p->h[2] += c; p->h[3] += d;
+  p->h[4] += e; p->h[5] += f; p->h[6] += g; p->h[7] += h;
+
+  //next block
+  p->inlen = 0;
+}
+
+inline void sha256_chunk(sha256_ctx* p, const uint8_t* s, unsigned len) {
+  unsigned l;
+  p->len += len;
+
+  while(len) {
+    l = 64 - p->inlen;
+    l = (len < l) ? len : l;
+
+    memcpy(p->in + p->inlen, s, l);
+    s += l;
+    p->inlen += l;
+    len -= l;
 
-      if(p->inlen == 64) sha256_block(p);
-    }
+    if(p->inlen == 64) sha256_block(p);
   }
+}
+
+inline void sha256_final(sha256_ctx* p) {
+  uint64_t len;
+  p->in[p->inlen++] = 0x80;
 
-  inline void sha256_final(sha256_ctx *p) {
-    uint64_t len;
-    p->in[p->inlen++] = 0x80;
-
-    if(p->inlen > 56) {
-      memset(p->in + p->inlen, 0, 64 - p->inlen);
-      sha256_block(p);
-    }
-
-    memset(p->in + p->inlen, 0, 56 - p->inlen);
-
-    len = p->len << 3;
-    ST32BE(p->in + 56, len >> 32);
-    ST32BE(p->in + 60, len);
+  if(p->inlen > 56) {
+    memset(p->in + p->inlen, 0, 64 - p->inlen);
     sha256_block(p);
   }
 
-  inline void sha256_hash(sha256_ctx *p, uint8_t *s) {
-    uint32_t *t = (uint32_t*)s;
-    for(unsigned i = 0; i < 8; i++) ST32BE(t++, p->h[i]);
-  }
+  memset(p->in + p->inlen, 0, 56 - p->inlen);
+
+  len = p->len << 3;
+  ST32BE(p->in + 56, len >> 32);
+  ST32BE(p->in + 60, len);
+  sha256_block(p);
+}
+
+inline void sha256_hash(sha256_ctx* p, uint8_t* s) {
+  uint32_t *t = (uint32_t*)s;
+  for(unsigned i = 0; i < 8; i++) ST32BE(t++, p->h[i]);
+}
+
+#undef PTR
+#undef SWAP32
+#undef ST32
+#undef ST32BE
+#undef LD32
+#undef LD32BE
+#undef LSL32
+#undef LSR32
+#undef ROR32
 
-  #undef PTR
-  #undef SWAP32
-  #undef ST32
-  #undef ST32BE
-  #undef LD32
-  #undef LD32BE
-  #undef LSL32
-  #undef LSR32
-  #undef ROR32
 }
 
 #endif
diff -ru higan_v092r07\nall\sort.hpp higan_v092r08\nall\sort.hpp
--- higan_v092r07\nall\sort.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\sort.hpp	Thu May 02 05:48:01 2013
@@ -19,59 +19,59 @@
 //#define NALL_SORT_SELECTION
 
 namespace nall {
-  template<typename T, typename Comparator>
-  void sort(T list[], unsigned size, const Comparator &lessthan) {
-    if(size <= 1) return;  //nothing to sort
-
-    //use insertion sort to quickly sort smaller blocks
-    if(size < 64) {
-      #if defined(NALL_SORT_INSERTION)
-      for(signed i = 1, j; i < size; i++) {
-        T copy = std::move(list[i]);
-        for(j = i - 1; j >= 0; j--) {
-          if(!lessthan(copy, list[j])) break;
-          list[j + 1] = std::move(list[j]);
-        }
-        list[j + 1] = std::move(copy);
-      }
-      #elif defined(NALL_SORT_SELECTION)
-      for(unsigned i = 0; i < size; i++) {
-        unsigned min = i;
-        for(unsigned j = i + 1; j < size; j++) {
-          if(lessthan(list[j], list[min])) min = j;
-        }
-        if(min != i) std::swap(list[i], list[min]);
+
+template<typename T, typename Comparator> void sort(T list[], unsigned size, const Comparator& lessthan) {
+  if(size <= 1) return;  //nothing to sort
+
+  //use insertion sort to quickly sort smaller blocks
+  if(size < 64) {
+    #if defined(NALL_SORT_INSERTION)
+    for(signed i = 1, j; i < size; i++) {
+      T copy = std::move(list[i]);
+      for(j = i - 1; j >= 0; j--) {
+        if(!lessthan(copy, list[j])) break;
+        list[j + 1] = std::move(list[j]);
       }
-      #endif
-      return;
+      list[j + 1] = std::move(copy);
     }
-
-    //split list in half and recursively sort both
-    unsigned middle = size / 2;
-    sort(list, middle, lessthan);
-    sort(list + middle, size - middle, lessthan);
-
-    //left and right are sorted here; perform merge sort
-    T *buffer = new T[size];
-    unsigned offset = 0, left = 0, right = middle;
-    while(left < middle && right < size) {
-      if(!lessthan(list[right], list[left])) {
-        buffer[offset++] = std::move(list[left++]);
-      } else {
-        buffer[offset++] = std::move(list[right++]);
+    #elif defined(NALL_SORT_SELECTION)
+    for(unsigned i = 0; i < size; i++) {
+      unsigned min = i;
+      for(unsigned j = i + 1; j < size; j++) {
+        if(lessthan(list[j], list[min])) min = j;
       }
+      if(min != i) std::swap(list[i], list[min]);
     }
-    while(left < middle) buffer[offset++] = std::move(list[left++]);
-    while(right < size)  buffer[offset++] = std::move(list[right++]);
-
-    for(unsigned i = 0; i < size; i++) list[i] = std::move(buffer[i]);
-    delete[] buffer;
+    #endif
+    return;
   }
 
-  template<typename T>
-  void sort(T list[], unsigned size) {
-    return sort(list, size, [](const T &l, const T &r) { return l < r; });
+  //split list in half and recursively sort both
+  unsigned middle = size / 2;
+  sort(list, middle, lessthan);
+  sort(list + middle, size - middle, lessthan);
+
+  //left and right are sorted here; perform merge sort
+  T* buffer = new T[size];
+  unsigned offset = 0, left = 0, right = middle;
+  while(left < middle && right < size) {
+    if(!lessthan(list[right], list[left])) {
+      buffer[offset++] = std::move(list[left++]);
+    } else {
+      buffer[offset++] = std::move(list[right++]);
+    }
   }
+  while(left < middle) buffer[offset++] = std::move(list[left++]);
+  while(right < size)  buffer[offset++] = std::move(list[right++]);
+
+  for(unsigned i = 0; i < size; i++) list[i] = std::move(buffer[i]);
+  delete[] buffer;
+}
+
+template<typename T> void sort(T list[], unsigned size) {
+  return sort(list, size, [](const T& l, const T& r) { return l < r; });
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\stdint.hpp higan_v092r08\nall\stdint.hpp
--- higan_v092r07\nall\stdint.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stdint.hpp	Thu May 02 05:48:02 2013
@@ -28,15 +28,17 @@
 #endif
 
 namespace nall {
-  static_assert(sizeof(int8_t)   == 1, "int8_t is not of the correct size" );
-  static_assert(sizeof(int16_t)  == 2, "int16_t is not of the correct size");
-  static_assert(sizeof(int32_t)  == 4, "int32_t is not of the correct size");
-  static_assert(sizeof(int64_t)  == 8, "int64_t is not of the correct size");
 
-  static_assert(sizeof(uint8_t)  == 1, "int8_t is not of the correct size" );
-  static_assert(sizeof(uint16_t) == 2, "int16_t is not of the correct size");
-  static_assert(sizeof(uint32_t) == 4, "int32_t is not of the correct size");
-  static_assert(sizeof(uint64_t) == 8, "int64_t is not of the correct size");
+static_assert(sizeof(int8_t)   == 1, "int8_t is not of the correct size" );
+static_assert(sizeof(int16_t)  == 2, "int16_t is not of the correct size");
+static_assert(sizeof(int32_t)  == 4, "int32_t is not of the correct size");
+static_assert(sizeof(int64_t)  == 8, "int64_t is not of the correct size");
+
+static_assert(sizeof(uint8_t)  == 1, "int8_t is not of the correct size" );
+static_assert(sizeof(uint16_t) == 2, "int16_t is not of the correct size");
+static_assert(sizeof(uint32_t) == 4, "int32_t is not of the correct size");
+static_assert(sizeof(uint64_t) == 8, "int64_t is not of the correct size");
+
 }
 
 #endif
diff -ru higan_v092r07\nall\stream\auto.hpp higan_v092r08\nall\stream\auto.hpp
--- higan_v092r07\nall\stream\auto.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\auto.hpp	Thu May 02 05:48:02 2013
@@ -5,18 +5,18 @@
 
 #define autostream(...) (*makestream(__VA_ARGS__))
 
-inline std::unique_ptr<stream> makestream(const string &path) {
+inline std::unique_ptr<stream> makestream(const string& path) {
   if(path.ibeginswith("http://")) return std::unique_ptr<stream>(new httpstream(path, 80));
   if(path.iendswith(".gz")) return std::unique_ptr<stream>(new gzipstream(filestream{path}));
   if(path.iendswith(".zip")) return std::unique_ptr<stream>(new zipstream(filestream{path}));
   return std::unique_ptr<stream>(new mmapstream(path));
 }
 
-inline std::unique_ptr<stream> makestream(uint8_t *data, unsigned size) {
+inline std::unique_ptr<stream> makestream(uint8_t* data, unsigned size) {
   return std::unique_ptr<stream>(new memorystream(data, size));
 }
 
-inline std::unique_ptr<stream> makestream(const uint8_t *data, unsigned size) {
+inline std::unique_ptr<stream> makestream(const uint8_t* data, unsigned size) {
   return std::unique_ptr<stream>(new memorystream(data, size));
 }
 
diff -ru higan_v092r07\nall\stream\file.hpp higan_v092r08\nall\stream\file.hpp
--- higan_v092r07\nall\stream\file.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\file.hpp	Thu May 02 05:48:02 2013
@@ -21,13 +21,13 @@
   uint8_t read() const { return pfile.read(); }
   void write(uint8_t data) const { pfile.write(data); }
 
-  filestream(const string &filename) {
+  filestream(const string& filename) {
     pfile.open(filename, file::mode::readwrite);
     pwritable = pfile.open();
     if(!pwritable) pfile.open(filename, file::mode::read);
   }
 
-  filestream(const string &filename, file::mode mode) {
+  filestream(const string& filename, file::mode mode) {
     pfile.open(filename, mode);
     pwritable = mode == file::mode::write || mode == file::mode::readwrite;
   }
diff -ru higan_v092r07\nall\stream\gzip.hpp higan_v092r08\nall\stream\gzip.hpp
--- higan_v092r07\nall\stream\gzip.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\gzip.hpp	Thu May 02 05:48:02 2013
@@ -9,7 +9,7 @@
   using stream::read;
   using stream::write;
 
-  gzipstream(const stream &stream) {
+  gzipstream(const stream& stream) {
     unsigned size = stream.size();
     uint8_t *data = new uint8_t[size];
     stream.read(data, size);
diff -ru higan_v092r07\nall\stream\http.hpp higan_v092r08\nall\stream\http.hpp
--- higan_v092r07\nall\stream\http.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\http.hpp	Thu May 02 05:48:02 2013
@@ -24,7 +24,7 @@
   uint8_t read(unsigned offset) const { return pdata[offset]; }
   void write(unsigned offset, uint8_t data) const { pdata[offset] = data; }
 
-  httpstream(const string &url, unsigned port) : pdata(nullptr), psize(0), poffset(0) {
+  httpstream(const string& url, unsigned port) : pdata(nullptr), psize(0), poffset(0) {
     string uri = url;
     uri.ltrim<1>("http://");
     lstring part = uri.split<1>("/");
@@ -40,7 +40,7 @@
   }
 
 private:
-  mutable uint8_t *pdata;
+  mutable uint8_t* pdata;
   mutable unsigned psize, poffset;
 };
 
diff -ru higan_v092r07\nall\stream\memory.hpp higan_v092r08\nall\stream\memory.hpp
--- higan_v092r07\nall\stream\memory.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\memory.hpp	Thu May 02 05:48:02 2013
@@ -14,7 +14,7 @@
   bool writable() const { return pwritable; }
   bool randomaccess() const { return true; }
 
-  uint8_t *data() const { return pdata; }
+  uint8_t* data() const { return pdata; }
   unsigned size() const { return psize; }
   unsigned offset() const { return poffset; }
   void seek(unsigned offset) const { poffset = offset; }
@@ -27,18 +27,18 @@
 
   memorystream() : pdata(nullptr), psize(0), poffset(0), pwritable(true) {}
 
-  memorystream(uint8_t *data, unsigned size) {
+  memorystream(uint8_t* data, unsigned size) {
     pdata = data, psize = size, poffset = 0;
     pwritable = true;
   }
 
-  memorystream(const uint8_t *data, unsigned size) {
+  memorystream(const uint8_t* data, unsigned size) {
     pdata = (uint8_t*)data, psize = size, poffset = 0;
     pwritable = false;
   }
 
 protected:
-  mutable uint8_t *pdata;
+  mutable uint8_t* pdata;
   mutable unsigned psize, poffset, pwritable;
 };
 
diff -ru higan_v092r07\nall\stream\mmap.hpp higan_v092r08\nall\stream\mmap.hpp
--- higan_v092r07\nall\stream\mmap.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\mmap.hpp	Thu May 02 05:48:02 2013
@@ -24,7 +24,7 @@
   uint8_t read(unsigned offset) const { return pdata[offset]; }
   void write(unsigned offset, uint8_t data) const { pdata[offset] = data; }
 
-  mmapstream(const string &filename) {
+  mmapstream(const string& filename) {
     pmmap.open(filename, filemap::mode::readwrite);
     pwritable = pmmap.open();
     if(!pwritable) pmmap.open(filename, filemap::mode::read);
@@ -33,7 +33,7 @@
 
 private:
   mutable filemap pmmap;
-  mutable uint8_t *pdata;
+  mutable uint8_t* pdata;
   mutable unsigned pwritable, poffset;
 };
 
diff -ru higan_v092r07\nall\stream\stream.hpp higan_v092r08\nall\stream\stream.hpp
--- higan_v092r07\nall\stream\stream.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\stream.hpp	Thu May 02 05:48:02 2013
@@ -44,7 +44,7 @@
     return data;
   }
 
-  void read(uint8_t *data, unsigned length) const {
+  void read(uint8_t* data, unsigned length) const {
     while(length--) *data++ = read();
   }
 
@@ -72,17 +72,17 @@
     }
   }
 
-  void write(const uint8_t *data, unsigned length) const {
+  void write(const uint8_t* data, unsigned length) const {
     while(length--) write(*data++);
   }
 
   struct byte {
     operator uint8_t() const { return s.read(offset); }
     byte& operator=(uint8_t data) { s.write(offset, data); return *this; }
-    byte(const stream &s, unsigned offset) : s(s), offset(offset) {}
+    byte(const stream& s, unsigned offset) : s(s), offset(offset) {}
 
   private:
-    const stream &s;
+    const stream& s;
     const unsigned offset;
   };
 
diff -ru higan_v092r07\nall\stream\vector.hpp higan_v092r08\nall\stream\vector.hpp
--- higan_v092r07\nall\stream\vector.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\vector.hpp	Thu May 02 05:48:02 2013
@@ -26,11 +26,11 @@
   uint8_t read(unsigned offset) const { return memory[offset]; }
   void write(unsigned offset, uint8_t data) const { memory[offset] = data; }
 
-  vectorstream(vector<uint8_t> &memory) : memory(memory), poffset(0), pwritable(true) {}
-  vectorstream(const vector<uint8_t> &memory) : memory((vector<uint8_t>&)memory), poffset(0), pwritable(false) {}
+  vectorstream(vector<uint8_t>& memory) : memory(memory), poffset(0), pwritable(true) {}
+  vectorstream(const vector<uint8_t>& memory) : memory((vector<uint8_t>&)memory), poffset(0), pwritable(false) {}
 
 protected:
-  vector<uint8_t> &memory;
+  vector<uint8_t>& memory;
   mutable unsigned poffset, pwritable;
 };
 
diff -ru higan_v092r07\nall\stream\zip.hpp higan_v092r08\nall\stream\zip.hpp
--- higan_v092r07\nall\stream\zip.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\stream\zip.hpp	Thu May 02 05:48:02 2013
@@ -9,16 +9,16 @@
   using stream::read;
   using stream::write;
 
-  zipstream(const stream &stream, const string &filter = "*") {
+  zipstream(const stream& stream, const string& filter = "*") {
     unsigned size = stream.size();
-    uint8_t *data = new uint8_t[size];
+    uint8_t* data = new uint8_t[size];
     stream.read(data, size);
 
     unzip archive;
     if(archive.open(data, size) == false) return;
     delete[] data;
 
-    for(auto &file : archive.file) {
+    for(auto& file : archive.file) {
       if(file.name.wildcard(filter)) {
         auto buffer = archive.extract(file);
         psize = buffer.size();
diff -ru higan_v092r07\nall\string\base.hpp higan_v092r08\nall\string\base.hpp
--- higan_v092r07\nall\string\base.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\base.hpp	Thu May 02 05:48:02 2013
@@ -11,19 +11,18 @@
     inline unsigned length() const;
     inline bool operator==(const char*) const;
     inline bool operator!=(const char*) const;
-    inline optional<unsigned> position(const char *key) const;
-    inline optional<unsigned> iposition(const char *key) const;
-    inline cstring& operator=(const char *data);
-    inline cstring(const char *data);
+    inline optional<unsigned> position(const char* key) const;
+    inline optional<unsigned> iposition(const char* key) const;
+    inline cstring& operator=(const char* data);
+    inline cstring(const char* data);
     inline cstring();
 
   protected:
-    const char *data;
+    const char* data;
   };
 
   struct string {
-    //deprecated: use string text = file::read(filename);
-    inline static string read(const string &filename);
+    inline static string read(const string& filename);
 
     inline static string date();
     inline static string time();
@@ -68,18 +67,18 @@
     inline string& upper();
     inline string& qlower();
     inline string& qupper();
-    inline string& transform(const char *before, const char *after);
+    inline string& transform(const char* before, const char* after);
     inline string& reverse();
 
-    template<unsigned limit = 0> inline string& ltrim(const char *key = " ");
-    template<unsigned limit = 0> inline string& rtrim(const char *key = " ");
-    template<unsigned limit = 0> inline string& trim(const char *key = " ", const char *rkey = nullptr);
+    template<unsigned limit = 0> inline string& ltrim(const char* key = " ");
+    template<unsigned limit = 0> inline string& rtrim(const char* key = " ");
+    template<unsigned limit = 0> inline string& trim(const char* key = " ", const char* rkey = nullptr);
     inline string& strip();
 
-    inline optional<unsigned> position(const char *key) const;
-    inline optional<unsigned> iposition(const char *key) const;
-    inline optional<unsigned> qposition(const char *key) const;
-    inline optional<unsigned> iqposition(const char *key) const;
+    inline optional<unsigned> position(const char* key) const;
+    inline optional<unsigned> iposition(const char* key) const;
+    inline optional<unsigned> qposition(const char* key) const;
+    inline optional<unsigned> iqposition(const char* key) const;
 
     inline explicit operator bool() const;
     inline operator const char*() const;
@@ -111,7 +110,7 @@
     inline string& append_(const char*);
 
   protected:
-    char *data;
+    char* data;
     unsigned size;
 
     template<unsigned Limit, bool Insensitive, bool Quoted> inline string& ureplace(const char*, const char*);
@@ -125,8 +124,9 @@
   struct lstring : vector<string> {
     inline optional<unsigned> find(const char*) const;
     inline string concatenate(const char*) const;
+    inline lstring& isort();
+    inline lstring& strip();
     inline void append() {}
-    inline void isort();
     template<typename... Args> inline void append(const string&, Args&&...);
 
     template<unsigned Limit = 0> inline lstring& split(const char*, const char*);
@@ -153,81 +153,81 @@
   //compare.hpp
   inline char chrlower(char c);
   inline char chrupper(char c);
-  inline int istrcmp(const char *str1, const char *str2);
-  inline bool strbegin(const char *str, const char *key);
-  inline bool istrbegin(const char *str, const char *key);
-  inline bool strend(const char *str, const char *key);
-  inline bool istrend(const char *str, const char *key);
+  inline int istrcmp(const char* str1, const char* str2);
+  inline bool strbegin(const char* str, const char* key);
+  inline bool istrbegin(const char* str, const char* key);
+  inline bool strend(const char* str, const char* key);
+  inline bool istrend(const char* str, const char* key);
 
   //convert.hpp
-  inline char* strlower(char *str);
-  inline char* strupper(char *str);
-  inline char* qstrlower(char *str);
-  inline char* qstrupper(char *str);
-  inline char* strtr(char *dest, const char *before, const char *after);
+  inline char* strlower(char* str);
+  inline char* strupper(char* str);
+  inline char* qstrlower(char* str);
+  inline char* qstrupper(char* str);
+  inline char* strtr(char* dest, const char* before, const char* after);
 
   //format.hpp
-  template<signed precision = 0, char padchar = ' '> inline string format(const string &value);
+  template<signed precision = 0, char padchar = ' '> inline string format(const string& value);
   template<signed precision = 0, char padchar = '0'> inline string hex(uintmax_t value);
   template<signed precision = 0, char padchar = '0'> inline string octal(uintmax_t value);
   template<signed precision = 0, char padchar = '0'> inline string binary(uintmax_t value);
 
   //math.hpp
-  inline bool strint(const char *str, int &result);
-  inline bool strmath(const char *str, int &result);
+  inline bool strint(const char* str, int& result);
+  inline bool strmath(const char* str, int& result);
 
   //platform.hpp
   inline string activepath();
-  inline string realpath(const string &name);
+  inline string realpath(const string& name);
   inline string userpath();
   inline string configpath();
   inline string sharedpath();
   inline string temppath();
 
   //strm.hpp
-  inline unsigned strmcpy(char *target, const char *source, unsigned length);
-  inline unsigned strmcat(char *target, const char *source, unsigned length);
-  inline bool strccpy(char *target, const char *source, unsigned length);
-  inline bool strccat(char *target, const char *source, unsigned length);
-  inline void strpcpy(char *&target, const char *source, unsigned &length);
+  inline unsigned strmcpy(char* target, const char* source, unsigned length);
+  inline unsigned strmcat(char* target, const char* source, unsigned length);
+  inline bool strccpy(char* target, const char* source, unsigned length);
+  inline bool strccat(char* target, const char* source, unsigned length);
+  inline void strpcpy(char*& target, const char* source, unsigned& length);
 
   //strpos.hpp
-  inline optional<unsigned> strpos(const char *str, const char *key);
-  inline optional<unsigned> istrpos(const char *str, const char *key);
-  inline optional<unsigned> qstrpos(const char *str, const char *key);
-  inline optional<unsigned> iqstrpos(const char *str, const char *key);
-  template<bool Insensitive = false, bool Quoted = false> inline optional<unsigned> ustrpos(const char *str, const char *key);
+  inline optional<unsigned> strpos(const char* str, const char* key);
+  inline optional<unsigned> istrpos(const char* str, const char* key);
+  inline optional<unsigned> qstrpos(const char* str, const char* key);
+  inline optional<unsigned> iqstrpos(const char* str, const char* key);
+  template<bool Insensitive = false, bool Quoted = false> inline optional<unsigned> ustrpos(const char* str, const char* key);
 
   //trim.hpp
-  template<unsigned limit = 0> inline char* ltrim(char *str, const char *key = " ");
-  template<unsigned limit = 0> inline char* rtrim(char *str, const char *key = " ");
-  template<unsigned limit = 0> inline char* trim(char *str, const char *key = " ", const char *rkey = nullptr);
-  inline char* strip(char *s);
+  template<unsigned limit = 0> inline char* ltrim(char* str, const char* key = " ");
+  template<unsigned limit = 0> inline char* rtrim(char* str, const char* key = " ");
+  template<unsigned limit = 0> inline char* trim(char* str, const char* key = " ", const char* rkey = nullptr);
+  inline char* strip(char* s);
 
   //utility.hpp
   template<bool Insensitive> alwaysinline bool chrequal(char x, char y);
-  template<bool Quoted, typename T> alwaysinline bool quoteskip(T *&p);
-  template<bool Quoted, typename T> alwaysinline bool quotecopy(char *&t, T *&p);
-  inline string substr(const char *src, unsigned start = 0, unsigned length = ~0u);
-  inline string sha256(const uint8_t *data, unsigned size);
+  template<bool Quoted, typename T> alwaysinline bool quoteskip(T*& p);
+  template<bool Quoted, typename T> alwaysinline bool quotecopy(char*& t, T*& p);
+  inline string substr(const char* src, unsigned start = 0, unsigned length = ~0u);
+  inline string sha256(const uint8_t* data, unsigned size);
 
-  inline char* integer(char *result, intmax_t value);
-  inline char* decimal(char *result, uintmax_t value);
+  inline char* integer(char* result, intmax_t value);
+  inline char* decimal(char* result, uintmax_t value);
 
   //these functions are deprecated, use format() instead:
   template<unsigned length = 0, char padding = ' '> inline string integer(intmax_t value);
   template<unsigned length = 0, char padding = ' '> inline string linteger(intmax_t value);
   template<unsigned length = 0, char padding = ' '> inline string decimal(uintmax_t value);
   template<unsigned length = 0, char padding = ' '> inline string ldecimal(uintmax_t value);
-  inline unsigned fp(char *str, long double value);
+  inline unsigned fp(char* str, long double value);
   inline string fp(long double value);
 
   //variadic.hpp
   template<typename... Args> inline void print(Args&&... args);
 
   //wildcard.hpp
-  inline bool wildcard(const char *str, const char *pattern);
-  inline bool iwildcard(const char *str, const char *pattern);
+  inline bool wildcard(const char* str, const char* pattern);
+  inline bool iwildcard(const char* str, const char* pattern);
 };
 
 #endif
diff -ru higan_v092r07\nall\string\bsv.hpp higan_v092r08\nall\string\bsv.hpp
--- higan_v092r07\nall\string\bsv.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\bsv.hpp	Thu May 02 05:48:02 2013
@@ -6,7 +6,7 @@
 namespace nall {
 
 struct BSV {
-  static inline string decode(const char *input) {
+  static inline string decode(const char* input) {
     string output;
     unsigned offset = 0;
     while(*input) {
@@ -30,7 +30,7 @@
     return output;
   }
 
-  static inline string encode(const char *input) {
+  static inline string encode(const char* input) {
     string output;
     unsigned offset = 0;
     while(*input) {
diff -ru higan_v092r07\nall\string\cast.hpp higan_v092r08\nall\string\cast.hpp
--- higan_v092r07\nall\string\cast.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\cast.hpp	Thu May 02 05:48:02 2013
@@ -119,7 +119,7 @@
 // arrays
 
 template<> struct stringify<vector<uint8_t>> {
-  char *text;
+  char* text;
   operator const char*() const { return text; }
   stringify(vector<uint8_t> value) {
     text = new char[value.size() + 1]();
@@ -131,9 +131,9 @@
 };
 
 template<> struct stringify<const vector<uint8_t>&> {
-  char *text;
+  char* text;
   operator const char*() const { return text; }
-  stringify(const vector<uint8_t> &value) {
+  stringify(const vector<uint8_t>& value) {
     text = new char[value.size() + 1]();
     memcpy(text, value.data(), value.size());
   }
@@ -145,53 +145,53 @@
 // strings
 
 template<> struct stringify<char*> {
-  const char *value;
+  const char* value;
   operator const char*() const { return value; }
-  stringify(char *value) : value(value) {}
+  stringify(char* value) : value(value) {}
 };
 
 template<> struct stringify<const char*> {
-  const char *value;
+  const char* value;
   operator const char*() const { return value; }
-  stringify(const char *value) : value(value) {}
+  stringify(const char* value) : value(value) {}
 };
 
 template<> struct stringify<string> {
-  const string &value;
+  const string& value;
   operator const char*() const { return value; }
-  stringify(const string &value) : value(value) {}
+  stringify(const string& value) : value(value) {}
 };
 
 template<> struct stringify<const string&> {
-  const string &value;
+  const string& value;
   operator const char*() const { return value; }
-  stringify(const string &value) : value(value) {}
+  stringify(const string& value) : value(value) {}
 };
 
 template<> struct stringify<cstring> {
-  const char *value;
+  const char* value;
   operator const char*() const { return value; }
-  stringify(const cstring &value) : value(value) {}
+  stringify(const cstring& value) : value(value) {}
 };
 
 template<> struct stringify<const cstring&> {
-  const char *value;
+  const char* value;
   operator const char*() const { return value; }
-  stringify(const cstring &value) : value(value) {}
+  stringify(const cstring& value) : value(value) {}
 };
 
 #if defined(QSTRING_H)
 
 template<> struct stringify<QString> {
-  const QString &value;
+  const QString& value;
   operator const char*() const { return value.toUtf8().constData(); }
-  stringify(const QString &value) : value(value) {}
+  stringify(const QString& value) : value(value) {}
 };
 
 template<> struct stringify<const QString&> {
-  const QString &value;
+  const QString& value;
   operator const char*() const { return value.toUtf8().constData(); }
-  stringify(const QString &value) : value(value) {}
+  stringify(const QString& value) : value(value) {}
 };
 
 string::operator QString() const {
diff -ru higan_v092r07\nall\string\compare.hpp higan_v092r08\nall\string\compare.hpp
--- higan_v092r07\nall\string\compare.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\compare.hpp	Thu May 02 05:48:02 2013
@@ -10,7 +10,7 @@
   return (c >= 'a' && c <= 'z') ? c - ('a' - 'A') : c;
 }
 
-int istrcmp(const char *str1, const char *str2) {
+int istrcmp(const char* str1, const char* str2) {
   while(*str1) {
     if(chrlower(*str1) != chrlower(*str2)) break;
     str1++, str2++;
@@ -18,14 +18,14 @@
   return (int)chrlower(*str1) - (int)chrlower(*str2);
 }
 
-bool strbegin(const char *str, const char *key) {
+bool strbegin(const char* str, const char* key) {
   int i, ssl = strlen(str), ksl = strlen(key);
 
   if(ksl > ssl) return false;
   return (!memcmp(str, key, ksl));
 }
 
-bool istrbegin(const char *str, const char *key) {
+bool istrbegin(const char* str, const char* key) {
   int ssl = strlen(str), ksl = strlen(key);
 
   if(ksl > ssl) return false;
@@ -41,14 +41,14 @@
   return true;
 }
 
-bool strend(const char *str, const char *key) {
+bool strend(const char* str, const char* key) {
   int ssl = strlen(str), ksl = strlen(key);
 
   if(ksl > ssl) return false;
   return (!memcmp(str + ssl - ksl, key, ksl));
 }
 
-bool istrend(const char *str, const char *key) {
+bool istrend(const char* str, const char* key) {
   int ssl = strlen(str), ksl = strlen(key);
 
   if(ksl > ssl) return false;
diff -ru higan_v092r07\nall\string\convert.hpp higan_v092r08\nall\string\convert.hpp
--- higan_v092r07\nall\string\convert.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\convert.hpp	Thu May 02 05:48:02 2013
@@ -2,7 +2,7 @@
 
 namespace nall {
 
-char* strlower(char *str) {
+char* strlower(char* str) {
   if(!str) return nullptr;
   int i = 0;
   while(str[i]) {
@@ -12,7 +12,7 @@
   return str;
 }
 
-char* strupper(char *str) {
+char* strupper(char* str) {
   if(!str) return nullptr;
   int i = 0;
   while(str[i]) {
@@ -22,7 +22,7 @@
   return str;
 }
 
-char* qstrlower(char *s) {
+char* qstrlower(char* s) {
   if(!s) return nullptr;
   bool quoted = false;
   while(*s) {
@@ -32,7 +32,7 @@
   }
 }
 
-char* qstrupper(char *s) {
+char* qstrupper(char* s) {
   if(!s) return nullptr;
   bool quoted = false;
   while(*s) {
@@ -42,7 +42,7 @@
   }
 }
 
-char* strtr(char *dest, const char *before, const char *after) {
+char* strtr(char* dest, const char* before, const char* after) {
   if(!dest || !before || !after) return dest;
   int sl = strlen(dest), bsl = strlen(before), asl = strlen(after);
 
diff -ru higan_v092r07\nall\string\core.hpp higan_v092r08\nall\string\core.hpp
--- higan_v092r07\nall\string\core.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\core.hpp	Thu May 02 05:48:02 2013
@@ -6,7 +6,7 @@
 }
 
 template<typename T, typename... Args>
-static void istring(string &output, const T &value, Args&&... args) {
+static void istring(string& output, const T& value, Args&&... args) {
   output.append_(make_string(value));
   istring(output, std::forward<Args>(args)...);
 }
@@ -46,14 +46,14 @@
   return *this;
 }
 
-string& string::assign_(const char *s) {
+string& string::assign_(const char* s) {
   unsigned length = strlen(s);
   reserve(length);
   strcpy(data, s);
   return *this;
 }
 
-string& string::append_(const char *s) {
+string& string::append_(const char* s) {
   unsigned length = strlen(data) + strlen(s);
   reserve(length);
   strcat(data, s);
@@ -77,20 +77,20 @@
   return data[index];
 }
 
-bool string::operator==(const char *str) const { return strcmp(data, str) == 0; }
-bool string::operator!=(const char *str) const { return strcmp(data, str) != 0; }
-bool string::operator< (const char *str) const { return strcmp(data, str)  < 0; }
-bool string::operator<=(const char *str) const { return strcmp(data, str) <= 0; }
-bool string::operator> (const char *str) const { return strcmp(data, str)  > 0; }
-bool string::operator>=(const char *str) const { return strcmp(data, str) >= 0; }
+bool string::operator==(const char* str) const { return strcmp(data, str) == 0; }
+bool string::operator!=(const char* str) const { return strcmp(data, str) != 0; }
+bool string::operator< (const char* str) const { return strcmp(data, str)  < 0; }
+bool string::operator<=(const char* str) const { return strcmp(data, str) <= 0; }
+bool string::operator> (const char* str) const { return strcmp(data, str)  > 0; }
+bool string::operator>=(const char* str) const { return strcmp(data, str) >= 0; }
 
-string& string::operator=(const string &value) {
+string& string::operator=(const string& value) {
   if(&value == this) return *this;
   assign(value);
   return *this;
 }
 
-string& string::operator=(string &&source) {
+string& string::operator=(string&& source) {
   if(&source == this) return *this;
   if(data) free(data);
   size = source.size;
@@ -107,13 +107,13 @@
   istring(*this, std::forward<Args>(args)...);
 }
 
-string::string(const string &value) {
+string::string(const string& value) {
   if(&value == this) return;
   size = strlen(value);
   data = strdup(value);
 }
 
-string::string(string &&source) {
+string::string(string&& source) {
   if(&source == this) return;
   size = source.size;
   data = source.data;
@@ -124,7 +124,7 @@
   if(data) free(data);
 }
 
-bool string::readfile(const string &filename) {
+bool string::readfile(const string& filename) {
   assign("");
 
   #if !defined(_WIN32)
@@ -147,14 +147,14 @@
   return true;
 }
 
-optional<unsigned> lstring::find(const char *key) const {
+optional<unsigned> lstring::find(const char* key) const {
   for(unsigned i = 0; i < size(); i++) {
     if(operator[](i) == key) return { true, i };
   }
   return { false, 0 };
 }
 
-string lstring::concatenate(const char *separator) const {
+string lstring::concatenate(const char* separator) const {
   string output;
   for(unsigned i = 0; i < size(); i++) {
     output.append(operator[](i), i < size() - 1 ? separator : "");
@@ -162,18 +162,26 @@
   return output;
 }
 
-template<typename... Args> void lstring::append(const string &data, Args&&... args) {
-  vector::append(data);
-  append(std::forward<Args>(args)...);
-}
-
-void lstring::isort() {
-  nall::sort(pool, objectsize, [](const string &x, const string &y) {
+lstring& lstring::isort() {
+  nall::sort(pool, objectsize, [](const string& x, const string& y) {
     return istrcmp(x, y) < 0;
   });
+  return *this;
+}
+
+lstring& lstring::strip() {
+  for(unsigned n = 0; n < size(); n++) {
+    operator[](n).strip();
+  }
+  return *this;
+}
+
+template<typename... Args> void lstring::append(const string& data, Args&&... args) {
+  vector::append(data);
+  append(std::forward<Args>(args)...);
 }
 
-bool lstring::operator==(const lstring &source) const {
+bool lstring::operator==(const lstring& source) const {
   if(this == &source) return true;
   if(size() != source.size()) return false;
   for(unsigned n = 0; n < size(); n++) {
@@ -182,21 +190,21 @@
   return true;
 }
 
-bool lstring::operator!=(const lstring &source) const {
+bool lstring::operator!=(const lstring& source) const {
   return !operator==(source);
 }
 
-lstring& lstring::operator=(const lstring &source) {
+lstring& lstring::operator=(const lstring& source) {
   vector::operator=(source);
   return *this;
 }
 
-lstring& lstring::operator=(lstring &source) {
+lstring& lstring::operator=(lstring& source) {
   vector::operator=(source);
   return *this;
 }
 
-lstring& lstring::operator=(lstring &&source) {
+lstring& lstring::operator=(lstring&& source) {
   vector::operator=(std::move(source));
   return *this;
 }
@@ -205,15 +213,15 @@
   append(std::forward<Args>(args)...);
 }
 
-lstring::lstring(const lstring &source) {
+lstring::lstring(const lstring& source) {
   vector::operator=(source);
 }
 
-lstring::lstring(lstring &source) {
+lstring::lstring(lstring& source) {
   vector::operator=(source);
 }
 
-lstring::lstring(lstring &&source) {
+lstring::lstring(lstring&& source) {
   vector::operator=(std::move(source));
 }
 
diff -ru higan_v092r07\nall\string\cstring.hpp higan_v092r08\nall\string\cstring.hpp
--- higan_v092r07\nall\string\cstring.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\cstring.hpp	Thu May 02 05:48:02 2013
@@ -8,12 +8,12 @@
 
 cstring::operator const char*() const { return data; }
 unsigned cstring::length() const { return strlen(data); }
-bool cstring::operator==(const char *s) const { return !strcmp(data, s); }
-bool cstring::operator!=(const char *s) const { return  strcmp(data, s); }
-optional<unsigned> cstring::position (const char *key) const { return  strpos(data, key); }
-optional<unsigned> cstring::iposition(const char *key) const { return istrpos(data, key); }
-cstring& cstring::operator=(const char *data) { this->data = data; return *this; }
-cstring::cstring(const char *data) : data(data) {}
+bool cstring::operator==(const char* s) const { return !strcmp(data, s); }
+bool cstring::operator!=(const char* s) const { return  strcmp(data, s); }
+optional<unsigned> cstring::position (const char* key) const { return  strpos(data, key); }
+optional<unsigned> cstring::iposition(const char* key) const { return istrpos(data, key); }
+cstring& cstring::operator=(const char* data) { this->data = data; return *this; }
+cstring::cstring(const char* data) : data(data) {}
 cstring::cstring() : data("") {}
 
 }
diff -ru higan_v092r07\nall\string\datetime.hpp higan_v092r08\nall\string\datetime.hpp
--- higan_v092r07\nall\string\datetime.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\datetime.hpp	Thu May 02 05:48:02 2013
@@ -4,7 +4,7 @@
 
 string string::date() {
   time_t timestamp = ::time(nullptr);
-  tm *info = localtime(&timestamp);
+  tm* info = localtime(&timestamp);
   return {
     decimal<4, '0'>(1900 + info->tm_year), "-",
     decimal<2, '0'>(1 + info->tm_mon), "-",
@@ -14,7 +14,7 @@
 
 string string::time() {
   time_t timestamp = ::time(nullptr);
-  tm *info = localtime(&timestamp);
+  tm* info = localtime(&timestamp);
   return {
     decimal<2, '0'>(info->tm_hour), ":",
     decimal<2, '0'>(info->tm_min), ":",
diff -ru higan_v092r07\nall\string\format.hpp higan_v092r08\nall\string\format.hpp
--- higan_v092r07\nall\string\format.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\format.hpp	Thu May 02 05:48:02 2013
@@ -2,7 +2,7 @@
 
 namespace nall {
 
-template<signed precision, char padchar> string format(const string &value) {
+template<signed precision, char padchar> string format(const string& value) {
   if(precision == 0) return value;
 
   bool padright = precision >= 0;
diff -ru higan_v092r07\nall\string\markup\bml.hpp higan_v092r08\nall\string\markup\bml.hpp
--- higan_v092r07\nall\string\markup\bml.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\markup\bml.hpp	Thu May 02 05:48:02 2013
@@ -14,21 +14,21 @@
   }
 
   //determine indentation level, without incrementing pointer
-  unsigned readDepth(const char *p) {
+  unsigned readDepth(const char* p) {
     unsigned depth = 0;
     while(p[depth] == '\t' || p[depth] == ' ') depth++;
     return depth;
   }
 
   //determine indentation level
-  unsigned parseDepth(const char *&p) {
+  unsigned parseDepth(const char*& p) {
     unsigned depth = readDepth(p);
     p += depth;
     return depth;
   }
 
   //read name
-  void parseName(const char *&p) {
+  void parseName(const char*& p) {
     unsigned length = 0;
     while(valid(p[length])) length++;
     if(length == 0) throw "Invalid node name";
@@ -36,7 +36,7 @@
     p += length;
   }
 
-  void parseData(const char *&p) {
+  void parseData(const char*& p) {
     if(*p == '=' && *(p + 1) == '\"') {
       unsigned length = 2;
       while(p[length] && p[length] != '\n' && p[length] != '\"') length++;
@@ -58,7 +58,7 @@
   }
 
   //read all attributes for a node
-  void parseAttributes(const char *&p) {
+  void parseAttributes(const char*& p) {
     while(*p && *p != '\n') {
       if(*p != ' ') throw "Invalid node name";
       while(*p == ' ') p++;  //skip excess spaces
@@ -77,8 +77,8 @@
   }
 
   //read a node and all of its child nodes
-  void parseNode(const lstring &text, unsigned &y) {
-    const char *p = text[y++];
+  void parseNode(const lstring& text, unsigned& y) {
+    const char* p = text[y++];
     level = parseDepth(p);
     parseName(p);
     parseData(p);
@@ -102,8 +102,8 @@
   }
 
   //read top-level nodes
-  void parse(const string &document) {
-    lstring text = document.split("\n");
+  void parse(const string& document) {
+    lstring text = string{document}.replace("\r", "").split("\n");
 
     //remove empty lines and comment lines
     for(unsigned y = 0; y < text.size();) {
@@ -134,12 +134,12 @@
 struct Document : Node {
   string error;
 
-  bool load(const string &document) {
+  bool load(const string& document) {
     name = "", data = "";
 
     try {
       parse(document);
-    } catch(const char *error) {
+    } catch(const char* error) {
       this->error = error;
       children.reset();
       return false;
@@ -147,7 +147,7 @@
     return true;
   }
 
-  Document(const string &document = "") {
+  Document(const string& document = "") {
     load(document);
   }
 };
diff -ru higan_v092r07\nall\string\markup\document.hpp higan_v092r08\nall\string\markup\document.hpp
--- higan_v092r07\nall\string\markup\document.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\markup\document.hpp	Thu May 02 05:48:02 2013
@@ -3,7 +3,7 @@
 namespace nall {
 namespace Markup {
 
-inline Node Document(const string &markup) {
+inline Node Document(const string& markup) {
   if(markup.beginswith("<")) return XML::Document(markup);
   return BML::Document(markup);
 }
diff -ru higan_v092r07\nall\string\markup\node.hpp higan_v092r08\nall\string\markup\node.hpp
--- higan_v092r07\nall\string\markup\node.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\markup\node.hpp	Thu May 02 05:48:02 2013
@@ -32,11 +32,11 @@
     children.reset();
   }
 
-  bool evaluate(const string &query) const {
+  bool evaluate(const string& query) const {
     if(query.empty()) return true;
     lstring rules = string{query}.replace(" ", "").split(",");
 
-    for(auto &rule : rules) {
+    for(auto& rule : rules) {
       enum class Comparator : unsigned { ID, EQ, NE, LT, LE, GT, GE };
       auto comparator = Comparator::ID;
            if(rule.wildcard("*!=*")) comparator = Comparator::NE;
@@ -83,7 +83,7 @@
     return true;
   }
 
-  vector<Node> find(const string &query) const {
+  vector<Node> find(const string& query) const {
     vector<Node> result;
 
     lstring path = query.split("/");
@@ -105,7 +105,7 @@
     }
 
     unsigned position = 0;
-    for(auto &node : children) {
+    for(auto& node : children) {
       if(node.name.wildcard(name) == false) continue;
       if(node.evaluate(rule) == false) continue;
 
@@ -116,22 +116,23 @@
       if(path.size() == 0) result.append(node);
       else {
         auto list = node.find(path.concatenate("/"));
-        for(auto &item : list) result.append(item);
+        for(auto& item : list) result.append(item);
       }
     }
 
     return result;
   }
 
-  Node operator[](const string &query) const {
+  Node operator[](const string& query) const {
     auto result = find(query);
     return result(0);
   }
 
-  Node* begin() { return children.begin(); }
-  Node* end() { return children.end(); }
-  const Node* begin() const { return children.begin(); }
-  const Node* end() const { return children.end(); }
+  vector<Node>::iterator begin() { return children.begin(); }
+  vector<Node>::iterator end() { return children.end(); }
+
+  const vector<Node>::const_iterator begin() const { return children.begin(); }
+  const vector<Node>::const_iterator end() const { return children.end(); }
 
   Node() : attribute(false), level(0) {}
 
diff -ru higan_v092r07\nall\string\markup\xml.hpp higan_v092r08\nall\string\markup\xml.hpp
--- higan_v092r07\nall\string\markup\xml.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\markup\xml.hpp	Thu May 02 05:48:02 2013
@@ -35,7 +35,7 @@
   }
 
   //copy part of string from source document into target string; decode markup while copying
-  inline void copy(string &target, const char *source, unsigned length) {
+  inline void copy(string& target, const char* source, unsigned length) {
     target.reserve(length + 1);
 
     #if defined(NALL_XML_LITERAL)
@@ -44,7 +44,7 @@
     return;
     #endif
 
-    char *output = target();
+    char* output = target();
     while(length) {
       if(*source == '&') {
         if(!memcmp(source, "&lt;",   4)) { *output++ = '<';  source += 4; length -= 4; continue; }
@@ -77,7 +77,7 @@
     *output = 0;
   }
 
-  inline bool parseExpression(const char *&p) {
+  inline bool parseExpression(const char*& p) {
     if(*(p + 1) != '!') return false;
 
     //comment
@@ -112,11 +112,11 @@
   }
 
   //returns true if tag closes itself (<tag/>); false if not (<tag>)
-  inline bool parseHead(const char *&p) {
+  inline bool parseHead(const char*& p) {
     //parse name
-    const char *nameStart = ++p;  //skip '<'
+    const char* nameStart = ++p;  //skip '<'
     while(isName(*p)) p++;
-    const char *nameEnd = p;
+    const char* nameEnd = p;
     copy(name, nameStart, nameEnd - nameStart);
     if(name.empty()) throw "missing element name";
 
@@ -130,9 +130,9 @@
       Node attribute;
       attribute.attribute = true;
 
-      const char *nameStart = p;
+      const char* nameStart = p;
       while(isName(*p)) p++;
-      const char *nameEnd = p;
+      const char* nameEnd = p;
       copy(attribute.name, nameStart, nameEnd - nameStart);
       if(attribute.name.empty()) throw "missing attribute name";
 
@@ -140,10 +140,10 @@
       if(*p++ != '=') throw "missing attribute value";
       char terminal = *p++;
       if(terminal != '\'' && terminal != '\"') throw "attribute value not quoted";
-      const char *dataStart = p;
+      const char* dataStart = p;
       while(*p && *p != terminal) p++;
       if(!*p) throw "missing attribute data terminal";
-      const char *dataEnd = p++;  //skip closing terminal
+      const char* dataEnd = p++;  //skip closing terminal
 
       copy(attribute.data, dataStart, dataEnd - dataStart);
       children.append(attribute);
@@ -157,27 +157,28 @@
   }
 
   //parse element and all of its child elements
-  inline void parseElement(const char *&p) {
+  inline void parseElement(const char*& p) {
     Node node;
     if(node.parseHead(p) == false) node.parse(p);
     children.append(node);
   }
 
   //return true if </tag> matches this node's name
-  inline bool parseClosureElement(const char *&p) {
+  inline bool parseClosureElement(const char*& p) {
     if(p[0] != '<' || p[1] != '/') return false;
     p += 2;
-    const char *nameStart = p;
+    const char* nameStart = p;
     while(*p && *p != '>') p++;
     if(*p != '>') throw "unclosed closure element";
-    const char *nameEnd = p++;
+    const char* nameEnd = p++;
     if(memcmp(name, nameStart, nameEnd - nameStart)) throw "closure element name mismatch";
     return true;
   }
 
   //parse contents of an element
-  inline void parse(const char *&p) {
-    const char *dataStart = p, *dataEnd = p;
+  inline void parse(const char*& p) {
+    const char* dataStart = p;
+    const char* dataEnd = p;
 
     while(*p) {
       while(*p && *p != '<') p++;
@@ -195,12 +196,12 @@
 struct Document : Node {
   string error;
 
-  inline bool load(const char *document) {
+  inline bool load(const char* document) {
     if(document == nullptr) return false;
     reset();
     try {
       parse(document);
-    } catch(const char *error) {
+    } catch(const char* error) {
       reset();
       this->error = error;
       return false;
@@ -209,7 +210,7 @@
   }
 
   inline Document() {}
-  inline Document(const char *document) { load(document); }
+  inline Document(const char* document) { load(document); }
 };
 
 }
diff -ru higan_v092r07\nall\string\math-fixed-point.hpp higan_v092r08\nall\string\math-fixed-point.hpp
--- higan_v092r07\nall\string\math-fixed-point.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\math-fixed-point.hpp	Thu May 02 05:48:02 2013
@@ -2,9 +2,9 @@
 
 namespace fixedpoint {
 
-static nall::function<intmax_t (const char *&)> eval_fallback;
+static nall::function<intmax_t (const char*&)> eval_fallback;
 
-static intmax_t eval_integer(const char *& s) {
+static intmax_t eval_integer(const char*& s) {
   if(!*s) throw "unrecognized integer";
   intmax_t value = 0, x = *s, y = *(s + 1);
 
@@ -58,7 +58,7 @@
   throw "unrecognized integer";
 }
 
-static intmax_t eval(const char *&s, int depth = 0) {
+static intmax_t eval(const char*& s, int depth = 0) {
   while(*s == ' ' || *s == '\t') s++;  //trim whitespace
   if(!*s) throw "unrecognized token";
   intmax_t value = 0, x = *s, y = *(s + 1);
@@ -142,7 +142,7 @@
   return value;
 }
 
-static bool eval(const char *s, intmax_t &result) {
+static bool eval(const char* s, intmax_t &result) {
   try {
     result = eval(s);
     return true;
@@ -152,11 +152,11 @@
   }
 }
 
-static intmax_t parse(const char *s) {
+static intmax_t parse(const char* s) {
   try {
     intmax_t result = eval(s);
     return result;
-  } catch(const char *) {
+  } catch(const char*) {
     return 0;
   }
 }
diff -ru higan_v092r07\nall\string\math-floating-point.hpp higan_v092r08\nall\string\math-floating-point.hpp
--- higan_v092r07\nall\string\math-floating-point.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\math-floating-point.hpp	Thu May 02 05:48:02 2013
@@ -2,9 +2,9 @@
 
 namespace floatingpoint {
 
-static nall::function<double (const char *&)> eval_fallback;
+static nall::function<double (const char*&)> eval_fallback;
 
-static double eval_integer(const char *&s) {
+static double eval_integer(const char*& s) {
   if(!*s) throw "unrecognized integer";
   intmax_t value = 0, radix = 0, x = *s, y = *(s + 1);
 
@@ -64,7 +64,7 @@
   throw "unrecognized integer";
 }
 
-static double eval(const char *&s, int depth = 0) {
+static double eval(const char*& s, int depth = 0) {
   while(*s == ' ' || *s == '\t') s++;  //trim whitespace
   if(!*s) throw "unrecognized token";
   double value = 0, x = *s, y = *(s + 1);
@@ -133,21 +133,21 @@
   return value;
 }
 
-static bool eval(const char *s, double &result) {
+static bool eval(const char* s, double& result) {
   try {
     result = eval(s);
     return true;
-  } catch(const char*e) {
+  } catch(const char*) {
     result = 0;
     return false;
   }
 }
 
-static double parse(const char *s) {
+static double parse(const char* s) {
   try {
     double result = eval(s);
     return result;
-  } catch(const char *) {
+  } catch(const char*) {
     return 0;
   }
 }
diff -ru higan_v092r07\nall\string\platform.hpp higan_v092r08\nall\string\platform.hpp
--- higan_v092r07\nall\string\platform.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\platform.hpp	Thu May 02 05:48:02 2013
@@ -19,7 +19,7 @@
   return result;
 }
 
-string realpath(const string &name) {
+string realpath(const string& name) {
   string result;
   #if defined(PLATFORM_WINDOWS)
   wchar_t path[PATH_MAX] = L"";
diff -ru higan_v092r07\nall\string\replace.hpp higan_v092r08\nall\string\replace.hpp
--- higan_v092r07\nall\string\replace.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\replace.hpp	Thu May 02 05:48:02 2013
@@ -3,11 +3,11 @@
 namespace nall {
 
 template<unsigned Limit, bool Insensitive, bool Quoted>
-string& string::ureplace(const char *key, const char *token) {
+string& string::ureplace(const char* key, const char* token) {
   if(!key || !*key) return *this;
   enum : unsigned { limit = Limit ? Limit : ~0u };
 
-  const char *p = data;
+  const char* p = data;
   unsigned counter = 0, keyLength = 0;
 
   while(*p) {
@@ -20,13 +20,14 @@
   if(counter == 0) return *this;
   if(Limit) counter = min(counter, Limit);
 
-  char *t = data, *base;
+  char* t = data;
+  char* base;
   unsigned tokenLength = strlen(token);
   if(tokenLength > keyLength) {
     t = base = strdup(data);
     reserve((unsigned)(p - data) + ((tokenLength - keyLength) * counter));
   }
-  char *o = data;
+  char* o = data;
 
   while(*t && counter) {
     if(quotecopy<Quoted>(o, t)) continue;
@@ -41,10 +42,10 @@
   return *this;
 }
 
-template<unsigned Limit> string &string::replace(const char *key, const char *token) { return ureplace<Limit, false, false>(key, token); }
-template<unsigned Limit> string &string::ireplace(const char *key, const char *token) { return ureplace<Limit, true, false>(key, token); }
-template<unsigned Limit> string &string::qreplace(const char *key, const char *token) { return ureplace<Limit, false, true>(key, token); }
-template<unsigned Limit> string &string::iqreplace(const char *key, const char *token) { return ureplace<Limit, true, true>(key, token); }
+template<unsigned Limit> string& string::replace(const char* key, const char* token) { return ureplace<Limit, false, false>(key, token); }
+template<unsigned Limit> string& string::ireplace(const char* key, const char* token) { return ureplace<Limit, true, false>(key, token); }
+template<unsigned Limit> string& string::qreplace(const char* key, const char* token) { return ureplace<Limit, false, true>(key, token); }
+template<unsigned Limit> string& string::iqreplace(const char* key, const char* token) { return ureplace<Limit, true, true>(key, token); }
 
 };
 
diff -ru higan_v092r07\nall\string\split.hpp higan_v092r08\nall\string\split.hpp
--- higan_v092r07\nall\string\split.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\split.hpp	Thu May 02 05:48:02 2013
@@ -2,11 +2,11 @@
 
 namespace nall {
 
-template<unsigned Limit, bool Insensitive, bool Quoted> lstring& lstring::usplit(const char *key, const char *base) {
+template<unsigned Limit, bool Insensitive, bool Quoted> lstring& lstring::usplit(const char* key, const char* base) {
   reset();
   if(!key || !*key) return *this;
 
-  const char *p = base;
+  const char* p = base;
 
   while(*p) {
     if(Limit) if(size() >= Limit) break;
@@ -26,10 +26,10 @@
   return *this;
 }
 
-template<unsigned Limit> lstring& lstring::split(const char *key, const char *src) { return usplit<Limit, false, false>(key, src); }
-template<unsigned Limit> lstring& lstring::isplit(const char *key, const char *src) { return usplit<Limit, true, false>(key, src); }
-template<unsigned Limit> lstring& lstring::qsplit(const char *key, const char *src) { return usplit<Limit, false, true>(key, src); }
-template<unsigned Limit> lstring& lstring::iqsplit(const char *key, const char *src) { return usplit<Limit, true, true>(key, src); }
+template<unsigned Limit> lstring& lstring::split(const char* key, const char* src) { return usplit<Limit, false, false>(key, src); }
+template<unsigned Limit> lstring& lstring::isplit(const char* key, const char* src) { return usplit<Limit, true, false>(key, src); }
+template<unsigned Limit> lstring& lstring::qsplit(const char* key, const char* src) { return usplit<Limit, false, true>(key, src); }
+template<unsigned Limit> lstring& lstring::iqsplit(const char* key, const char* src) { return usplit<Limit, true, true>(key, src); }
 
 };
 
diff -ru higan_v092r07\nall\string\static.hpp higan_v092r08\nall\string\static.hpp
--- higan_v092r07\nall\string\static.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\static.hpp	Thu May 02 05:48:02 2013
@@ -2,7 +2,7 @@
 
 namespace nall {
 
-string string::read(const string &filename) {
+string string::read(const string& filename) {
   string data;
   data.readfile(filename);
   return data;
diff -ru higan_v092r07\nall\string\strm.hpp higan_v092r08\nall\string\strm.hpp
--- higan_v092r07\nall\string\strm.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\strm.hpp	Thu May 02 05:48:02 2013
@@ -2,13 +2,9 @@
 
 namespace nall {
 
-//
-//strmcpy, strmcat created by byuu
-//
-
 //return = strlen(target)
-unsigned strmcpy(char *target, const char *source, unsigned length) {
-  const char *origin = target;
+unsigned strmcpy(char* target, const char* source, unsigned length) {
+  const char* origin = target;
   if(length) {
     while(*source && --length) *target++ = *source++;
     *target = 0;
@@ -17,25 +13,25 @@
 }
 
 //return = strlen(target)
-unsigned strmcat(char *target, const char *source, unsigned length) {
-  const char *origin = target;
+unsigned strmcat(char* target, const char* source, unsigned length) {
+  const char* origin = target;
   while(*target && length) target++, length--;
   return (target - origin) + strmcpy(target, source, length);
 }
 
 //return = true when all of source was copied
-bool strccpy(char *target, const char *source, unsigned length) {
+bool strccpy(char* target, const char* source, unsigned length) {
   return !source[strmcpy(target, source, length)];
 }
 
 //return = true when all of source was copied
-bool strccat(char *target, const char *source, unsigned length) {
+bool strccat(char* target, const char* source, unsigned length) {
   while(*target && length) target++, length--;
   return !source[strmcpy(target, source, length)];
 }
 
 //return = reserved for future use
-void strpcpy(char *&target, const char *source, unsigned &length) {
+void strpcpy(char*& target, const char* source, unsigned& length) {
   unsigned offset = strmcpy(target, source, length);
   target += offset, length -= offset;
 }
diff -ru higan_v092r07\nall\string\strpos.hpp higan_v092r08\nall\string\strpos.hpp
--- higan_v092r07\nall\string\strpos.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\strpos.hpp	Thu May 02 05:48:02 2013
@@ -7,26 +7,26 @@
 namespace nall {
 
 template<bool Insensitive, bool Quoted>
-optional<unsigned> ustrpos(const char *str, const char *key) {
-  const char *base = str;
+optional<unsigned> ustrpos(const char* str, const char* key) {
+  const char* base = str;
 
   while(*str) {
     if(quoteskip<Quoted>(str)) continue;
     for(unsigned n = 0;; n++) {
-      if(key[n] == 0) return { true, (unsigned)(str - base) };
-      if(str[n] == 0) return { false, 0 };
+      if(key[n] == 0) return {true, (unsigned)(str - base)};
+      if(str[n] == 0) return false;
       if(!chrequal<Insensitive>(str[n], key[n])) break;
     }
     str++;
   }
 
-  return { false, 0 };
+  return false;
 }
 
-optional<unsigned> strpos(const char *str, const char *key) { return ustrpos<false, false>(str, key); }
-optional<unsigned> istrpos(const char *str, const char *key) { return ustrpos<true, false>(str, key); }
-optional<unsigned> qstrpos(const char *str, const char *key) { return ustrpos<false, true>(str, key); }
-optional<unsigned> iqstrpos(const char *str, const char *key) { return ustrpos<true, true>(str, key); }
+optional<unsigned> strpos(const char* str, const char* key) { return ustrpos<false, false>(str, key); }
+optional<unsigned> istrpos(const char* str, const char* key) { return ustrpos<true, false>(str, key); }
+optional<unsigned> qstrpos(const char* str, const char* key) { return ustrpos<false, true>(str, key); }
+optional<unsigned> iqstrpos(const char* str, const char* key) { return ustrpos<true, true>(str, key); }
 
 }
 
diff -ru higan_v092r07\nall\string\trim.hpp higan_v092r08\nall\string\trim.hpp
--- higan_v092r07\nall\string\trim.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\trim.hpp	Thu May 02 05:48:02 2013
@@ -3,11 +3,12 @@
 namespace nall {
 
 //limit defaults to zero, which will underflow on first compare; equivalent to no limit
-template<unsigned Limit> char* ltrim(char *str, const char *key) {
+template<unsigned Limit> char* ltrim(char* str, const char* key) {
   unsigned limit = Limit;
   if(!key || !*key) return str;
   while(strbegin(str, key)) {
-    char *dest = str, *src = str + strlen(key);
+    char* dest = str;
+    char* src = str + strlen(key);
     while(true) {
       *dest = *src++;
       if(!*dest) break;
@@ -18,7 +19,7 @@
   return str;
 }
 
-template<unsigned Limit> char* rtrim(char *str, const char *key) {
+template<unsigned Limit> char* rtrim(char* str, const char* key) {
   unsigned limit = Limit;
   if(!key || !*key) return str;
   while(strend(str, key)) {
@@ -28,13 +29,13 @@
   return str;
 }
 
-template<unsigned limit> char* trim(char *str, const char *key, const char *rkey) {
+template<unsigned limit> char* trim(char* str, const char* key, const char* rkey) {
   if(rkey) return ltrim<limit>(rtrim<limit>(str, rkey), key);
   return ltrim<limit>(rtrim<limit>(str, key), key);
 }
 
 //remove whitespace characters from both left and right sides of string
-char* strip(char *s) {
+char* strip(char* s) {
   signed n = 0, p = 0;
   while(s[n]) {
     if(s[n] != ' ' && s[n] != '\t' && s[n] != '\r' && s[n] != '\n') break;
diff -ru higan_v092r07\nall\string\utf8.hpp higan_v092r08\nall\string\utf8.hpp
--- higan_v092r07\nall\string\utf8.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\utf8.hpp	Thu May 02 05:48:02 2013
@@ -8,7 +8,7 @@
   unsigned codepoint;  //decoded codepoint
 };
 
-inline UTF8 utf8_read(const char *s) {
+inline UTF8 utf8_read(const char* s) {
   UTF8 utf8;
 
        if((*s & 0xfe) == 0xfc) utf8.size = 6;
@@ -32,7 +32,7 @@
   return utf8;
 }
 
-inline void utf8_write(char *s, const UTF8 &utf8) {
+inline void utf8_write(char* s, const UTF8& utf8) {
   for(signed n = utf8.size - 1, shift = 0; n >= 0; n--, shift += 8) {
     s[n] = utf8.data >> shift;
   }
diff -ru higan_v092r07\nall\string\utility.hpp higan_v092r08\nall\string\utility.hpp
--- higan_v092r07\nall\string\utility.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\utility.hpp	Thu May 02 05:48:02 2013
@@ -9,7 +9,7 @@
 }
 
 template<bool Quoted, typename T>
-bool quoteskip(T *&p) {
+bool quoteskip(T*& p) {
   if(Quoted == false) return false;
   if(*p != '\'' && *p != '\"') return false;
 
@@ -21,7 +21,7 @@
 }
 
 template<bool Quoted, typename T>
-bool quotecopy(char *&t, T *&p) {
+bool quotecopy(char*& t, T*& p) {
   if(Quoted == false) return false;
   if(*p != '\'' && *p != '\"') return false;
 
@@ -34,7 +34,7 @@
   return true;
 }
 
-string substr(const char *src, unsigned start, unsigned length) {
+string substr(const char* src, unsigned start, unsigned length) {
   string dest;
   if(length == ~0u) {
     //copy entire string
@@ -48,7 +48,7 @@
   return dest;
 }
 
-string sha256(const uint8_t *data, unsigned size) {
+string sha256(const uint8_t* data, unsigned size) {
   sha256_ctx sha;
   uint8_t hash[32];
   sha256_init(&sha);
@@ -62,7 +62,7 @@
 
 /* cast.hpp arithmetic -> string */
 
-char* integer(char *result, intmax_t value) {
+char* integer(char* result, intmax_t value) {
   bool negative = value < 0;
   if(negative) value = -value;
 
@@ -82,7 +82,7 @@
   return result;
 }
 
-char* decimal(char *result, uintmax_t value) {
+char* decimal(char* result, uintmax_t value) {
   char buffer[64];
   unsigned size = 0;
 
@@ -204,7 +204,7 @@
 //using sprintf is certainly not the most ideal method to convert
 //a double to a string ... but attempting to parse a double by
 //hand, digit-by-digit, results in subtle rounding errors.
-unsigned fp(char *str, long double value) {
+unsigned fp(char* str, long double value) {
   char buffer[256];
   #ifdef _WIN32
   //Windows C-runtime does not support long double via sprintf()
@@ -214,9 +214,9 @@
   #endif
 
   //remove excess 0's in fraction (2.500000 -> 2.5)
-  for(char *p = buffer; *p; p++) {
+  for(char* p = buffer; *p; p++) {
     if(*p == '.') {
-      char *p = buffer + strlen(buffer) - 1;
+      char* p = buffer + strlen(buffer) - 1;
       while(*p == '0') {
         if(*(p - 1) != '.') *p = 0;  //... but not for eg 1.0 -> 1.
         p--;
diff -ru higan_v092r07\nall\string\wildcard.hpp higan_v092r08\nall\string\wildcard.hpp
--- higan_v092r07\nall\string\wildcard.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\wildcard.hpp	Thu May 02 05:48:02 2013
@@ -2,8 +2,9 @@
 
 namespace nall {
 
-bool wildcard(const char *s, const char *p) {
-  const char *cp = nullptr, *mp = nullptr;
+bool wildcard(const char* s, const char* p) {
+  const char* cp = nullptr;
+  const char* mp = nullptr;
   while(*s && *p != '*') {
     if(*p != '?' && *s != *p) return false;
     p++, s++;
@@ -22,8 +23,9 @@
   return !*p;
 }
 
-bool iwildcard(const char *s, const char *p) {
-  const char *cp = nullptr, *mp = nullptr;
+bool iwildcard(const char* s, const char* p) {
+  const char* cp = nullptr;
+  const char* mp = nullptr;
   while(*s && *p != '*') {
     if(*p != '?' && chrlower(*s) != chrlower(*p)) return false;
     p++, s++;
@@ -42,7 +44,7 @@
   return !*p;
 }
 
-inline bool tokenize(const char *s, const char *p) {
+inline bool tokenize(const char* s, const char* p) {
   while(*s) {
     if(*p == '*') {
       while(*s) if(tokenize(s++, p + 1)) return true;
@@ -54,10 +56,10 @@
   return !*p;
 }
 
-inline bool tokenize(lstring &list, const char *s, const char *p) {
+inline bool tokenize(lstring &list, const char* s, const char* p) {
   while(*s) {
     if(*p == '*') {
-      const char *b = s;
+      const char* b = s;
       while(*s) {
         if(tokenize(list, s++, p + 1)) {
           list.prepend(substr(b, 0, --s - b));
diff -ru higan_v092r07\nall\string\wrapper.hpp higan_v092r08\nall\string\wrapper.hpp
--- higan_v092r07\nall\string\wrapper.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\string\wrapper.hpp	Thu May 02 05:48:02 2013
@@ -5,43 +5,43 @@
 unsigned string::length() const { return strlen(data); }
 unsigned string::capacity() const { return size; }
 
-template<unsigned limit> lstring string::split(const char *key) const { lstring result; result.split<limit>(key, data); return result; }
-template<unsigned limit> lstring string::isplit(const char *key) const { lstring result; result.isplit<limit>(key, data); return result; }
-template<unsigned limit> lstring string::qsplit(const char *key) const { lstring result; result.qsplit<limit>(key, data); return result; }
-template<unsigned limit> lstring string::iqsplit(const char *key) const { lstring result; result.iqsplit<limit>(key, data); return result; }
-
-bool string::equals(const char *str) const { return !strcmp(data, str); }
-bool string::iequals(const char *str) const { return !istrcmp(data, str); }
+template<unsigned limit> lstring string::split(const char* key) const { lstring result; result.split<limit>(key, data); return result; }
+template<unsigned limit> lstring string::isplit(const char* key) const { lstring result; result.isplit<limit>(key, data); return result; }
+template<unsigned limit> lstring string::qsplit(const char* key) const { lstring result; result.qsplit<limit>(key, data); return result; }
+template<unsigned limit> lstring string::iqsplit(const char* key) const { lstring result; result.iqsplit<limit>(key, data); return result; }
+
+bool string::equals(const char* str) const { return !strcmp(data, str); }
+bool string::iequals(const char* str) const { return !istrcmp(data, str); }
 
-bool string::wildcard(const char *str) const { return nall::wildcard(data, str); }
-bool string::iwildcard(const char *str) const { return nall::iwildcard(data, str); }
+bool string::wildcard(const char* str) const { return nall::wildcard(data, str); }
+bool string::iwildcard(const char* str) const { return nall::iwildcard(data, str); }
 
-bool string::beginswith(const char *str) const { return strbegin(data, str); }
-bool string::ibeginswith(const char *str) const { return istrbegin(data, str); }
+bool string::beginswith(const char* str) const { return strbegin(data, str); }
+bool string::ibeginswith(const char* str) const { return istrbegin(data, str); }
 
-bool string::endswith(const char *str) const { return strend(data, str); }
-bool string::iendswith(const char *str) const { return istrend(data, str); }
+bool string::endswith(const char* str) const { return strend(data, str); }
+bool string::iendswith(const char* str) const { return istrend(data, str); }
 
 string& string::lower() { nall::strlower(data); return *this; }
 string& string::upper() { nall::strupper(data); return *this; }
 string& string::qlower() { nall::qstrlower(data); return *this; }
 string& string::qupper() { nall::qstrupper(data); return *this; }
-string& string::transform(const char *before, const char *after) { nall::strtr(data, before, after); return *this; }
+string& string::transform(const char* before, const char* after) { nall::strtr(data, before, after); return *this; }
 string& string::reverse() {
   unsigned length = strlen(data), pivot = length >> 1;
   for(signed x = 0, y = length - 1; x < pivot && y >= 0; x++, y--) std::swap(data[x], data[y]);
   return *this;
 }
 
-template<unsigned limit> string& string::ltrim(const char *key) { nall::ltrim<limit>(data, key); return *this; }
-template<unsigned limit> string& string::rtrim(const char *key) { nall::rtrim<limit>(data, key); return *this; }
-template<unsigned limit> string& string::trim(const char *key, const char *rkey) { nall::trim <limit>(data, key, rkey); return *this; }
+template<unsigned limit> string& string::ltrim(const char* key) { nall::ltrim<limit>(data, key); return *this; }
+template<unsigned limit> string& string::rtrim(const char* key) { nall::rtrim<limit>(data, key); return *this; }
+template<unsigned limit> string& string::trim(const char* key, const char* rkey) { nall::trim <limit>(data, key, rkey); return *this; }
 string& string::strip() { nall::strip(data); return *this; }
 
-optional<unsigned> string::position(const char *key) const { return strpos(data, key); }
-optional<unsigned> string::iposition(const char *key) const { return istrpos(data, key); }
-optional<unsigned> string::qposition(const char *key) const { return qstrpos(data, key); }
-optional<unsigned> string::iqposition(const char *key) const { return iqstrpos(data, key); }
+optional<unsigned> string::position(const char* key) const { return strpos(data, key); }
+optional<unsigned> string::iposition(const char* key) const { return istrpos(data, key); }
+optional<unsigned> string::qposition(const char* key) const { return qstrpos(data, key); }
+optional<unsigned> string::iqposition(const char* key) const { return iqstrpos(data, key); }
 
 }
 
diff -ru higan_v092r07\nall\thread.hpp higan_v092r08\nall\thread.hpp
--- higan_v092r07\nall\thread.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\thread.hpp	Thu May 02 05:48:02 2013
@@ -9,114 +9,118 @@
   #include <pthread.h>
 
 namespace nall {
-  inline void* thread_entry_point(void*);
 
-  struct thread {
-    thread(function<void ()> entryPoint) : entryPoint(entryPoint), completed(false), dead(false) {
-      initialize();
-      pthread_create(&pthread, nullptr, thread_entry_point, (void*)this);
-    }
-
-    ~thread() {
-      join();
-    }
-
-    bool active() const {
-      return completed == false;
-    }
-
-    void join() {
-      if(dead) return;
-      dead = true;
-      pthread_join(pthread, nullptr);
-    }
-
-    static bool primary() {
-      initialize();
-      return pthread_equal(primaryThread(), pthread_self());
-    }
-
-  private:
-    pthread_t pthread;
-    function<void ()> entryPoint;
-    volatile bool completed, dead;
-    friend void* thread_entry_point(void*);
-
-    static void initialize() {
-      static bool initialized = false;
-      if(initialized) return;
-      initialized = true;
-      primaryThread() = pthread_self();
-    }
-
-    static pthread_t& primaryThread() {
-      static pthread_t thread;
-      return thread;
-    }
-  };
-
-  void* thread_entry_point(void *parameter) {
-    thread *context = (thread*)parameter;
-    context->entryPoint();
-    context->completed = true;
-    pthread_exit(nullptr);
+inline void* thread_entry_point(void*);
+
+struct thread {
+  thread(function<void ()> entryPoint) : entryPoint(entryPoint), completed(false), dead(false) {
+    initialize();
+    pthread_create(&pthread, nullptr, thread_entry_point, (void*)this);
+  }
+
+  ~thread() {
+    join();
+  }
+
+  bool active() const {
+    return completed == false;
+  }
+
+  void join() {
+    if(dead) return;
+    dead = true;
+    pthread_join(pthread, nullptr);
+  }
+
+  static bool primary() {
+    initialize();
+    return pthread_equal(primaryThread(), pthread_self());
+  }
+
+private:
+  pthread_t pthread;
+  function<void ()> entryPoint;
+  volatile bool completed, dead;
+  friend void* thread_entry_point(void*);
+
+  static void initialize() {
+    static bool initialized = false;
+    if(initialized) return;
+    initialized = true;
+    primaryThread() = pthread_self();
+  }
+
+  static pthread_t& primaryThread() {
+    static pthread_t thread;
+    return thread;
   }
+};
+
+void* thread_entry_point(void* parameter) {
+  thread* context = (thread*)parameter;
+  context->entryPoint();
+  context->completed = true;
+  pthread_exit(nullptr);
+}
+
 }
 #elif defined(PLATFORM_WIN)
 namespace nall {
-  inline DWORD WINAPI thread_entry_point(LPVOID);
 
-  struct thread {
-    thread(function<void ()> entryPoint) : entryPoint(entryPoint), completed(false), dead(false) {
-      initialize();
-      hthread = CreateThread(nullptr, 0, thread_entry_point, (void*)this, 0, nullptr);
-    }
-
-    ~thread() {
-      join();
-    }
-
-    bool active() const {
-      return completed == false;
-    }
-
-    void join() {
-      if(dead) return;
-      dead = true;
-      WaitForSingleObject(hthread, INFINITE);
-      CloseHandle(hthread);
-    }
-
-    static bool primary() {
-      initialize();
-      return primaryThread() == GetCurrentThreadId();
-    }
-
-  private:
-    HANDLE hthread;
-    function<void ()> entryPoint;
-    volatile bool completed, dead;
-    friend DWORD WINAPI thread_entry_point(LPVOID);
-
-    static void initialize() {
-      static bool initialized = false;
-      if(initialized) return;
-      initialized = true;
-      primaryThread() = GetCurrentThreadId();
-    }
-
-    static DWORD& primaryThread() {
-      static DWORD thread;
-      return thread;
-    }
-  };
-
-  inline DWORD WINAPI thread_entry_point(LPVOID parameter) {
-    thread *context = (thread*)parameter;
-    context->entryPoint();
-    context->completed = true;
-    return 0;
+inline DWORD WINAPI thread_entry_point(LPVOID);
+
+struct thread {
+  thread(function<void ()> entryPoint) : entryPoint(entryPoint), completed(false), dead(false) {
+    initialize();
+    hthread = CreateThread(nullptr, 0, thread_entry_point, (void*)this, 0, nullptr);
+  }
+
+  ~thread() {
+    join();
+  }
+
+  bool active() const {
+    return completed == false;
+  }
+
+  void join() {
+    if(dead) return;
+    dead = true;
+    WaitForSingleObject(hthread, INFINITE);
+    CloseHandle(hthread);
+  }
+
+  static bool primary() {
+    initialize();
+    return primaryThread() == GetCurrentThreadId();
+  }
+
+private:
+  HANDLE hthread;
+  function<void ()> entryPoint;
+  volatile bool completed, dead;
+  friend DWORD WINAPI thread_entry_point(LPVOID);
+
+  static void initialize() {
+    static bool initialized = false;
+    if(initialized) return;
+    initialized = true;
+    primaryThread() = GetCurrentThreadId();
+  }
+
+  static DWORD& primaryThread() {
+    static DWORD thread;
+    return thread;
   }
+};
+
+inline DWORD WINAPI thread_entry_point(LPVOID parameter) {
+  thread *context = (thread*)parameter;
+  context->entryPoint();
+  context->completed = true;
+  return 0;
+}
+
 }
 #endif
 
diff -ru higan_v092r07\nall\udl.hpp higan_v092r08\nall\udl.hpp
--- higan_v092r07\nall\udl.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\udl.hpp	Thu May 02 05:48:02 2013
@@ -7,22 +7,24 @@
 #include <type_traits>
 
 namespace nall {
-  constexpr inline uintmax_t operator"" _b(const char *n) { return binary(n); }
 
-  //convert to bytes
-  constexpr inline uintmax_t operator"" _kb(unsigned long long n) { return 1024 * n; }
-  constexpr inline uintmax_t operator"" _mb(unsigned long long n) { return 1024 * 1024 * n; }
-  constexpr inline uintmax_t operator"" _gb(unsigned long long n) { return 1024 * 1024 * 1024 * n; }
+constexpr inline uintmax_t operator"" _b(const char *n) { return binary(n); }
 
-  //convert to bits
-  constexpr inline uintmax_t operator"" _kbit(unsigned long long n) { return 1024 * n / 8; }
-  constexpr inline uintmax_t operator"" _mbit(unsigned long long n) { return 1024 * 1024 * n / 8; }
-  constexpr inline uintmax_t operator"" _gbit(unsigned long long n) { return 1024 * 1024 * 1024 * n / 8; }
+//convert to bytes
+constexpr inline uintmax_t operator"" _kb(unsigned long long n) { return 1024 * n; }
+constexpr inline uintmax_t operator"" _mb(unsigned long long n) { return 1024 * 1024 * n; }
+constexpr inline uintmax_t operator"" _gb(unsigned long long n) { return 1024 * 1024 * 1024 * n; }
+
+//convert to bits
+constexpr inline uintmax_t operator"" _kbit(unsigned long long n) { return 1024 * n / 8; }
+constexpr inline uintmax_t operator"" _mbit(unsigned long long n) { return 1024 * 1024 * n / 8; }
+constexpr inline uintmax_t operator"" _gbit(unsigned long long n) { return 1024 * 1024 * 1024 * n / 8; }
+
+//convert to hz
+constexpr inline uintmax_t operator"" _khz(long double n) { return n * 1000; }
+constexpr inline uintmax_t operator"" _mhz(long double n) { return n * 1000000; }
+constexpr inline uintmax_t operator"" _ghz(long double n) { return n * 1000000000; }
 
-  //convert to hz
-  constexpr inline uintmax_t operator"" _khz(long double n) { return n * 1000; }
-  constexpr inline uintmax_t operator"" _mhz(long double n) { return n * 1000000; }
-  constexpr inline uintmax_t operator"" _ghz(long double n) { return n * 1000000000; }
 }
 
 #endif
diff -ru higan_v092r07\nall\unzip.hpp higan_v092r08\nall\unzip.hpp
--- higan_v092r07\nall\unzip.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\unzip.hpp	Thu May 02 05:48:02 2013
@@ -11,14 +11,14 @@
 struct unzip {
   struct File {
     string name;
-    const uint8_t *data;
+    const uint8_t* data;
     unsigned size;
     unsigned csize;
     unsigned cmode;  //0 = uncompressed, 8 = deflate
     unsigned crc32;
   };
 
-  inline bool open(const string &filename) {
+  inline bool open(const string& filename) {
     close();
     if(fm.open(filename, filemap::mode::read) == false) return false;
     if(open(fm.data(), fm.size()) == false) {
@@ -28,7 +28,7 @@
     return true;
   }
 
-  inline bool open(const uint8_t *data, unsigned size) {
+  inline bool open(const uint8_t* data, unsigned size) {
     if(size < 22) return false;
 
     filedata = data;
@@ -36,7 +36,7 @@
 
     file.reset();
 
-    const uint8_t *footer = data + size - 22;
+    const uint8_t* footer = data + size - 22;
     while(true) {
       if(footer <= data + 22) return false;
       if(read(footer, 4) == 0x06054b50) {
@@ -45,7 +45,7 @@
       }
       footer--;
     }
-    const uint8_t *directory = data + read(footer + 16, 4);
+    const uint8_t* directory = data + read(footer + 16, 4);
 
     while(true) {
       unsigned signature = read(directory + 0, 4);
@@ -61,7 +61,7 @@
       unsigned extralength = read(directory + 30, 2);
       unsigned commentlength = read(directory + 32, 2);
 
-      char *filename = new char[namelength + 1];
+      char* filename = new char[namelength + 1];
       memcpy(filename, directory + 46, namelength);
       filename[namelength] = 0;
       file.name = filename;
@@ -80,7 +80,7 @@
     return true;
   }
 
-  inline vector<uint8_t> extract(File &file) {
+  inline vector<uint8_t> extract(File& file) {
     vector<uint8_t> buffer;
 
     if(file.cmode == 0) {
@@ -108,10 +108,10 @@
 
 protected:
   filemap fm;
-  const uint8_t *filedata;
+  const uint8_t* filedata;
   unsigned filesize;
 
-  unsigned read(const uint8_t *data, unsigned size) {
+  unsigned read(const uint8_t* data, unsigned size) {
     unsigned result = 0, shift = 0;
     while(size--) { result |= *data++ << shift; shift += 8; }
     return result;
diff -ru higan_v092r07\nall\ups.hpp higan_v092r08\nall\ups.hpp
--- higan_v092r07\nall\ups.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\ups.hpp	Thu May 02 05:48:02 2013
@@ -25,9 +25,9 @@
   function<void (unsigned offset, unsigned length)> progress;
 
   result create(
-    const uint8_t *sourcedata, unsigned sourcelength,
-    const uint8_t *targetdata, unsigned targetlength,
-    const char *patchfilename
+    const uint8_t* sourcedata, unsigned sourcelength,
+    const uint8_t* targetdata, unsigned targetlength,
+    const char* patchfilename
   ) {
     source_data = (uint8_t*)sourcedata, target_data = (uint8_t*)targetdata;
     source_length = sourcelength, target_length = targetlength;
@@ -85,9 +85,9 @@
   }
 
   result apply(
-    const uint8_t *patchdata, unsigned patchlength,
-    const uint8_t *sourcedata, unsigned sourcelength,
-    uint8_t *targetdata, unsigned &targetlength
+    const uint8_t* patchdata, unsigned patchlength,
+    const uint8_t* sourcedata, unsigned sourcelength,
+    uint8_t* targetdata, unsigned& targetlength
   ) {
     patch_data = (uint8_t*)patchdata, source_data = (uint8_t*)sourcedata, target_data = targetdata;
     patch_length = patchlength, source_length = sourcelength, target_length = targetlength;
@@ -141,7 +141,9 @@
   }
 
 private:
-  uint8_t *patch_data, *source_data, *target_data;
+  uint8_t* patch_data = nullptr;
+  uint8_t* source_data = nullptr;
+  uint8_t* target_data = nullptr;
   unsigned patch_length, source_length, target_length;
   unsigned patch_offset, source_offset, target_offset;
   unsigned patch_checksum, source_checksum, target_checksum;
diff -ru higan_v092r07\nall\utility.hpp higan_v092r08\nall\utility.hpp
--- higan_v092r07\nall\utility.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\utility.hpp	Thu May 02 05:48:02 2013
@@ -5,28 +5,106 @@
 #include <utility>
 
 namespace nall {
-  template<typename T> struct base_from_member {
-    T value;
-    base_from_member(T value_) : value(value_) {}
-  };
-
-  template<typename T> class optional {
-  public:
-    bool valid;
-    T value;
-  public:
-    inline operator bool() const { return valid; }
-    inline const T& operator()() const { if(!valid) throw; return value; }
-    inline optional<T>& operator=(const optional<T> &source) { valid = source.valid; value = source.value; return *this; }
-    inline optional() : valid(false) {}
-    inline optional(bool valid, const T &value) : valid(valid), value(value) {}
-  };
-
-  template<typename T> inline T* allocate(unsigned size, const T &value) {
-    T *array = new T[size];
-    for(unsigned i = 0; i < size; i++) array[i] = value;
-    return array;
+
+template<typename T> struct base_from_member {
+  T value;
+  base_from_member(T value) : value(value) {}
+};
+
+template<typename TT> struct optional {
+  typedef typename std::remove_reference<TT>::type T;
+  static const bool isConst = std::is_const<TT>::value;
+  static const bool isReference = std::is_reference<TT>::value;
+  struct optional_value_not_valid{};
+
+  bool valid = false;
+  T* value = nullptr;
+
+  operator bool() const { return valid; }
+
+  void reset() {
+    valid = false;
+    if(value) {
+      if(!isReference) delete value;
+      value = nullptr;
+    }
+  }
+
+  template<typename = typename std::enable_if<!isConst>::type>
+  T& operator()() {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  const T& operator()() const {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  const T& operator()(const T& alternate) const {
+    if(!valid) return alternate;
+    return *value;
+  }
+
+  const bool operator==(const optional& source) const {
+    if(valid && source.valid) return *value == *source.value;
+    if(!valid && !source.valid) return true;
+    return false;
   }
+
+  const bool operator!=(const optional& source) const {
+    return !operator==(source);
+  }
+
+  optional& operator=(const T& source) {
+    reset();
+    valid = true;
+    if(isReference) value = (T*)&source;
+    else value = new T(source);
+    return *this;
+  }
+
+  optional& operator=(T&& source) {
+    reset();
+    valid = true;
+    if(isReference) value = &source;
+    else value = new T(std::move(source));
+    return *this;
+  }
+
+  optional& operator=(const optional& source) {
+    reset();
+    valid = source.valid;
+    if(valid) operator=(source);
+    return *this;
+  }
+
+  optional& operator=(optional&& source) {
+    reset();
+    valid = source.valid;
+    value = source.value;
+    source.valid = false;
+    source.value = nullptr;
+    return *this;
+  }
+
+  optional() = default;
+  optional(bool valid) : valid(valid) {}
+  optional(const T& value) { operator=(value); }
+  optional(T&& value) { operator=(std::move(value)); }
+  optional(bool valid, const T& value) : valid(valid) { if(valid) operator=(value); }
+  optional(bool valid, T&& value) : valid(valid) { if(valid) operator=(std::move(value)); }
+  optional(const optional& source) { operator=(source); }
+  optional(optional&& source) { operator=(std::move(source)); }
+  ~optional() { reset(); }
+};
+
+template<typename T> inline T* allocate(unsigned size, const T& value) {
+  T* array = new T[size];
+  for(unsigned i = 0; i < size; i++) array[i] = value;
+  return array;
+}
+
 }
 
 #endif
diff -ru higan_v092r07\nall\varint.hpp higan_v092r08\nall\varint.hpp
--- higan_v092r07\nall\varint.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\varint.hpp	Thu May 02 05:48:02 2013
@@ -5,93 +5,95 @@
 #include <nall/traits.hpp>
 
 namespace nall {
-  template<unsigned bits> struct uint_t {
-  private:
-    typedef typename type_if<bits <= 8 * sizeof(unsigned), unsigned, uintmax_t>::type type_t;
-    type_t data;
-
-  public:
-    inline operator type_t() const { return data; }
-    inline type_t operator ++(int) { type_t r = data; data = uclip<bits>(data + 1); return r; }
-    inline type_t operator --(int) { type_t r = data; data = uclip<bits>(data - 1); return r; }
-    inline type_t operator ++() { return data = uclip<bits>(data + 1); }
-    inline type_t operator --() { return data = uclip<bits>(data - 1); }
-    inline type_t operator  =(const type_t i) { return data = uclip<bits>(i); }
-    inline type_t operator |=(const type_t i) { return data = uclip<bits>(data  | i); }
-    inline type_t operator ^=(const type_t i) { return data = uclip<bits>(data  ^ i); }
-    inline type_t operator &=(const type_t i) { return data = uclip<bits>(data  & i); }
-    inline type_t operator<<=(const type_t i) { return data = uclip<bits>(data << i); }
-    inline type_t operator>>=(const type_t i) { return data = uclip<bits>(data >> i); }
-    inline type_t operator +=(const type_t i) { return data = uclip<bits>(data  + i); }
-    inline type_t operator -=(const type_t i) { return data = uclip<bits>(data  - i); }
-    inline type_t operator *=(const type_t i) { return data = uclip<bits>(data  * i); }
-    inline type_t operator /=(const type_t i) { return data = uclip<bits>(data  / i); }
-    inline type_t operator %=(const type_t i) { return data = uclip<bits>(data  % i); }
-
-    inline uint_t() : data(0) {}
-    inline uint_t(const type_t i) : data(uclip<bits>(i)) {}
-
-    template<unsigned s> inline type_t operator=(const uint_t<s> &i) { return data = uclip<bits>((type_t)i); }
-    template<unsigned s> inline uint_t(const uint_t<s> &i) : data(uclip<bits>(i)) {}
-  };
-
-  template<unsigned bits> struct int_t {
-  private:
-    typedef typename type_if<bits <= 8 * sizeof(signed), signed, intmax_t>::type type_t;
-    type_t data;
-
-  public:
-    inline operator type_t() const { return data; }
-    inline type_t operator ++(int) { type_t r = data; data = sclip<bits>(data + 1); return r; }
-    inline type_t operator --(int) { type_t r = data; data = sclip<bits>(data - 1); return r; }
-    inline type_t operator ++() { return data = sclip<bits>(data + 1); }
-    inline type_t operator --() { return data = sclip<bits>(data - 1); }
-    inline type_t operator  =(const type_t i) { return data = sclip<bits>(i); }
-    inline type_t operator |=(const type_t i) { return data = sclip<bits>(data  | i); }
-    inline type_t operator ^=(const type_t i) { return data = sclip<bits>(data  ^ i); }
-    inline type_t operator &=(const type_t i) { return data = sclip<bits>(data  & i); }
-    inline type_t operator<<=(const type_t i) { return data = sclip<bits>(data << i); }
-    inline type_t operator>>=(const type_t i) { return data = sclip<bits>(data >> i); }
-    inline type_t operator +=(const type_t i) { return data = sclip<bits>(data  + i); }
-    inline type_t operator -=(const type_t i) { return data = sclip<bits>(data  - i); }
-    inline type_t operator *=(const type_t i) { return data = sclip<bits>(data  * i); }
-    inline type_t operator /=(const type_t i) { return data = sclip<bits>(data  / i); }
-    inline type_t operator %=(const type_t i) { return data = sclip<bits>(data  % i); }
-
-    inline int_t() : data(0) {}
-    inline int_t(const type_t i) : data(sclip<bits>(i)) {}
-
-    template<unsigned s> inline type_t operator=(const int_t<s> &i) { return data = sclip<bits>((type_t)i); }
-    template<unsigned s> inline int_t(const int_t<s> &i) : data(sclip<bits>(i)) {}
-  };
-
-  template<typename type_t> struct varuint_t {
-  private:
-    type_t data;
-    type_t mask;
-
-  public:
-    inline operator type_t() const { return data; }
-    inline type_t operator ++(int) { type_t r = data; data = (data + 1) & mask; return r; }
-    inline type_t operator --(int) { type_t r = data; data = (data - 1) & mask; return r; }
-    inline type_t operator ++() { return data = (data + 1) & mask; }
-    inline type_t operator --() { return data = (data - 1) & mask; }
-    inline type_t operator  =(const type_t i) { return data = (i) & mask; }
-    inline type_t operator |=(const type_t i) { return data = (data  | i) & mask; }
-    inline type_t operator ^=(const type_t i) { return data = (data  ^ i) & mask; }
-    inline type_t operator &=(const type_t i) { return data = (data  & i) & mask; }
-    inline type_t operator<<=(const type_t i) { return data = (data << i) & mask; }
-    inline type_t operator>>=(const type_t i) { return data = (data >> i) & mask; }
-    inline type_t operator +=(const type_t i) { return data = (data  + i) & mask; }
-    inline type_t operator -=(const type_t i) { return data = (data  - i) & mask; }
-    inline type_t operator *=(const type_t i) { return data = (data  * i) & mask; }
-    inline type_t operator /=(const type_t i) { return data = (data  / i) & mask; }
-    inline type_t operator %=(const type_t i) { return data = (data  % i) & mask; }
-
-    inline void bits(type_t bits) { mask = (1ull << (bits - 1)) + ((1ull << (bits - 1)) - 1); data &= mask; }
-    inline varuint_t() : data(0ull), mask((type_t)~0ull) {}
-    inline varuint_t(const type_t i) : data(i), mask((type_t)~0ull) {}
-  };
+
+template<unsigned bits> struct uint_t {
+private:
+  typedef typename type_if<bits <= 8 * sizeof(unsigned), unsigned, uintmax_t>::type type_t;
+  type_t data;
+
+public:
+  inline operator type_t() const { return data; }
+  inline type_t operator ++(int) { type_t r = data; data = uclip<bits>(data + 1); return r; }
+  inline type_t operator --(int) { type_t r = data; data = uclip<bits>(data - 1); return r; }
+  inline type_t operator ++() { return data = uclip<bits>(data + 1); }
+  inline type_t operator --() { return data = uclip<bits>(data - 1); }
+  inline type_t operator  =(const type_t i) { return data = uclip<bits>(i); }
+  inline type_t operator |=(const type_t i) { return data = uclip<bits>(data  | i); }
+  inline type_t operator ^=(const type_t i) { return data = uclip<bits>(data  ^ i); }
+  inline type_t operator &=(const type_t i) { return data = uclip<bits>(data  & i); }
+  inline type_t operator<<=(const type_t i) { return data = uclip<bits>(data << i); }
+  inline type_t operator>>=(const type_t i) { return data = uclip<bits>(data >> i); }
+  inline type_t operator +=(const type_t i) { return data = uclip<bits>(data  + i); }
+  inline type_t operator -=(const type_t i) { return data = uclip<bits>(data  - i); }
+  inline type_t operator *=(const type_t i) { return data = uclip<bits>(data  * i); }
+  inline type_t operator /=(const type_t i) { return data = uclip<bits>(data  / i); }
+  inline type_t operator %=(const type_t i) { return data = uclip<bits>(data  % i); }
+
+  inline uint_t() : data(0) {}
+  inline uint_t(const type_t i) : data(uclip<bits>(i)) {}
+
+  template<unsigned s> inline type_t operator=(const uint_t<s> &i) { return data = uclip<bits>((type_t)i); }
+  template<unsigned s> inline uint_t(const uint_t<s> &i) : data(uclip<bits>(i)) {}
+};
+
+template<unsigned bits> struct int_t {
+private:
+  typedef typename type_if<bits <= 8 * sizeof(signed), signed, intmax_t>::type type_t;
+  type_t data;
+
+public:
+  inline operator type_t() const { return data; }
+  inline type_t operator ++(int) { type_t r = data; data = sclip<bits>(data + 1); return r; }
+  inline type_t operator --(int) { type_t r = data; data = sclip<bits>(data - 1); return r; }
+  inline type_t operator ++() { return data = sclip<bits>(data + 1); }
+  inline type_t operator --() { return data = sclip<bits>(data - 1); }
+  inline type_t operator  =(const type_t i) { return data = sclip<bits>(i); }
+  inline type_t operator |=(const type_t i) { return data = sclip<bits>(data  | i); }
+  inline type_t operator ^=(const type_t i) { return data = sclip<bits>(data  ^ i); }
+  inline type_t operator &=(const type_t i) { return data = sclip<bits>(data  & i); }
+  inline type_t operator<<=(const type_t i) { return data = sclip<bits>(data << i); }
+  inline type_t operator>>=(const type_t i) { return data = sclip<bits>(data >> i); }
+  inline type_t operator +=(const type_t i) { return data = sclip<bits>(data  + i); }
+  inline type_t operator -=(const type_t i) { return data = sclip<bits>(data  - i); }
+  inline type_t operator *=(const type_t i) { return data = sclip<bits>(data  * i); }
+  inline type_t operator /=(const type_t i) { return data = sclip<bits>(data  / i); }
+  inline type_t operator %=(const type_t i) { return data = sclip<bits>(data  % i); }
+
+  inline int_t() : data(0) {}
+  inline int_t(const type_t i) : data(sclip<bits>(i)) {}
+
+  template<unsigned s> inline type_t operator=(const int_t<s> &i) { return data = sclip<bits>((type_t)i); }
+  template<unsigned s> inline int_t(const int_t<s> &i) : data(sclip<bits>(i)) {}
+};
+
+template<typename type_t> struct varuint_t {
+private:
+  type_t data;
+  type_t mask;
+
+public:
+  inline operator type_t() const { return data; }
+  inline type_t operator ++(int) { type_t r = data; data = (data + 1) & mask; return r; }
+  inline type_t operator --(int) { type_t r = data; data = (data - 1) & mask; return r; }
+  inline type_t operator ++() { return data = (data + 1) & mask; }
+  inline type_t operator --() { return data = (data - 1) & mask; }
+  inline type_t operator  =(const type_t i) { return data = (i) & mask; }
+  inline type_t operator |=(const type_t i) { return data = (data  | i) & mask; }
+  inline type_t operator ^=(const type_t i) { return data = (data  ^ i) & mask; }
+  inline type_t operator &=(const type_t i) { return data = (data  & i) & mask; }
+  inline type_t operator<<=(const type_t i) { return data = (data << i) & mask; }
+  inline type_t operator>>=(const type_t i) { return data = (data >> i) & mask; }
+  inline type_t operator +=(const type_t i) { return data = (data  + i) & mask; }
+  inline type_t operator -=(const type_t i) { return data = (data  - i) & mask; }
+  inline type_t operator *=(const type_t i) { return data = (data  * i) & mask; }
+  inline type_t operator /=(const type_t i) { return data = (data  / i) & mask; }
+  inline type_t operator %=(const type_t i) { return data = (data  % i) & mask; }
+
+  inline void bits(type_t bits) { mask = (1ull << (bits - 1)) + ((1ull << (bits - 1)) - 1); data &= mask; }
+  inline varuint_t() : data(0ull), mask((type_t)~0ull) {}
+  inline varuint_t(const type_t i) : data(i), mask((type_t)~0ull) {}
+};
+
 }
 
 //typedefs
diff -ru higan_v092r07\nall\vector.hpp higan_v092r08\nall\vector.hpp
--- higan_v092r07\nall\vector.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\vector.hpp	Thu May 02 05:48:02 2013
@@ -4,7 +4,6 @@
 #include <algorithm>
 #include <initializer_list>
 #include <new>
-#include <type_traits>
 #include <utility>
 #include <nall/algorithm.hpp>
 #include <nall/bit.hpp>
@@ -12,195 +11,257 @@
 #include <nall/utility.hpp>
 
 namespace nall {
-  template<typename T> struct vector {
-    struct exception_out_of_bounds{};
 
-  protected:
-    T *pool;
-    unsigned poolsize;
-    unsigned objectsize;
-
-  public:
-    explicit operator bool() const { return pool; }
-    T* data() { return pool; }
-    const T* data() const { return pool; }
-
-    bool empty() const { return objectsize == 0; }
-    unsigned size() const { return objectsize; }
-    unsigned capacity() const { return poolsize; }
-
-    T* move() {
-      T *result = pool;
-      pool = nullptr;
-      poolsize = 0;
-      objectsize = 0;
-      return result;
-    }
-
-    void reset() {
-      if(pool) {
-        for(unsigned n = 0; n < objectsize; n++) pool[n].~T();
-        free(pool);
-      }
-      pool = nullptr;
-      poolsize = 0;
-      objectsize = 0;
-    }
+template<typename T> struct vector {
+  struct exception_out_of_bounds{};
 
-    void reserve(unsigned size) {
-      unsigned outputsize = min(size, objectsize);
-      size = bit::round(size);  //amortize growth
-      T *copy = (T*)calloc(size, sizeof(T));
-      for(unsigned n = 0; n < outputsize; n++) new(copy + n) T(pool[n]);
-      for(unsigned n = 0; n < objectsize; n++) pool[n].~T();
+protected:
+  T* pool = nullptr;
+  unsigned poolbase = 0;
+  unsigned poolsize = 0;
+  unsigned objectsize = 0;
+
+public:
+  explicit operator bool() const { return pool; }
+  T* data() { return pool + poolbase; }
+  const T* data() const { return pool + poolbase; }
+
+  bool empty() const { return objectsize == 0; }
+  unsigned size() const { return objectsize; }
+  unsigned capacity() const { return poolsize; }
+
+  T* move() {
+    T* result = pool + poolbase;
+    pool = nullptr;
+    poolbase = 0;
+    poolsize = 0;
+    objectsize = 0;
+    return result;
+  }
+
+  void reset() {
+    if(pool) {
+      for(unsigned n = 0; n < objectsize; n++) pool[poolbase + n].~T();
       free(pool);
-      pool = copy;
-      poolsize = size;
-      objectsize = outputsize;
     }
-
-    //requires trivial constructor
-    void resize(unsigned size) {
-      if(size == objectsize) return;
-      if(size < objectsize) return reserve(size);
-      while(size > objectsize) append(T());
-    }
-
-    template<typename... Args>
-    void append(const T& data, Args&&... args) {
-      append(data);
-      append(std::forward<Args>(args)...);
-    }
-
-    void append(const T& data) {
-      if(objectsize + 1 > poolsize) reserve(objectsize + 1);
-      new(pool + objectsize++) T(data);
-    }
-
-    bool appendonce(const T& data) {
-      if(find(data) == true) return false;
-      append(data);
-      return true;
-    }
-
-    void insert(unsigned position, const T& data) {
-      append(data);
-      for(signed n = size() - 1; n > position; n--) pool[n] = pool[n - 1];
-      pool[position] = data;
-    }
-
-    void prepend(const T& data) {
-      insert(0, data);
-    }
-
-    void remove(unsigned index = ~0u, unsigned count = 1) {
-      if(index == ~0) index = objectsize ? objectsize - 1 : 0;
-      for(unsigned n = index; count + n < objectsize; n++) pool[n] = pool[count + n];
-      objectsize = (count + index >= objectsize) ? index : objectsize - count;
-    }
-
-    T take(unsigned index = ~0u) {
-      if(index == ~0) index = objectsize ? objectsize - 1 : 0;
-      if(index >= objectsize) throw exception_out_of_bounds();
-      T item = pool[index];
-      remove(index);
-      return item;
-    }
-
-    void reverse() {
-      unsigned pivot = size() / 2;
-      for(unsigned l = 0, r = size() - 1; l < pivot; l++, r--) {
-        std::swap(pool[l], pool[r]);
+    pool = nullptr;
+    poolbase = 0;
+    poolsize = 0;
+    objectsize = 0;
+  }
+
+  void reserve(unsigned size) {
+    if(size <= poolsize) return;
+    size = bit::round(size);  //amortize growth
+
+    T* copy = (T*)calloc(size, sizeof(T));
+    for(unsigned n = 0; n < objectsize; n++) new(copy + n) T(std::move(pool[poolbase + n]));
+    free(pool);
+    pool = copy;
+    poolbase = 0;
+    poolsize = size;
+  }
+
+  void resize(unsigned size) {
+    T* copy = (T*)calloc(size, sizeof(T));
+    for(unsigned n = 0; n < size && n < objectsize; n++) new(copy + n) T(std::move(pool[poolbase + n]));
+    reset();
+    pool = copy;
+    poolbase = 0;
+    poolsize = size;
+    objectsize = size;
+  }
+
+  template<typename... Args> void prepend(const T& data, Args&&... args) {
+    prepend(std::forward<Args>(args)...);
+    prepend(data);
+  }
+
+  void prepend(const T& data) {
+    reserve(objectsize + 1);
+    if(poolbase == 0) {
+      unsigned available = poolsize - objectsize;
+      poolbase = max(1u, available >> 1);
+      for(signed n = objectsize - 1; n >= 0; n--) {
+        pool[poolbase + n] = std::move(pool[n]);
       }
     }
-
-    void sort() {
-      nall::sort(pool, objectsize);
-    }
-
-    template<typename Comparator> void sort(const Comparator &lessthan) {
-      nall::sort(pool, objectsize, lessthan);
-    }
-
-    optional<unsigned> find(const T& data) {
-      for(unsigned n = 0; n < size(); n++) if(pool[n] == data) return {true, n};
-      return {false, 0u};
-    }
-
-    T& first() {
-      if(objectsize == 0) throw exception_out_of_bounds();
-      return pool[0];
-    }
-
-    T& last() {
-      if(objectsize == 0) throw exception_out_of_bounds();
-      return pool[objectsize - 1];
-    }
-
-    //access
-    inline T& operator[](unsigned position) {
-      if(position >= objectsize) throw exception_out_of_bounds();
-      return pool[position];
-    }
-
-    inline const T& operator[](unsigned position) const {
-      if(position >= objectsize) throw exception_out_of_bounds();
-      return pool[position];
-    }
-
-    inline T& operator()(unsigned position) {
-      if(position >= poolsize) reserve(position + 1);
-      while(position >= objectsize) append(T());
-      return pool[position];
-    }
-
-    inline const T& operator()(unsigned position, const T& data) const {
-      if(position >= objectsize) return data;
-      return pool[position];
-    }
-
-    //iteration
-    T* begin() { return &pool[0]; }
-    T* end() { return &pool[objectsize]; }
-    const T* begin() const { return &pool[0]; }
-    const T* end() const { return &pool[objectsize]; }
-
-    //copy
-    inline vector& operator=(const vector &source) {
-      reset();
-      reserve(source.capacity());
-      for(auto &data : source) append(data);
-      return *this;
+    new(pool + --poolbase) T(data);
+    objectsize++;
+  }
+
+  template<typename... Args> void append(const T& data, Args&&... args) {
+    append(data);
+    append(std::forward<Args>(args)...);
+  }
+
+  void append(const T& data) {
+    reserve(poolbase + objectsize + 1);
+    new(pool + poolbase + objectsize++) T(data);
+  }
+
+  bool appendonce(const T& data) {
+    if(find(data)) return false;
+    return append(data), true;
+  }
+
+  void insert(unsigned position, const T& data) {
+    if(position == 0) return prepend(data);
+    append(data);
+    if(position == ~0u) return;
+    for(signed n = objectsize - 1; n > position; n--) {
+      pool[poolbase + n] = std::move(pool[poolbase + n - 1]);
+    }
+    pool[poolbase + position] = data;
+  }
+
+  void remove(unsigned position = ~0u, unsigned length = 1) {
+    if(position == ~0u) position = objectsize - 1;
+    if(position + length > objectsize) throw exception_out_of_bounds{};
+
+    if(position == 0) {
+      for(unsigned n = 0; n < length; n++) pool[poolbase + n].~T();
+      poolbase += length;
+    } else {
+      for(unsigned n = position; n < objectsize; n++) {
+        if(n + length < objectsize) {
+          pool[poolbase + n] = std::move(pool[poolbase + n + length]);
+        } else {
+          pool[poolbase + n].~T();
+        }
+      }
     }
+    objectsize -= length;
+  }
 
-    vector(const vector &source) : pool(nullptr), poolsize(0), objectsize(0) {
-      operator=(source);
-    }
+  T take(unsigned position = ~0u) {
+    if(position == ~0u) position = objectsize - 1;
+    T object = pool[poolbase + position];
+    remove(position);
+    return object;
+  }
+
+  void reverse() {
+    unsigned pivot = size() / 2;
+    for(unsigned l = 0, r = size() - 1; l < pivot; l++, r--) {
+      std::swap(pool[poolbase + l], pool[poolbase + r]);
+    }
+  }
+
+  void sort() {
+    nall::sort(pool + poolbase, objectsize);
+  }
+
+  template<typename Comparator> void sort(const Comparator &lessthan) {
+    nall::sort(pool + poolbase, objectsize, lessthan);
+  }
+
+  optional<unsigned> find(const T& data) {
+    for(unsigned n = 0; n < objectsize; n++) if(pool[poolbase + n] == data) return {true, n};
+    return false;
+  }
+
+  T& first() {
+    if(objectsize == 0) throw exception_out_of_bounds();
+    return pool[poolbase];
+  }
+
+  const T& first() const {
+    if(objectsize == 0) throw exception_out_of_bounds();
+    return pool[poolbase];
+  }
+
+  T& last() {
+    if(objectsize == 0) throw exception_out_of_bounds();
+    return pool[poolbase + objectsize - 1];
+  }
+
+  const T& last() const {
+    if(objectsize == 0) throw exception_out_of_bounds();
+    return pool[poolbase + objectsize - 1];
+  }
+
+  //access
+  inline T& operator[](unsigned position) {
+    if(position >= objectsize) throw exception_out_of_bounds();
+    return pool[poolbase + position];
+  }
+
+  inline const T& operator[](unsigned position) const {
+    if(position >= objectsize) throw exception_out_of_bounds();
+    return pool[poolbase + position];
+  }
+
+  inline T& operator()(unsigned position) {
+    if(position >= poolsize) reserve(position + 1);
+    while(position >= objectsize) append(T());
+    return pool[poolbase + position];
+  }
+
+  inline const T& operator()(unsigned position, const T& data) const {
+    if(position >= objectsize) return data;
+    return pool[poolbase + position];
+  }
+
+  //iteration
+  struct iterator {
+    T& operator*() { return source.operator[](position); }
+    bool operator!=(const iterator& source) const { return position != source.position; }
+    iterator& operator++() { position++; return *this; }
+    iterator(vector& source, unsigned position) : source(source), position(position) {}
+
+  private:
+    vector& source;
+    unsigned position;
+  };
 
-    //move
-    inline vector& operator=(vector &&source) {
-      reset();
-      pool = source.pool, poolsize = source.poolsize, objectsize = source.objectsize;
-      source.pool = nullptr, source.poolsize = 0, source.objectsize = 0;
-      return *this;
-    }
+  iterator begin() { return iterator(*this, 0); }
+  iterator end() { return iterator(*this, size()); }
 
-    vector(vector &&source) : pool(nullptr), poolsize(0), objectsize(0) {
-      operator=(std::move(source));
-    }
+  struct const_iterator {
+    const T& operator*() const { return source.operator[](position); }
+    bool operator!=(const const_iterator& source) const { return position != source.position; }
+    const_iterator& operator++() { position++; return *this; }
+    const_iterator(const vector& source, unsigned position) : source(source), position(position) {}
+
+  private:
+    const vector& source;
+    unsigned position;
+  };
 
-    //construction
-    vector() : pool(nullptr), poolsize(0), objectsize(0) {
-    }
+  const const_iterator begin() const { return const_iterator(*this, 0); }
+  const const_iterator end() const { return const_iterator(*this, size()); }
 
-    vector(std::initializer_list<T> list) : pool(nullptr), poolsize(0), objectsize(0) {
-      for(auto &data : list) append(data);
-    }
+  //copy
+  inline vector& operator=(const vector& source) {
+    reset();
+    reserve(source.size());
+    for(auto& data : source) append(data);
+    return *this;
+  }
+
+  //move
+  inline vector& operator=(vector&& source) {
+    reset();
+    pool = source.pool;
+    poolbase = source.poolbase;
+    poolsize = source.poolsize;
+    objectsize = source.objectsize;
+    source.pool = nullptr;
+    source.poolbase = 0;
+    source.poolsize = 0;
+    source.objectsize = 0;
+    return *this;
+  }
+
+  //construction and destruction
+  vector() = default;
+  vector(std::initializer_list<T> list) { for(auto& data : list) append(data); }
+  vector(const vector& source) { operator=(source); }
+  vector(vector&& source) { operator=(std::move(source)); }
+  ~vector() { reset(); }
+};
 
-    ~vector() {
-      reset();
-    }
-  };
 }
 
 #endif
diff -ru higan_v092r07\nall\windows\detour.hpp higan_v092r08\nall\windows\detour.hpp
--- higan_v092r07\nall\windows\detour.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\windows\detour.hpp	Thu May 02 05:48:02 2013
@@ -13,12 +13,12 @@
 #define RelNear 1
 
 struct detour {
-  static bool insert(const string &moduleName, const string &functionName, void *&source, void *target);
-  static bool remove(const string &moduleName, const string &functionName, void *&source);
+  static bool insert(const string& moduleName, const string& functionName, void*& source, void* target);
+  static bool remove(const string& moduleName, const string& functionName, void*& source);
 
 protected:
-  static unsigned length(const uint8_t *function);
-  static unsigned mirror(uint8_t *target, const uint8_t *source);
+  static unsigned length(const uint8_t* function);
+  static unsigned mirror(uint8_t* target, const uint8_t* source);
 
   struct opcode {
     uint16_t prefix;
@@ -62,11 +62,11 @@
   { 0xeb, 2, RelNear,   0xe9 },  //jmp near     -> jmp far
 };
 
-bool detour::insert(const string &moduleName, const string &functionName, void *&source, void *target) {
+bool detour::insert(const string& moduleName, const string& functionName, void*& source, void* target) {
   HMODULE module = GetModuleHandleW(utf16_t(moduleName));
   if(!module) return false;
 
-  uint8_t *sourceData = (uint8_t*)GetProcAddress(module, functionName);
+  uint8_t* sourceData = (uint8_t*)GetProcAddress(module, functionName);
   if(!sourceData) return false;
 
   unsigned sourceLength = detour::length(sourceData);
@@ -81,7 +81,7 @@
     return false;
   }
 
-  uint8_t *mirrorData = new uint8_t[512]();
+  uint8_t* mirrorData = new uint8_t[512]();
   detour::mirror(mirrorData, sourceData);
 
   DWORD privileges;
@@ -99,14 +99,14 @@
   return true;
 }
 
-bool detour::remove(const string &moduleName, const string &functionName, void *&source) {
+bool detour::remove(const string& moduleName, const string& functionName, void*& source) {
   HMODULE module = GetModuleHandleW(utf16_t(moduleName));
   if(!module) return false;
 
-  uint8_t *sourceData = (uint8_t*)GetProcAddress(module, functionName);
+  uint8_t* sourceData = (uint8_t*)GetProcAddress(module, functionName);
   if(!sourceData) return false;
 
-  uint8_t *mirrorData = (uint8_t*)source;
+  uint8_t* mirrorData = (uint8_t*)source;
   if(mirrorData == sourceData) return false;  //hook was never installed
 
   unsigned length = detour::length(256 + mirrorData);
@@ -122,7 +122,7 @@
   return true;
 }
 
-unsigned detour::length(const uint8_t *function) {
+unsigned detour::length(const uint8_t* function) {
   unsigned length = 0;
   while(length < 5) {
     detour::opcode *opcode = 0;
@@ -138,7 +138,7 @@
   return length;
 }
 
-unsigned detour::mirror(uint8_t *target, const uint8_t *source) {
+unsigned detour::mirror(uint8_t* target, const uint8_t* source) {
   const uint8_t *entryPoint = source;
   for(unsigned n = 0; n < 256; n++) target[256 + n] = source[n];
 
diff -ru higan_v092r07\nall\windows\launcher.hpp higan_v092r08\nall\windows\launcher.hpp
--- higan_v092r07\nall\windows\launcher.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\windows\launcher.hpp	Thu May 02 05:48:02 2013
@@ -5,7 +5,7 @@
 
 //launch a new process and inject specified DLL into it
 
-bool launch(const char *applicationName, const char *libraryName, uint32_t entryPoint) {
+bool launch(const char* applicationName, const char* libraryName, uint32_t entryPoint) {
   //if a launcher does not send at least one message, a wait cursor will appear
   PostThreadMessage(GetCurrentThreadId(), WM_USER, 0, 0);
   MSG msg;
diff -ru higan_v092r07\nall\windows\registry.hpp higan_v092r08\nall\windows\registry.hpp
--- higan_v092r07\nall\windows\registry.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\windows\registry.hpp	Thu May 02 05:48:02 2013
@@ -24,7 +24,7 @@
 namespace nall {
 
 struct registry {
-  static bool exists(const string &name) {
+  static bool exists(const string& name) {
     lstring part = name.split("/");
     HKEY handle, rootKey = root(part.take(0));
     string node = part.take();
@@ -39,7 +39,7 @@
     return false;
   }
 
-  static string read(const string &name) {
+  static string read(const string& name) {
     lstring part = name.split("/");
     HKEY handle, rootKey = root(part.take(0));
     string node = part.take();
@@ -54,7 +54,7 @@
     return "";
   }
 
-  static void write(const string &name, const string &data = "") {
+  static void write(const string& name, const string& data = "") {
     lstring part = name.split("/");
     HKEY handle, rootKey = root(part.take(0));
     string node = part.take(), path;
@@ -71,7 +71,7 @@
     }
   }
 
-  static bool remove(const string &name) {
+  static bool remove(const string& name) {
     lstring part = name.split("/");
     HKEY rootKey = root(part.take(0));
     string node = part.take();
@@ -80,7 +80,7 @@
     return SHDeleteValueW(rootKey, utf16_t(path), utf16_t(node)) == ERROR_SUCCESS;
   }
 
-  static lstring contents(const string &name) {
+  static lstring contents(const string& name) {
     lstring part = name.split("/"), result;
     HKEY handle, rootKey = root(part.take(0));
     part.remove();
@@ -106,7 +106,7 @@
   }
 
 private:
-  static HKEY root(const string &name) {
+  static HKEY root(const string& name) {
     if(name == "HKCR") return HKEY_CLASSES_ROOT;
     if(name == "HKCC") return HKEY_CURRENT_CONFIG;
     if(name == "HKCU") return HKEY_CURRENT_USER;
diff -ru higan_v092r07\nall\windows\utf8.hpp higan_v092r08\nall\windows\utf8.hpp
--- higan_v092r07\nall\windows\utf8.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\windows\utf8.hpp	Thu May 02 05:48:02 2013
@@ -18,8 +18,7 @@
 
 namespace nall {
   //UTF-8 to UTF-16
-  class utf16_t {
-  public:
+  struct utf16_t {
     operator wchar_t*() {
       return buffer;
     }
@@ -28,7 +27,7 @@
       return buffer;
     }
 
-    utf16_t(const char *s = "") {
+    utf16_t(const char* s = "") {
       if(!s) s = "";
       unsigned length = MultiByteToWideChar(CP_UTF8, 0, s, -1, nullptr, 0);
       buffer = new wchar_t[length + 1]();
@@ -40,12 +39,11 @@
     }
 
   private:
-    wchar_t *buffer;
+    wchar_t* buffer;
   };
 
   //UTF-16 to UTF-8
-  class utf8_t {
-  public:
+  struct utf8_t {
     operator char*() {
       return buffer;
     }
@@ -54,7 +52,7 @@
       return buffer;
     }
 
-    utf8_t(const wchar_t *s = L"") {
+    utf8_t(const wchar_t* s = L"") {
       if(!s) s = L"";
       unsigned length = WideCharToMultiByte(CP_UTF8, 0, s, -1, nullptr, 0, nullptr, nullptr);
       buffer = new char[length + 1]();
@@ -69,11 +67,11 @@
     utf8_t& operator=(const utf8_t&) = delete;
 
   private:
-    char *buffer;
+    char* buffer;
   };
 
-  inline void utf8_args(int &argc, char **&argv) {
-    wchar_t **wargv = CommandLineToArgvW(GetCommandLineW(), &argc);
+  inline void utf8_args(int& argc, char**& argv) {
+    wchar_t** wargv = CommandLineToArgvW(GetCommandLineW(), &argc);
     argv = new char*[argc];
     for(unsigned i = 0; i < argc; i++) {
       argv[i] = new char[_MAX_PATH];
diff -ru higan_v092r07\nall\zip.hpp higan_v092r08\nall\zip.hpp
--- higan_v092r07\nall\zip.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\nall\zip.hpp	Thu May 02 05:48:02 2013
@@ -9,17 +9,17 @@
 namespace nall {
 
 struct zip {
-  zip(const string &filename) {
+  zip(const string& filename) {
     fp.open(filename, file::mode::write);
     time_t currentTime = time(nullptr);
-    tm *info = localtime(&currentTime);
+    tm* info = localtime(&currentTime);
     dosTime = (info->tm_hour << 11) | (info->tm_min << 5) | (info->tm_sec >> 1);
     dosDate = ((info->tm_year - 80) << 9) | ((1 + info->tm_mon) << 5) + (info->tm_mday);
   }
 
   //append path: append("path/");
   //append file: append("path/file", data, size);
-  void append(string filename, const uint8_t *data = nullptr, unsigned size = 0u) {
+  void append(string filename, const uint8_t* data = nullptr, unsigned size = 0u) {
     filename.transform("\\", "/");
     uint32_t checksum = crc32_calculate(data, size);
     directory.append({filename, checksum, size, fp.offset()});
@@ -43,7 +43,7 @@
   ~zip() {
     //central directory
     unsigned baseOffset = fp.offset();
-    for(auto &entry : directory) {
+    for(auto& entry : directory) {
       fp.writel(0x02014b50, 4);               //signature
       fp.writel(0x0014, 2);                   //version made by (2.0)
       fp.writel(0x0014, 2);                   //version needed to extract (2.0)
diff -ru higan_v092r07\phoenix\cocoa\action\action.hpp higan_v092r08\phoenix\cocoa\action\action.hpp
--- higan_v092r07\phoenix\cocoa\action\action.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\action.hpp	Thu May 02 05:48:03 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pAction : public pObject {
-  Action &action;
-  NSMenuItem *cocoaAction = nullptr;
+  Action& action;
+  NSMenuItem* cocoaAction = nullptr;
 
   void setEnabled(bool enabled);
   void setVisible(bool visible);
 
-  pAction(Action &action) : pObject(action), action(action) {}
+  pAction(Action& action) : pObject(action), action(action) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\action\check-item.cpp higan_v092r08\phoenix\cocoa\action\check-item.cpp
--- higan_v092r07\phoenix\cocoa\action\check-item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\check-item.cpp	Thu May 02 05:48:03 2013
@@ -33,7 +33,7 @@
   }
 }
 
-void pCheckItem::setText(const string &text) {
+void pCheckItem::setText(const string& text) {
   @autoreleasepool {
     [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\action\check-item.hpp higan_v092r08\phoenix\cocoa\action\check-item.hpp
--- higan_v092r07\phoenix\cocoa\action\check-item.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\check-item.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaCheckItem : NSMenuItem {
 @public
-  phoenix::CheckItem *checkItem;
+  phoenix::CheckItem* checkItem;
 }
 -(id) initWith:(phoenix::CheckItem&)checkItem;
 -(void) activate;
@@ -9,14 +9,14 @@
 namespace phoenix {
 
 struct pCheckItem : public pAction {
-  CheckItem &checkItem;
-  CocoaCheckItem *cocoaCheckItem = nullptr;
+  CheckItem& checkItem;
+  CocoaCheckItem* cocoaCheckItem = nullptr;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckItem(CheckItem &checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\action\item.cpp higan_v092r08\phoenix\cocoa\action\item.cpp
--- higan_v092r07\phoenix\cocoa\action\item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\item.cpp	Thu May 02 05:48:03 2013
@@ -17,14 +17,14 @@
 
 namespace phoenix {
 
-void pItem::setImage(const image &image) {
+void pItem::setImage(const image& image) {
   @autoreleasepool {
     unsigned size = 15;  //there is no API to retrieve the optimal size
     [cocoaAction setImage:NSMakeImage(image, size, size)];
   }
 }
 
-void pItem::setText(const string &text) {
+void pItem::setText(const string& text) {
   @autoreleasepool {
     [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\action\item.hpp higan_v092r08\phoenix\cocoa\action\item.hpp
--- higan_v092r07\phoenix\cocoa\action\item.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\item.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaItem : NSMenuItem {
 @public
-  phoenix::Item *item;
+  phoenix::Item* item;
 }
 -(id) initWith:(phoenix::Item&)item;
 -(void) activate;
@@ -9,13 +9,13 @@
 namespace phoenix {
 
 struct pItem : public pAction {
-  Item &item;
-  CocoaItem *cocoaItem = nullptr;
+  Item& item;
+  CocoaItem* cocoaItem = nullptr;
 
-  void setImage(const image &image);
-  void setText(const string &text);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pItem(Item &item) : pAction(item), item(item) {}
+  pItem(Item& item) : pAction(item), item(item) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\action\menu.cpp higan_v092r08\phoenix\cocoa\action\menu.cpp
--- higan_v092r07\phoenix\cocoa\action\menu.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\menu.cpp	Thu May 02 05:48:03 2013
@@ -18,26 +18,26 @@
 
 namespace phoenix {
 
-void pMenu::append(Action &action) {
+void pMenu::append(Action& action) {
   @autoreleasepool {
     [[cocoaAction cocoaMenu] addItem:action.p.cocoaAction];
   }
 }
 
-void pMenu::remove(Action &action) {
+void pMenu::remove(Action& action) {
   @autoreleasepool {
     [[cocoaAction cocoaMenu] removeItem:action.p.cocoaAction];
   }
 }
 
-void pMenu::setImage(const image &image) {
+void pMenu::setImage(const image& image) {
   @autoreleasepool {
     unsigned size = 15;  //there is no API to retrieve the optimal size
     [cocoaAction setImage:NSMakeImage(image, size, size)];
   }
 }
 
-void pMenu::setText(const string &text) {
+void pMenu::setText(const string& text) {
   @autoreleasepool {
     [[cocoaAction cocoaMenu] setTitle:[NSString stringWithUTF8String:text]];
     [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
diff -ru higan_v092r07\phoenix\cocoa\action\menu.hpp higan_v092r08\phoenix\cocoa\action\menu.hpp
--- higan_v092r07\phoenix\cocoa\action\menu.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\menu.hpp	Thu May 02 05:48:03 2013
@@ -1,7 +1,7 @@
 @interface CocoaMenu : NSMenuItem {
 @public
-  phoenix::Menu *menu;
-  NSMenu *cocoaMenu;
+  phoenix::Menu* menu;
+  NSMenu* cocoaMenu;
 }
 -(id) initWith:(phoenix::Menu&)menu;
 -(NSMenu*) cocoaMenu;
@@ -10,15 +10,15 @@
 namespace phoenix {
 
 struct pMenu : public pAction {
-  Menu &menu;
-  CocoaMenu *cocoaMenu = nullptr;
+  Menu& menu;
+  CocoaMenu* cocoaMenu = nullptr;
 
-  void append(Action &action);
-  void remove(Action &action);
-  void setImage(const image &image);
-  void setText(const string &text);
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pMenu(Menu &menu) : pAction(menu), menu(menu) {}
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\action\radio-item.cpp higan_v092r08\phoenix\cocoa\action\radio-item.cpp
--- higan_v092r07\phoenix\cocoa\action\radio-item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\radio-item.cpp	Thu May 02 05:48:03 2013
@@ -27,17 +27,17 @@
 
 void pRadioItem::setChecked() {
   @autoreleasepool {
-    for(auto &item : radioItem.state.group) {
+    for(auto& item : radioItem.state.group) {
       auto state = (&item == &radioItem) ? NSOnState : NSOffState;
       [item.p.cocoaAction setState:state];
     }
   }
 }
 
-void pRadioItem::setGroup(const group<RadioItem&> &group) {
+void pRadioItem::setGroup(const group<RadioItem>& group) {
 }
 
-void pRadioItem::setText(const string &text) {
+void pRadioItem::setText(const string& text) {
   @autoreleasepool {
     [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\action\radio-item.hpp higan_v092r08\phoenix\cocoa\action\radio-item.hpp
--- higan_v092r07\phoenix\cocoa\action\radio-item.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\radio-item.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaRadioItem : NSMenuItem {
 @public
-  phoenix::RadioItem *radioItem;
+  phoenix::RadioItem* radioItem;
 }
 -(id) initWith:(phoenix::RadioItem&)radioItem;
 -(void) activate;
@@ -9,15 +9,15 @@
 namespace phoenix {
 
 struct pRadioItem : public pAction {
-  RadioItem &radioItem;
-  CocoaRadioItem *cocoaRadioItem = nullptr;
+  RadioItem& radioItem;
+  CocoaRadioItem* cocoaRadioItem = nullptr;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioItem&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioItem>& group);
+  void setText(const string& text);
 
-  pRadioItem(RadioItem &radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\action\separator.hpp higan_v092r08\phoenix\cocoa\action\separator.hpp
--- higan_v092r07\phoenix\cocoa\action\separator.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\action\separator.hpp	Thu May 02 05:48:03 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 struct pSeparator : public pAction {
-  Separator &separator;
-  NSMenuItem *cocoaSeparator = nullptr;
+  Separator& separator;
+  NSMenuItem* cocoaSeparator = nullptr;
 
-  pSeparator(Separator &separator) : pAction(separator), separator(separator) {}
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\application.cpp higan_v092r08\phoenix\cocoa\application.cpp
--- higan_v092r07\phoenix\cocoa\application.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\application.cpp	Thu May 02 05:48:03 2013
@@ -19,9 +19,9 @@
 }
 
 -(void) updateInDock:(NSTimer*)timer {
-  NSArray *windows = [NSApp windows];
+  NSArray* windows = [NSApp windows];
   for(unsigned n = 0; n < [windows count]; n++) {
-    NSWindow *window = [windows objectAtIndex:n];
+    NSWindow* window = [windows objectAtIndex:n];
     if([window isMiniaturized]) {
       [window updateInDock];
     }
@@ -30,15 +30,15 @@
 
 @end
 
-CocoaDelegate *cocoaDelegate = nullptr;
+CocoaDelegate* cocoaDelegate = nullptr;
 
 namespace phoenix {
 
 void pApplication::run() {
-//NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.1667 target:cocoaDelegate selector:@selector(updateInDock:) userInfo:nil repeats:YES];
+//NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:0.1667 target:cocoaDelegate selector:@selector(updateInDock:) userInfo:nil repeats:YES];
 
   if(Application::main) {
-    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.0 target:cocoaDelegate selector:@selector(run:) userInfo:nil repeats:YES];
+    NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:0.0 target:cocoaDelegate selector:@selector(run:) userInfo:nil repeats:YES];
 
     //below line is needed to run application during window resize; however it has a large performance penalty on the resize smoothness
     //[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSEventTrackingRunLoopMode];
@@ -52,7 +52,7 @@
 bool pApplication::pendingEvents() {
   bool result = false;
   @autoreleasepool {
-    NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:NO];
+    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:NO];
     if(event != nil) result = true;
   }
   return result;
@@ -61,7 +61,7 @@
 void pApplication::processEvents() {
   @autoreleasepool {
     while(applicationState.quit == false) {
-      NSEvent *event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES];
+      NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES];
       if(event == nil) break;
       [event retain];
       [NSApp sendEvent:event];
@@ -73,7 +73,7 @@
 void pApplication::quit() {
   @autoreleasepool {
     [NSApp stop:nil];
-    NSEvent *event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
+    NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
     [NSApp postEvent:event atStart:true];
   }
 }
diff -ru higan_v092r07\phoenix\cocoa\browser-window.cpp higan_v092r08\phoenix\cocoa\browser-window.cpp
--- higan_v092r07\phoenix\cocoa\browser-window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\browser-window.cpp	Thu May 02 05:48:03 2013
@@ -1,16 +1,16 @@
 namespace phoenix {
 
-string pBrowserWindow::directory(BrowserWindow::State &state) {
+string pBrowserWindow::directory(BrowserWindow::State& state) {
   string result;
 
   @autoreleasepool {
-    NSOpenPanel *panel = [NSOpenPanel openPanel];
+    NSOpenPanel* panel = [NSOpenPanel openPanel];
     if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
     [panel setCanChooseDirectories:YES];
     [panel setCanChooseFiles:NO];
     if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
-      NSArray *names = [panel filenames];
-      const char *name = [[names objectAtIndex:0] UTF8String];
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
       if(name) result = name;
     }
   }
@@ -18,23 +18,23 @@
   return result;
 }
 
-string pBrowserWindow::open(BrowserWindow::State &state) {
+string pBrowserWindow::open(BrowserWindow::State& state) {
   string result;
 
   @autoreleasepool {
-    NSMutableArray *filters = [[NSMutableArray alloc] init];
-    for(auto &rule : state.filters) {
+    NSMutableArray* filters = [[NSMutableArray alloc] init];
+    for(auto& rule : state.filters) {
       string pattern = rule.split<1>("(")(1).rtrim<1>(")");
       if(!pattern.empty()) [filters addObject:[NSString stringWithUTF8String:pattern]];
     }
-    NSOpenPanel *panel = [NSOpenPanel openPanel];
+    NSOpenPanel* panel = [NSOpenPanel openPanel];
     if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
     [panel setCanChooseDirectories:NO];
     [panel setCanChooseFiles:YES];
     [panel setAllowedFileTypes:filters];
     if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
-      NSArray *names = [panel filenames];
-      const char *name = [[names objectAtIndex:0] UTF8String];
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
       if(name) result = name;
     }
     [filters release];
@@ -43,21 +43,21 @@
   return result;
 }
 
-string pBrowserWindow::save(BrowserWindow::State &state) {
+string pBrowserWindow::save(BrowserWindow::State& state) {
   string result;
 
   @autoreleasepool {
-    NSMutableArray *filters = [[NSMutableArray alloc] init];
-    for(auto &rule : state.filters) {
+    NSMutableArray* filters = [[NSMutableArray alloc] init];
+    for(auto& rule : state.filters) {
       string pattern = rule.split<1>("(")(1).rtrim<1>(")");
       if(!pattern.empty()) [filters addObjects:[NSString stringWithUTF8String:pattern]];
     }
-    NSSavePanel *panel = [NSSavePanel savePanel];
+    NSSavePanel* panel = [NSSavePanel savePanel];
     if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
     [panel setAllowedFileTypes:filters];
     if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
-      NSArray *names = [panel filenames];
-      const char *name = [[names objectAtIndex:0] UTF8String];
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
       if(name) result = name;
     }
     [filters release];
diff -ru higan_v092r07\phoenix\cocoa\browser-window.hpp higan_v092r08\phoenix\cocoa\browser-window.hpp
--- higan_v092r07\phoenix\cocoa\browser-window.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\browser-window.hpp	Thu May 02 05:48:03 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pBrowserWindow {
-  static string directory(BrowserWindow::State &state);
-  static string open(BrowserWindow::State &state);
-  static string save(BrowserWindow::State &state);
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
 };
 
 }
diff -ru higan_v092r07\phoenix\cocoa\font.cpp higan_v092r08\phoenix\cocoa\font.cpp
--- higan_v092r07\phoenix\cocoa\font.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\font.cpp	Thu May 02 05:48:03 2013
@@ -18,20 +18,20 @@
   return {"Menlo, ", size, ", ", style};
 }
 
-Size pFont::size(const string &font, const string &text) {
+Size pFont::size(const string& font, const string& text) {
   @autoreleasepool {
-    if(NSFont *nsFont = cocoaFont(font)) {
+    if(NSFont* nsFont = cocoaFont(font)) {
       return size(nsFont, text);
     }
   }
   return {0, 0};
 }
 
-NSFont* pFont::cocoaFont(const string &description) {
+NSFont* pFont::cocoaFont(const string& description) {
   lstring part = description.split<2>(",");
-  for(auto &item : part) item.strip();
+  for(auto& item : part) item.strip();
 
-  NSString *family = @"Lucida Grande";
+  NSString* family = @"Lucida Grande";
   NSFontTraitMask traits = 0;
   CGFloat size = 12;
 
@@ -47,10 +47,10 @@
   return [[NSFontManager sharedFontManager] fontWithFamily:family traits:traits weight:5 size:size];
 }
 
-Size pFont::size(NSFont *font, const string &text) {
+Size pFont::size(NSFont* font, const string& text) {
   @autoreleasepool {
-    NSString *cocoaText = [NSString stringWithUTF8String:text];
-    NSDictionary *fontAttributes = [NSDictionary dictionaryWithObjectsAndKeys:font, NSFontAttributeName, nil];
+    NSString* cocoaText = [NSString stringWithUTF8String:text];
+    NSDictionary* fontAttributes = [NSDictionary dictionaryWithObjectsAndKeys:font, NSFontAttributeName, nil];
     NSSize size = [cocoaText sizeWithAttributes:fontAttributes];
     return {size.width, size.height};
   }
diff -ru higan_v092r07\phoenix\cocoa\font.hpp higan_v092r08\phoenix\cocoa\font.hpp
--- higan_v092r07\phoenix\cocoa\font.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\font.hpp	Thu May 02 05:48:03 2013
@@ -4,10 +4,10 @@
   static string serif(unsigned size, string style);
   static string sans(unsigned size, string style);
   static string monospace(unsigned size, string style);
-  static Size size(const string &font, const string &text);
+  static Size size(const string& font, const string& text);
 
-  static NSFont* cocoaFont(const string &description);
-  static Size size(NSFont *font, const string &text);
+  static NSFont* cocoaFont(const string& description);
+  static Size size(NSFont* font, const string& text);
 };
 
 }
diff -ru higan_v092r07\phoenix\cocoa\keyboard.cpp higan_v092r08\phoenix\cocoa\keyboard.cpp
--- higan_v092r07\phoenix\cocoa\keyboard.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\keyboard.cpp	Thu May 02 05:48:03 2013
@@ -7,7 +7,7 @@
 vector<bool> pKeyboard::state() {
   vector<bool> output;
   output.resize((unsigned)Keyboard::Scancode::Limit);
-  for(auto &n : output) n = false;
+  for(auto& n : output) n = false;
   return output;
 }
 
diff -ru higan_v092r07\phoenix\cocoa\message-window.cpp higan_v092r08\phoenix\cocoa\message-window.cpp
--- higan_v092r07\phoenix\cocoa\message-window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\message-window.cpp	Thu May 02 05:48:03 2013
@@ -2,9 +2,9 @@
 
 enum class MessageWindowType : unsigned { Error, Information, Question, Warning };
 
-MessageWindow::Response MessageWindow_dialog(MessageWindow::State &state, MessageWindowType type) {
+MessageWindow::Response MessageWindow_dialog(MessageWindow::State& state, MessageWindowType type) {
   @autoreleasepool {
-    NSAlert *alert = [[[NSAlert alloc] init] autorelease];
+    NSAlert* alert = [[[NSAlert alloc] init] autorelease];
     if(state.title) [alert setMessageText:[NSString stringWithUTF8String:state.title]];
     [alert setInformativeText:[NSString stringWithUTF8String:state.text]];
 
@@ -60,19 +60,19 @@
   throw;
 }
 
-MessageWindow::Response pMessageWindow::error(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
   return MessageWindow_dialog(state, MessageWindowType::Error);
 }
 
-MessageWindow::Response pMessageWindow::information(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
   return MessageWindow_dialog(state, MessageWindowType::Information);
 }
 
-MessageWindow::Response pMessageWindow::question(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
   return MessageWindow_dialog(state, MessageWindowType::Question);
 }
 
-MessageWindow::Response pMessageWindow::warning(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
   return MessageWindow_dialog(state, MessageWindowType::Warning);
 }
 
diff -ru higan_v092r07\phoenix\cocoa\message-window.hpp higan_v092r08\phoenix\cocoa\message-window.hpp
--- higan_v092r07\phoenix\cocoa\message-window.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\message-window.hpp	Thu May 02 05:48:03 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 struct pMessageWindow {
-  static MessageWindow::Response error(MessageWindow::State &state);
-  static MessageWindow::Response information(MessageWindow::State &state);
-  static MessageWindow::Response question(MessageWindow::State &state);
-  static MessageWindow::Response warning(MessageWindow::State &state);
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
 };
 
 }
diff -ru higan_v092r07\phoenix\cocoa\object.hpp higan_v092r08\phoenix\cocoa\object.hpp
--- higan_v092r07\phoenix\cocoa\object.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\object.hpp	Thu May 02 05:48:03 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 struct pObject {
-  Object &object;
+  Object& object;
   bool locked;
 
-  pObject(Object &object) : object(object), locked(false) {}
+  pObject(Object& object) : object(object), locked(false) {}
   virtual ~pObject() {}
 
   void constructor();
diff -ru higan_v092r07\phoenix\cocoa\timer.hpp higan_v092r08\phoenix\cocoa\timer.hpp
--- higan_v092r07\phoenix\cocoa\timer.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\timer.hpp	Thu May 02 05:48:03 2013
@@ -1,7 +1,7 @@
 @interface CocoaTimer : NSObject {
 @public
-  phoenix::Timer *timer;
-  NSTimer *instance;
+  phoenix::Timer* timer;
+  NSTimer* instance;
 }
 -(id) initWith:(phoenix::Timer&)timer;
 -(NSTimer*) instance;
@@ -12,13 +12,13 @@
 namespace phoenix {
 
 struct pTimer : public pObject {
-  Timer &timer;
-  CocoaTimer *cocoaTimer = nullptr;
+  Timer& timer;
+  CocoaTimer* cocoaTimer = nullptr;
 
   void setEnabled(bool enabled);
   void setInterval(unsigned milliseconds);
 
-  pTimer(Timer &timer) : pObject(timer), timer(timer) {}
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\utility.cpp higan_v092r08\phoenix\cocoa\utility.cpp
--- higan_v092r07\phoenix\cocoa\utility.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\utility.cpp	Thu May 02 05:48:03 2013
@@ -2,8 +2,8 @@
   if(image.empty()) return nil;
   if(width && height) image.scale(width, height, Interpolation::Linear);
   image.transform(0, 32, 255u << 24, 255u << 0, 255u << 8, 255u << 16);
-  NSImage *cocoaImage = [[[NSImage alloc] initWithSize:NSMakeSize(image.width, image.height)] autorelease];
-  NSBitmapImageRep *bitmap = [[[NSBitmapImageRep alloc]
+  NSImage* cocoaImage = [[[NSImage alloc] initWithSize:NSMakeSize(image.width, image.height)] autorelease];
+  NSBitmapImageRep* bitmap = [[[NSBitmapImageRep alloc]
     initWithBitmapDataPlanes:nil
     pixelsWide:image.width pixelsHigh:image.height
     bitsPerSample:8 samplesPerPixel:4 hasAlpha:YES
diff -ru higan_v092r07\phoenix\cocoa\widget\button.cpp higan_v092r08\phoenix\cocoa\widget\button.cpp
--- higan_v092r07\phoenix\cocoa\widget\button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\button.cpp	Thu May 02 05:48:03 2013
@@ -35,14 +35,14 @@
   return {size.width + 20, size.height + 4};
 }
 
-void pButton::setGeometry(const Geometry &geometry) {
+void pButton::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x - 2, geometry.y - 2,
     geometry.width + 4, geometry.height + 4
   });
 }
 
-void pButton::setImage(const image &image, Orientation orientation) {
+void pButton::setImage(const image& image, Orientation orientation) {
   @autoreleasepool {
     if(image.empty()) {
       [cocoaView setImage:nil];
@@ -56,7 +56,7 @@
   }
 }
 
-void pButton::setText(const string &text) {
+void pButton::setText(const string& text) {
   @autoreleasepool {
     [cocoaView setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\button.hpp higan_v092r08\phoenix\cocoa\widget\button.hpp
--- higan_v092r07\phoenix\cocoa\widget\button.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\button.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaButton : NSButton {
 @public
-  phoenix::Button *button;
+  phoenix::Button* button;
 }
 -(id) initWith:(phoenix::Button&)button;
 -(IBAction) activate:(id)sender;
@@ -9,15 +9,15 @@
 namespace phoenix {
 
 struct pButton : public pWidget {
-  Button &button;
-  CocoaButton *cocoaButton = nullptr;
+  Button& button;
+  CocoaButton* cocoaButton = nullptr;
 
   Size minimumSize();
-  void setGeometry(const Geometry &geometry);
-  void setImage(const image &image, Orientation orientation);
-  void setText(const string &text);
+  void setGeometry(const Geometry& geometry);
+  void setImage(const image& image, Orientation orientation);
+  void setText(const string& text);
 
-  pButton(Button &button) : pWidget(button), button(button) {}
+  pButton(Button& button) : pWidget(button), button(button) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\canvas.cpp higan_v092r08\phoenix\cocoa\widget\canvas.cpp
--- higan_v092r07\phoenix\cocoa\widget\canvas.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\canvas.cpp	Thu May 02 05:48:03 2013
@@ -73,10 +73,10 @@
 
 namespace phoenix {
 
-void pCanvas::setSize(const Size &size) {
+void pCanvas::setSize(const Size& size) {
   @autoreleasepool {
-    NSImage *image = [[[NSImage alloc] initWithSize:NSMakeSize(size.width, size.height)] autorelease];
-    NSBitmapImageRep *bitmap = [[[NSBitmapImageRep alloc]
+    NSImage* image = [[[NSImage alloc] initWithSize:NSMakeSize(size.width, size.height)] autorelease];
+    NSBitmapImageRep* bitmap = [[[NSBitmapImageRep alloc]
       initWithBitmapDataPlanes:nil
       pixelsWide:size.width pixelsHigh:size.height
       bitsPerSample:8 samplesPerPixel:4 hasAlpha:YES
@@ -92,9 +92,9 @@
 
 void pCanvas::update() {
   @autoreleasepool {
-    if(NSBitmapImageRep *bitmap = [[[cocoaView image] representations] objectAtIndex:0]) {
-      uint8_t *target = [bitmap bitmapData];
-      uint32_t *source = canvas.state.data;
+    if(NSBitmapImageRep* bitmap = [[[cocoaView image] representations] objectAtIndex:0]) {
+      uint8_t* target = [bitmap bitmapData];
+      uint32_t* source = canvas.state.data;
 
       for(unsigned n = 0; n < canvas.state.width * canvas.state.height; n++) {
         *target++ = *source >> 16;
diff -ru higan_v092r07\phoenix\cocoa\widget\canvas.hpp higan_v092r08\phoenix\cocoa\widget\canvas.hpp
--- higan_v092r07\phoenix\cocoa\widget\canvas.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\canvas.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaCanvas : NSImageView {
 @public
-  phoenix::Canvas *canvas;
+  phoenix::Canvas* canvas;
 }
 -(id) initWith:(phoenix::Canvas&)canvas;
 -(void) mouseButton:(NSEvent*)event down:(BOOL)isDown;
@@ -20,13 +20,13 @@
 namespace phoenix {
 
 struct pCanvas : public pWidget {
-  Canvas &canvas;
-  CocoaCanvas *cocoaCanvas = nullptr;
+  Canvas& canvas;
+  CocoaCanvas* cocoaCanvas = nullptr;
 
-  void setSize(const Size &size);
+  void setSize(const Size& size);
   void update();
 
-  pCanvas(Canvas &canvas) : pWidget(canvas), canvas(canvas) {}
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\check-button.cpp higan_v092r08\phoenix\cocoa\widget\check-button.cpp
--- higan_v092r07\phoenix\cocoa\widget\check-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\check-button.cpp	Thu May 02 05:48:03 2013
@@ -37,14 +37,14 @@
   }
 }
 
-void pCheckButton::setGeometry(const Geometry &geometry) {
+void pCheckButton::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x - 2, geometry.y,
     geometry.width + 4, geometry.height
   });
 }
 
-void pCheckButton::setText(const string &text) {
+void pCheckButton::setText(const string& text) {
   @autoreleasepool {
     [cocoaView setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\check-button.hpp higan_v092r08\phoenix\cocoa\widget\check-button.hpp
--- higan_v092r07\phoenix\cocoa\widget\check-button.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\check-button.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaCheckButton : NSButton {
 @public
-  phoenix::CheckButton *checkButton;
+  phoenix::CheckButton* checkButton;
 }
 -(id) initWith:(phoenix::CheckButton&)checkButton;
 -(IBAction) activate:(id)sender;
@@ -9,16 +9,16 @@
 namespace phoenix {
 
 struct pCheckButton : public pWidget {
-  CheckButton &checkButton;
-  CocoaCheckButton *cocoaCheckButton = nullptr;
+  CheckButton& checkButton;
+  CocoaCheckButton* cocoaCheckButton = nullptr;
 
   bool checked();
   Size minimumSize();
   void setChecked(bool checked);
-  void setGeometry(const Geometry &geometry);
-  void setText(const string &text);
+  void setGeometry(const Geometry& geometry);
+  void setText(const string& text);
 
-  pCheckButton(CheckButton &checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\combo-button.cpp higan_v092r08\phoenix\cocoa\widget\combo-button.cpp
--- higan_v092r07\phoenix\cocoa\widget\combo-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\combo-button.cpp	Thu May 02 05:48:03 2013
@@ -18,7 +18,7 @@
 
 namespace phoenix {
 
-void pComboButton::append(const string &text) {
+void pComboButton::append(const string& text) {
   @autoreleasepool {
     [cocoaView addItemWithTitle:[NSString stringWithUTF8String:text]];
   }
@@ -26,12 +26,12 @@
 
 Size pComboButton::minimumSize() {
   unsigned maximumWidth = 0;
-  for(auto &text : comboButton.state.text) maximumWidth = max(maximumWidth, Font::size(comboButton.font(), text).width);
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, Font::size(comboButton.font(), text).width);
   Size size = Font::size(comboButton.font(), " ");
   return {maximumWidth + 36, size.height + 6};
 }
 
-void pComboButton::modify(unsigned row, const string &text) {
+void pComboButton::modify(unsigned row, const string& text) {
   @autoreleasepool {
     [[cocoaView itemAtIndex:row] setTitle:[NSString stringWithUTF8String:text]];
   }
@@ -55,7 +55,7 @@
   }
 }
 
-void pComboButton::setGeometry(const Geometry &geometry) {
+void pComboButton::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x - 2, geometry.y,
     geometry.width + 4, geometry.height
diff -ru higan_v092r07\phoenix\cocoa\widget\combo-button.hpp higan_v092r08\phoenix\cocoa\widget\combo-button.hpp
--- higan_v092r07\phoenix\cocoa\widget\combo-button.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\combo-button.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaComboButton : NSPopUpButton {
 @public
-  phoenix::ComboButton *comboButton;
+  phoenix::ComboButton* comboButton;
 }
 -(id) initWith:(phoenix::ComboButton&)comboButton;
 -(IBAction) activate:(id)sender;
@@ -9,19 +9,19 @@
 namespace phoenix {
 
 struct pComboButton : public pWidget {
-  ComboButton &comboButton;
-  CocoaComboButton *cocoaComboButton = nullptr;
+  ComboButton& comboButton;
+  CocoaComboButton* cocoaComboButton = nullptr;
 
-  void append(const string &text);
+  void append(const string& text);
   Size minimumSize();
-  void modify(unsigned row, const string &text);
+  void modify(unsigned row, const string& text);
   void remove(unsigned row);
   void reset();
   unsigned selection();
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setSelection(unsigned row);
 
-  pComboButton(ComboButton &comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\hex-edit.hpp higan_v092r08\phoenix\cocoa\widget\hex-edit.hpp
--- higan_v092r07\phoenix\cocoa\widget\hex-edit.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\hex-edit.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaHexEdit : NSScrollView {
 @public
-  phoenix::HexEdit *hexEdit;
+  phoenix::HexEdit* hexEdit;
 }
 -(id) initWith:(phoenix::HexEdit&)hexEdit;
 @end
@@ -8,8 +8,8 @@
 namespace phoenix {
 
 struct pHexEdit : public pWidget {
-  HexEdit &hexEdit;
-  CocoaHexEdit *cocoaHexEdit = nullptr;
+  HexEdit& hexEdit;
+  CocoaHexEdit* cocoaHexEdit = nullptr;
 
   void setColumns(unsigned columns);
   void setLength(unsigned length);
@@ -17,7 +17,7 @@
   void setRows(unsigned rows);
   void update();
 
-  pHexEdit(HexEdit &hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\horizontal-scroller.cpp higan_v092r08\phoenix\cocoa\widget\horizontal-scroller.cpp
--- higan_v092r07\phoenix\cocoa\widget\horizontal-scroller.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\horizontal-scroller.cpp	Thu May 02 05:48:03 2013
@@ -25,7 +25,7 @@
 }
 
 -(IBAction) scroll:(id)sender {
-  auto &state = horizontalScroller->state;
+  auto& state = horizontalScroller->state;
 
   switch([self hitPart]) {
   case NSScrollerIncrementLine:
diff -ru higan_v092r07\phoenix\cocoa\widget\horizontal-scroller.hpp higan_v092r08\phoenix\cocoa\widget\horizontal-scroller.hpp
--- higan_v092r07\phoenix\cocoa\widget\horizontal-scroller.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\horizontal-scroller.hpp	Thu May 02 05:48:03 2013
@@ -1,6 +1,6 @@
 @interface CocoaHorizontalScroller : NSScroller {
 @public
-  phoenix::HorizontalScroller *horizontalScroller;
+  phoenix::HorizontalScroller* horizontalScroller;
 }
 -(id) initWith:(phoenix::HorizontalScroller&)horizontalScroller;
 -(void) update;
@@ -10,15 +10,15 @@
 namespace phoenix {
 
 struct pHorizontalScroller : public pWidget {
-  HorizontalScroller &horizontalScroller;
-  CocoaHorizontalScroller *cocoaHorizontalScroller = nullptr;
+  HorizontalScroller& horizontalScroller;
+  CocoaHorizontalScroller* cocoaHorizontalScroller = nullptr;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalScroller(HorizontalScroller &horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\horizontal-slider.cpp higan_v092r08\phoenix\cocoa\widget\horizontal-slider.cpp
--- higan_v092r07\phoenix\cocoa\widget\horizontal-slider.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\horizontal-slider.cpp	Thu May 02 05:48:04 2013
@@ -30,7 +30,7 @@
   }
 }
 
-void pHorizontalSlider::setGeometry(const Geometry &geometry) {
+void pHorizontalSlider::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x - 2, geometry.y,
     geometry.width + 4, geometry.height
diff -ru higan_v092r07\phoenix\cocoa\widget\horizontal-slider.hpp higan_v092r08\phoenix\cocoa\widget\horizontal-slider.hpp
--- higan_v092r07\phoenix\cocoa\widget\horizontal-slider.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\horizontal-slider.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaHorizontalSlider : NSSlider {
 @public
-  phoenix::HorizontalSlider *horizontalSlider;
+  phoenix::HorizontalSlider* horizontalSlider;
 }
 -(id) initWith:(phoenix::HorizontalSlider&)horizontalSlider;
 -(IBAction) activate:(id)sender;
@@ -9,16 +9,16 @@
 namespace phoenix {
 
 struct pHorizontalSlider : public pWidget {
-  HorizontalSlider &horizontalSlider;
-  CocoaHorizontalSlider *cocoaHorizontalSlider = nullptr;
+  HorizontalSlider& horizontalSlider;
+  CocoaHorizontalSlider* cocoaHorizontalSlider = nullptr;
 
   Size minimumSize();
   unsigned position();
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalSlider(HorizontalSlider &horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\label.cpp higan_v092r08\phoenix\cocoa\widget\label.cpp
--- higan_v092r07\phoenix\cocoa\widget\label.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\label.cpp	Thu May 02 05:48:04 2013
@@ -21,7 +21,7 @@
   return {size.width, size.height};
 }
 
-void pLabel::setGeometry(const Geometry &geometry) {
+void pLabel::setGeometry(const Geometry& geometry) {
   //NSTextField does not support vertical text centering:
   //simulate this by adjusting the geometry placement (reduce height, move view down)
   unsigned height = Font::size(label.font(), " ").height;
@@ -40,7 +40,7 @@
   });
 }
 
-void pLabel::setText(const string &text) {
+void pLabel::setText(const string& text) {
   @autoreleasepool {
     [cocoaView setStringValue:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\label.hpp higan_v092r08\phoenix\cocoa\widget\label.hpp
--- higan_v092r07\phoenix\cocoa\widget\label.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\label.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaLabel : NSTextField {
 @public
-  phoenix::Label *label;
+  phoenix::Label* label;
 }
 -(id) initWith:(phoenix::Label&)label;
 @end
@@ -8,14 +8,14 @@
 namespace phoenix {
 
 struct pLabel : public pWidget {
-  Label &label;
-  CocoaLabel *cocoaLabel = nullptr;
+  Label& label;
+  CocoaLabel* cocoaLabel = nullptr;
 
   Size minimumSize();
-  void setGeometry(const Geometry &geometry);
-  void setText(const string &text);
+  void setGeometry(const Geometry& geometry);
+  void setText(const string& text);
 
-  pLabel(Label &label) : pWidget(label), label(label) {}
+  pLabel(Label& label) : pWidget(label), label(label) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\layout.hpp higan_v092r08\phoenix\cocoa\widget\layout.hpp
--- higan_v092r07\phoenix\cocoa\widget\layout.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\layout.hpp	Thu May 02 05:48:04 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pLayout : public pSizable {
-  Layout &layout;
+  Layout& layout;
 
-  pLayout(Layout &layout) : pSizable(layout), layout(layout) {}
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
 };
 
 }
diff -ru higan_v092r07\phoenix\cocoa\widget\line-edit.cpp higan_v092r08\phoenix\cocoa\widget\line-edit.cpp
--- higan_v092r07\phoenix\cocoa\widget\line-edit.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\line-edit.cpp	Thu May 02 05:48:04 2013
@@ -37,7 +37,7 @@
   }
 }
 
-void pLineEdit::setText(const string &text) {
+void pLineEdit::setText(const string& text) {
   @autoreleasepool {
     [cocoaView setStringValue:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\line-edit.hpp higan_v092r08\phoenix\cocoa\widget\line-edit.hpp
--- higan_v092r07\phoenix\cocoa\widget\line-edit.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\line-edit.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaLineEdit : NSTextField <NSTextFieldDelegate> {
 @public
-  phoenix::LineEdit *lineEdit;
+  phoenix::LineEdit* lineEdit;
 }
 -(id) initWith:(phoenix::LineEdit&)lineEdit;
 -(void) textDidChange:(NSNotification*)n;
@@ -10,15 +10,15 @@
 namespace phoenix {
 
 struct pLineEdit : public pWidget {
-  LineEdit &lineEdit;
-  CocoaLineEdit *cocoaLineEdit = nullptr;
+  LineEdit& lineEdit;
+  CocoaLineEdit* cocoaLineEdit = nullptr;
 
   Size minimumSize();
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   string text();
 
-  pLineEdit(LineEdit &lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\list-view.cpp higan_v092r08\phoenix\cocoa\widget\list-view.cpp
--- higan_v092r07\phoenix\cocoa\widget\list-view.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\list-view.cpp	Thu May 02 05:48:04 2013
@@ -80,9 +80,9 @@
   [content setUsesAlternatingRowBackgroundColors:headers.size() >= 2];
 
   for(unsigned column = 0; column < headers.size(); column++) {
-    NSTableColumn *tableColumn = [[NSTableColumn alloc] initWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
-    NSTableHeaderCell *headerCell = [[NSTableHeaderCell alloc] initTextCell:[NSString stringWithUTF8String:headers(column)]];
-    CocoaListViewCell *dataCell = [[CocoaListViewCell alloc] initTextCell:@""];
+    NSTableColumn* tableColumn = [[NSTableColumn alloc] initWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
+    NSTableHeaderCell* headerCell = [[NSTableHeaderCell alloc] initTextCell:[NSString stringWithUTF8String:headers(column)]];
+    CocoaListViewCell* dataCell = [[CocoaListViewCell alloc] initTextCell:@""];
 
     [dataCell setEditable:NO];
 
@@ -107,8 +107,8 @@
   NSInteger column = [[tableColumn identifier] integerValue];
   unsigned height = [table rowHeight];
 
-  NSString *text = [NSString stringWithUTF8String:listView->state.text(row)(column)];
-  NSImage *image = NSMakeImage(listView->state.image(row)(column), height, height);
+  NSString* text = [NSString stringWithUTF8String:listView->state.text(row)(column)];
+  NSImage* image = NSMakeImage(listView->state.image(row)(column), height, height);
 
   if(image) return @{ @"text":text, @"image":image };
   return @{ @"text":text };
@@ -173,12 +173,12 @@
 }
 
 -(void) drawWithFrame:(NSRect)frame inView:(NSView*)view {
-  NSString *text = [[self objectValue] objectForKey:@"text"];
-  NSImage *image = [[self objectValue] objectForKey:@"image"];
+  NSString* text = [[self objectValue] objectForKey:@"text"];
+  NSImage* image = [[self objectValue] objectForKey:@"image"];
   unsigned textDisplacement = 0;
 
   if(image) {
-    NSGraphicsContext *context = [NSGraphicsContext currentContext];
+    NSGraphicsContext* context = [NSGraphicsContext currentContext];
     [context saveGraphicsState];
 
     NSRect targetRect = NSMakeRect(frame.origin.x, frame.origin.y, frame.size.height, frame.size.height);
@@ -194,7 +194,7 @@
     frame.size.width - textDisplacement, frame.size.height
   );
 
-  NSColor *textColor = [self isHighlighted]
+  NSColor* textColor = [self isHighlighted]
   ? [NSColor alternateSelectedControlTextColor]
   : [NSColor textColor];
 
@@ -208,7 +208,7 @@
 
 namespace phoenix {
 
-void pListView::append(const lstring &text) {
+void pListView::append(const lstring& text) {
   @autoreleasepool {
     [[cocoaView content] reloadData];
   }
@@ -217,13 +217,13 @@
 void pListView::autoSizeColumns() {
   @autoreleasepool {
     if(listView.state.checkable) {
-      NSTableColumn *tableColumn = [[cocoaView content] tableColumnWithIdentifier:@"check"];
+      NSTableColumn* tableColumn = [[cocoaView content] tableColumnWithIdentifier:@"check"];
       [tableColumn setWidth:20.0];
     }
 
     unsigned height = [[cocoaView content] rowHeight];
     for(unsigned column = 0; column < max(1u, listView.state.headerText.size()); column++) {
-      NSTableColumn *tableColumn = [[cocoaView content] tableColumnWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
+      NSTableColumn* tableColumn = [[cocoaView content] tableColumnWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
       unsigned minimumWidth = pFont::size([[tableColumn headerCell] font], listView.state.headerText(column)).width + 4;
       for(unsigned row = 0; row < listView.state.text.size(); row++) {
         unsigned width = pFont::size([cocoaView font], listView.state.text(row)(column)).width + 2;
@@ -241,7 +241,7 @@
   return listView.state.checked(row);
 }
 
-void pListView::modify(unsigned row, const lstring &text) {
+void pListView::modify(unsigned row, const lstring& text) {
   @autoreleasepool {
     [[cocoaView content] reloadData];
   }
@@ -285,13 +285,13 @@
   }
 }
 
-void pListView::setFont(const string &font) {
+void pListView::setFont(const string& font) {
   @autoreleasepool {
     [cocoaView setFont:pFont::cocoaFont(font)];
   }
 }
 
-void pListView::setHeaderText(const lstring &text) {
+void pListView::setHeaderText(const lstring& text) {
   @autoreleasepool {
     [cocoaView reloadColumns];
   }
@@ -307,7 +307,7 @@
   }
 }
 
-void pListView::setImage(unsigned row, unsigned column, const image &image) {
+void pListView::setImage(unsigned row, unsigned column, const image& image) {
   @autoreleasepool {
     [[cocoaView content] reloadData];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\list-view.hpp higan_v092r08\phoenix\cocoa\widget\list-view.hpp
--- higan_v092r07\phoenix\cocoa\widget\list-view.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\list-view.hpp	Thu May 02 05:48:04 2013
@@ -2,9 +2,9 @@
 
 @interface CocoaListView : NSScrollView <NSTableViewDelegate, NSTableViewDataSource> {
 @public
-  phoenix::ListView *listView;
-  CocoaListViewContent *content;
-  NSFont *font;
+  phoenix::ListView* listView;
+  CocoaListViewContent* content;
+  NSFont* font;
 }
 -(id) initWith:(phoenix::ListView&)listView;
 -(void) dealloc;
@@ -37,27 +37,27 @@
 namespace phoenix {
 
 struct pListView : public pWidget {
-  ListView &listView;
-  CocoaListView *cocoaListView = nullptr;
+  ListView& listView;
+  CocoaListView* cocoaListView = nullptr;
 
-  void append(const lstring &text);
+  void append(const lstring& text);
   void autoSizeColumns();
   bool checked(unsigned row);
-  void modify(unsigned row, const lstring &text);
+  void modify(unsigned row, const lstring& text);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable);
   void setChecked(unsigned row, bool checked);
-  void setFont(const string &font);
-  void setHeaderText(const lstring &text);
+  void setFont(const string& font);
+  void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
-  void setImage(unsigned row, unsigned column, const image &image);
+  void setImage(unsigned row, unsigned column, const image& image);
   void setSelected(bool selected);
   void setSelection(unsigned row);
 
-  pListView(ListView &listView) : pWidget(listView), listView(listView) {}
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\progress-bar.hpp higan_v092r08\phoenix\cocoa\widget\progress-bar.hpp
--- higan_v092r07\phoenix\cocoa\widget\progress-bar.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\progress-bar.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaProgressBar : NSProgressIndicator {
 @public
-  phoenix::ProgressBar *progressBar;
+  phoenix::ProgressBar* progressBar;
 }
 -(id) initWith:(phoenix::ProgressBar&)progressBar;
 @end
@@ -8,12 +8,12 @@
 namespace phoenix {
 
 struct pProgressBar : public pWidget {
-  ProgressBar &progressBar;
-  CocoaProgressBar *cocoaProgressBar = nullptr;
+  ProgressBar& progressBar;
+  CocoaProgressBar* cocoaProgressBar = nullptr;
 
   void setPosition(unsigned position);
 
-  pProgressBar(ProgressBar &progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\radio-button.cpp higan_v092r08\phoenix\cocoa\widget\radio-button.cpp
--- higan_v092r07\phoenix\cocoa\widget\radio-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\radio-button.cpp	Thu May 02 05:48:04 2013
@@ -33,24 +33,24 @@
 
 void pRadioButton::setChecked() {
   @autoreleasepool {
-    for(auto &button : radioButton.state.group) {
+    for(auto& button : radioButton.state.group) {
       auto state = (&button == &radioButton) ? NSOnState : NSOffState;
       [button.p.cocoaView setState:state];
     }
   }
 }
 
-void pRadioButton::setGeometry(const Geometry &geometry) {
+void pRadioButton::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x - 1, geometry.y,
     geometry.width + 2, geometry.height
   });
 }
 
-void pRadioButton::setGroup(const group<RadioButton&> &group) {
+void pRadioButton::setGroup(const group<RadioButton>& group) {
 }
 
-void pRadioButton::setText(const string &text) {
+void pRadioButton::setText(const string& text) {
   @autoreleasepool {
     [cocoaView setTitle:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\radio-button.hpp higan_v092r08\phoenix\cocoa\widget\radio-button.hpp
--- higan_v092r07\phoenix\cocoa\widget\radio-button.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\radio-button.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaRadioButton : NSButton {
 @public
-  phoenix::RadioButton *radioButton;
+  phoenix::RadioButton* radioButton;
 }
 -(id) initWith:(phoenix::RadioButton&)radioButton;
 -(IBAction) activate:(id)sender;
@@ -9,17 +9,17 @@
 namespace phoenix {
 
 struct pRadioButton : public pWidget {
-  RadioButton &radioButton;
-  CocoaRadioButton *cocoaRadioButton = nullptr;
+  RadioButton& radioButton;
+  CocoaRadioButton* cocoaRadioButton = nullptr;
 
   bool checked();
   Size minimumSize();
   void setChecked();
-  void setGeometry(const Geometry &geometry);
-  void setGroup(const group<RadioButton&> &group);
-  void setText(const string &text);
+  void setGeometry(const Geometry& geometry);
+  void setGroup(const group<RadioButton>& group);
+  void setText(const string& text);
 
-  pRadioButton(RadioButton &radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\sizable.hpp higan_v092r08\phoenix\cocoa\widget\sizable.hpp
--- higan_v092r07\phoenix\cocoa\widget\sizable.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\sizable.hpp	Thu May 02 05:48:04 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pSizable : public pObject {
-  Sizable &sizable;
+  Sizable& sizable;
 
-  pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
 };
 
 }
diff -ru higan_v092r07\phoenix\cocoa\widget\text-edit.cpp higan_v092r08\phoenix\cocoa\widget\text-edit.cpp
--- higan_v092r07\phoenix\cocoa\widget\text-edit.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\text-edit.cpp	Thu May 02 05:48:04 2013
@@ -57,13 +57,13 @@
   }
 }
 
-void pTextEdit::setFont(const string &font) {
+void pTextEdit::setFont(const string& font) {
   @autoreleasepool {
     [[cocoaView content] setFont:pFont::cocoaFont(font)];
   }
 }
 
-void pTextEdit::setText(const string &text) {
+void pTextEdit::setText(const string& text) {
   @autoreleasepool {
     [[cocoaView content] setString:[NSString stringWithUTF8String:text]];
   }
diff -ru higan_v092r07\phoenix\cocoa\widget\text-edit.hpp higan_v092r08\phoenix\cocoa\widget\text-edit.hpp
--- higan_v092r07\phoenix\cocoa\widget\text-edit.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\text-edit.hpp	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 @interface CocoaTextEdit : NSScrollView <NSTextViewDelegate> {
 @public
-  phoenix::TextEdit *textEdit;
-  NSTextView *content;
+  phoenix::TextEdit* textEdit;
+  NSTextView* content;
 }
 -(id) initWith:(phoenix::TextEdit&)textEdit;
 -(NSTextView*) content;
@@ -12,17 +12,17 @@
 namespace phoenix {
 
 struct pTextEdit : public pWidget {
-  TextEdit &textEdit;
-  CocoaTextEdit *cocoaTextEdit = nullptr;
+  TextEdit& textEdit;
+  CocoaTextEdit* cocoaTextEdit = nullptr;
 
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setFont(const string &font);
-  void setText(const string &text);
+  void setFont(const string& font);
+  void setText(const string& text);
   void setWordWrap(bool wordWrap);
   string text();
 
-  pTextEdit(TextEdit &textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\vertical-scroller.cpp higan_v092r08\phoenix\cocoa\widget\vertical-scroller.cpp
--- higan_v092r07\phoenix\cocoa\widget\vertical-scroller.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\vertical-scroller.cpp	Thu May 02 05:48:04 2013
@@ -25,7 +25,7 @@
 }
 
 -(IBAction) scroll:(id)sender {
-  auto &state = verticalScroller->state;
+  auto& state = verticalScroller->state;
 
   switch([self hitPart]) {
   case NSScrollerIncrementLine:
diff -ru higan_v092r07\phoenix\cocoa\widget\vertical-scroller.hpp higan_v092r08\phoenix\cocoa\widget\vertical-scroller.hpp
--- higan_v092r07\phoenix\cocoa\widget\vertical-scroller.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\vertical-scroller.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaVerticalScroller : NSScroller {
 @public
-  phoenix::VerticalScroller *verticalScroller;
+  phoenix::VerticalScroller* verticalScroller;
 }
 -(id) initWith:(phoenix::VerticalScroller&)verticalScroller;
 -(void) update;
@@ -10,15 +10,15 @@
 namespace phoenix {
 
 struct pVerticalScroller : public pWidget {
-  VerticalScroller &verticalScroller;
-  CocoaVerticalScroller *cocoaVerticalScroller = nullptr;
+  VerticalScroller& verticalScroller;
+  CocoaVerticalScroller* cocoaVerticalScroller = nullptr;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalScroller(VerticalScroller &verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\vertical-slider.cpp higan_v092r08\phoenix\cocoa\widget\vertical-slider.cpp
--- higan_v092r07\phoenix\cocoa\widget\vertical-slider.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\vertical-slider.cpp	Thu May 02 05:48:04 2013
@@ -30,7 +30,7 @@
   }
 }
 
-void pVerticalSlider::setGeometry(const Geometry &geometry) {
+void pVerticalSlider::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry({
     geometry.x, geometry.y - 2,
     geometry.width, geometry.height + 4
diff -ru higan_v092r07\phoenix\cocoa\widget\vertical-slider.hpp higan_v092r08\phoenix\cocoa\widget\vertical-slider.hpp
--- higan_v092r07\phoenix\cocoa\widget\vertical-slider.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\vertical-slider.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaVerticalSlider : NSSlider {
 @public
-  phoenix::VerticalSlider *verticalSlider;
+  phoenix::VerticalSlider* verticalSlider;
 }
 -(id) initWith:(phoenix::VerticalSlider&)verticalSlider;
 -(IBAction) activate:(id)sender;
@@ -9,16 +9,16 @@
 namespace phoenix {
 
 struct pVerticalSlider : public pWidget {
-  VerticalSlider &verticalSlider;
-  CocoaVerticalSlider *cocoaVerticalSlider = nullptr;
+  VerticalSlider& verticalSlider;
+  CocoaVerticalSlider* cocoaVerticalSlider = nullptr;
 
   Size minimumSize();
   unsigned position();
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalSlider(VerticalSlider &verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\viewport.hpp higan_v092r08\phoenix\cocoa\widget\viewport.hpp
--- higan_v092r07\phoenix\cocoa\widget\viewport.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\viewport.hpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 @interface CocoaViewport : NSView {
 @public
-  phoenix::Viewport *viewport;
+  phoenix::Viewport* viewport;
 }
 -(id) initWith:(phoenix::Viewport&)viewport;
 -(void) drawRect:(NSRect)rect;
@@ -12,12 +12,12 @@
 namespace phoenix {
 
 struct pViewport : public pWidget {
-  Viewport &viewport;
-  CocoaViewport *cocoaViewport = nullptr;
+  Viewport& viewport;
+  CocoaViewport* cocoaViewport = nullptr;
 
   uintptr_t handle();
 
-  pViewport(Viewport &viewport) : pWidget(viewport), viewport(viewport) {}
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\widget\widget.cpp higan_v092r08\phoenix\cocoa\widget\widget.cpp
--- higan_v092r07\phoenix\cocoa\widget\widget.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\widget.cpp	Thu May 02 05:48:04 2013
@@ -33,7 +33,7 @@
   }
 }
 
-void pWidget::setFont(const string &font) {
+void pWidget::setFont(const string& font) {
   @autoreleasepool {
     if([cocoaView respondsToSelector:@selector(setFont:)]) {
       [cocoaView setFont:pFont::cocoaFont(font)];
@@ -41,7 +41,7 @@
   }
 }
 
-void pWidget::setGeometry(const Geometry &geometry) {
+void pWidget::setGeometry(const Geometry& geometry) {
   @autoreleasepool {
     CGFloat windowHeight = [[cocoaView superview] frame].size.height;
     [cocoaView setFrame:NSMakeRect(geometry.x, windowHeight - geometry.y - geometry.height, geometry.width, geometry.height)];
diff -ru higan_v092r07\phoenix\cocoa\widget\widget.hpp higan_v092r08\phoenix\cocoa\widget\widget.hpp
--- higan_v092r07\phoenix\cocoa\widget\widget.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\widget\widget.hpp	Thu May 02 05:48:04 2013
@@ -1,19 +1,19 @@
 namespace phoenix {
 
 struct pWidget : public pSizable {
-  Widget &widget;
-  NSView *cocoaView = nullptr;
+  Widget& widget;
+  NSView* cocoaView = nullptr;
 
   bool enabled();
   bool focused();
   virtual Size minimumSize();
   void setEnabled(bool enabled);
   void setFocused();
-  virtual void setFont(const string &font);
-  virtual void setGeometry(const Geometry &geometry);
+  virtual void setFont(const string& font);
+  virtual void setGeometry(const Geometry& geometry);
   void setVisible(bool visible);
 
-  pWidget(Widget &widget) : pSizable(widget), widget(widget) {}
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\cocoa\window.cpp higan_v092r08\phoenix\cocoa\window.cpp
--- higan_v092r07\phoenix\cocoa\window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\window.cpp	Thu May 02 05:48:04 2013
@@ -12,14 +12,14 @@
     [self setAcceptsMouseMovedEvents:YES];
     [self setTitle:@""];
 
-    NSBundle *bundle = [NSBundle mainBundle];
-    NSDictionary *dictionary = [bundle infoDictionary];
-    NSString *applicationName = [dictionary objectForKey:@"CFBundleDisplayName"];
+    NSBundle* bundle = [NSBundle mainBundle];
+    NSDictionary* dictionary = [bundle infoDictionary];
+    NSString* applicationName = [dictionary objectForKey:@"CFBundleDisplayName"];
     if(applicationName == nil) applicationName = [NSString stringWithUTF8String:phoenix::applicationState.name];
 
     menuBar = [[NSMenu alloc] init];
 
-    NSMenuItem *item;
+    NSMenuItem* item;
     string text;
 
     rootMenu = [[NSMenu alloc] init];
@@ -37,7 +37,7 @@
     [rootMenu addItem:item];
     [rootMenu addItem:[NSMenuItem separatorItem]];
 
-    NSMenu *servicesMenu = [[[NSMenu alloc] initWithTitle:@"Services"] autorelease];
+    NSMenu* servicesMenu = [[[NSMenu alloc] initWithTitle:@"Services"] autorelease];
     item = [[[NSMenuItem alloc] initWithTitle:@"Services" action:nil keyEquivalent:@""] autorelease];
     [item setTarget:self];
     [item setSubmenu:servicesMenu];
@@ -133,12 +133,12 @@
 namespace phoenix {
 
 Window& pWindow::none() {
-  static Window *window = nullptr;
+  static Window* window = nullptr;
   if(window == nullptr) window = new Window;
   return *window;
 }
 
-void pWindow::append(Layout &layout) {
+void pWindow::append(Layout& layout) {
   Geometry geometry = window.state.geometry;
   geometry.x = geometry.y = 0;
   layout.setGeometry(geometry);
@@ -146,13 +146,13 @@
   statusBarReposition();
 }
 
-void pWindow::append(Menu &menu) {
+void pWindow::append(Menu& menu) {
   @autoreleasepool {
     [[cocoaWindow menuBar] addItem:menu.p.cocoaAction];
   }
 }
 
-void pWindow::append(Widget &widget) {
+void pWindow::append(Widget& widget) {
   if(widget.font().empty() && !window.state.widgetFont.empty()) {
     widget.setFont(window.state.widgetFont);
   }
@@ -167,7 +167,7 @@
 
 Color pWindow::backgroundColor() {
   @autoreleasepool {
-    NSColor *color = [[cocoaWindow backgroundColor] colorUsingColorSpaceName:NSCalibratedRGBColorSpace];
+    NSColor* color = [[cocoaWindow backgroundColor] colorUsingColorSpaceName:NSCalibratedRGBColorSpace];
     return {
       uint8_t(255 * [color redComponent]),
       uint8_t(255 * [color greenComponent]),
@@ -198,26 +198,26 @@
   }
 }
 
-void pWindow::remove(Layout &layout) {
+void pWindow::remove(Layout& layout) {
   @autoreleasepool {
     [[cocoaWindow contentView] setNeedsDisplay:YES];
   }
 }
 
-void pWindow::remove(Menu &menu) {
+void pWindow::remove(Menu& menu) {
   @autoreleasepool {
     [[cocoaWindow menuBar] removeItem:menu.p.cocoaAction];
   }
 }
 
-void pWindow::remove(Widget &widget) {
+void pWindow::remove(Widget& widget) {
   @autoreleasepool {
     [widget.p.cocoaView removeFromSuperview];
     [[cocoaWindow contentView] setNeedsDisplay:YES];
   }
 }
 
-void pWindow::setBackgroundColor(const Color &color) {
+void pWindow::setBackgroundColor(const Color& color) {
   @autoreleasepool {
     [cocoaWindow
       setBackgroundColor:[NSColor
@@ -250,7 +250,7 @@
   }
 }
 
-void pWindow::setGeometry(const Geometry &geometry) {
+void pWindow::setGeometry(const Geometry& geometry) {
   locked = true;
 
   @autoreleasepool {
@@ -264,7 +264,7 @@
       display:YES
     ];
 
-    for(auto &layout : window.state.layout) {
+    for(auto& layout : window.state.layout) {
       Geometry geometry = this->geometry();
       geometry.x = geometry.y = 0;
       layout.setGeometry(geometry);
@@ -276,7 +276,7 @@
   locked = false;
 }
 
-void pWindow::setMenuFont(const string &font) {
+void pWindow::setMenuFont(const string& font) {
 }
 
 void pWindow::setMenuVisible(bool visible) {
@@ -288,7 +288,7 @@
       [NSApp runModalForWindow:cocoaWindow];
     } else {
       [NSApp stopModal];
-      NSEvent *event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
+      NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
       [NSApp postEvent:event atStart:true];
     }
   }
@@ -302,14 +302,14 @@
   }
 }
 
-void pWindow::setStatusFont(const string &font) {
+void pWindow::setStatusFont(const string& font) {
   @autoreleasepool {
     [[cocoaWindow statusBar] setFont:pFont::cocoaFont(font)];
   }
   statusBarReposition();
 }
 
-void pWindow::setStatusText(const string &text) {
+void pWindow::setStatusText(const string& text) {
   @autoreleasepool {
     [[cocoaWindow statusBar] setStringValue:[NSString stringWithUTF8String:text]];
   }
@@ -322,7 +322,7 @@
   }
 }
 
-void pWindow::setTitle(const string &text) {
+void pWindow::setTitle(const string& text) {
   @autoreleasepool {
     [cocoaWindow setTitle:[NSString stringWithUTF8String:text]];
   }
@@ -335,7 +335,7 @@
   }
 }
 
-void pWindow::setWidgetFont(const string &font) {
+void pWindow::setWidgetFont(const string& font) {
 }
 
 void pWindow::constructor() {
@@ -369,7 +369,7 @@
     window.state.geometry.height = geometry.height;
   }
 
-  for(auto &layout : window.state.layout) {
+  for(auto& layout : window.state.layout) {
     Geometry geometry = this->geometry();
     geometry.x = geometry.y = 0;
     layout.setGeometry(geometry);
diff -ru higan_v092r07\phoenix\cocoa\window.hpp higan_v092r08\phoenix\cocoa\window.hpp
--- higan_v092r07\phoenix\cocoa\window.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\cocoa\window.hpp	Thu May 02 05:48:04 2013
@@ -1,9 +1,9 @@
 @interface CocoaWindow : NSWindow <NSWindowDelegate> {
 @public
-  phoenix::Window *window;
-  NSMenu *menuBar;
-  NSMenu *rootMenu;
-  NSTextField *statusBar;
+  phoenix::Window* window;
+  NSMenu* menuBar;
+  NSMenu* rootMenu;
+  NSTextField* statusBar;
 }
 -(id) initWith:(phoenix::Window&)window;
 -(BOOL) canBecomeKeyWindow;
@@ -22,37 +22,37 @@
 namespace phoenix {
 
 struct pWindow : public pObject {
-  Window &window;
-  CocoaWindow *cocoaWindow = nullptr;
+  Window& window;
+  CocoaWindow* cocoaWindow = nullptr;
 
   static Window& none();
 
-  void append(Layout &layout);
-  void append(Menu &menu);
-  void append(Widget &widget);
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
   Color backgroundColor();
   bool focused();
   Geometry frameMargin();
   Geometry geometry();
-  void remove(Layout &layout);
-  void remove(Menu &menu);
-  void remove(Widget &widget);
-  void setBackgroundColor(const Color &color);
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(const Color& color);
   void setFocused();
   void setFullScreen(bool fullScreen);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const string& font);
   void setMenuVisible(bool visible);
   void setModal(bool modal);
   void setResizable(bool resizable);
-  void setStatusFont(const string &font);
-  void setStatusText(const string &text);
+  void setStatusFont(const string& font);
+  void setStatusText(const string& text);
   void setStatusVisible(bool visible);
-  void setTitle(const string &text);
+  void setTitle(const string& text);
   void setVisible(bool visible);
-  void setWidgetFont(const string &font);
+  void setWidgetFont(const string& font);
 
-  pWindow(Window &window) : pObject(window), window(window) {}
+  pWindow(Window& window) : pObject(window), window(window) {}
   void constructor();
   void destructor();
   void moveEvent();
diff -ru higan_v092r07\phoenix\core\core.cpp higan_v092r08\phoenix\core\core.cpp
--- higan_v092r07\phoenix\core\core.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\core.cpp	Thu May 02 05:48:04 2013
@@ -61,7 +61,7 @@
   return pApplication::quit();
 }
 
-void Application::setName(const string &name) {
+void Application::setName(const string& name) {
   applicationState.name = name;
 }
 
@@ -99,7 +99,7 @@
   return {x, ",", y, ",", width, ",", height};
 }
 
-Geometry::Geometry(const string &text) {
+Geometry::Geometry(const string& text) {
   lstring part = text.split(",");
   x = integer(part(0, "256"));
   y = integer(part(1, "256"));
@@ -110,19 +110,19 @@
 //Font
 //====
 
-string Font::serif(unsigned size, const string &style) {
+string Font::serif(unsigned size, const string& style) {
   return pFont::serif(size, style);
 }
 
-string Font::sans(unsigned size, const string &style) {
+string Font::sans(unsigned size, const string& style) {
   return pFont::sans(size, style);
 }
 
-string Font::monospace(unsigned size, const string &style) {
+string Font::monospace(unsigned size, const string& style) {
   return pFont::monospace(size, style);
 }
 
-Size Font::size(const string &font, const string &text) {
+Size Font::size(const string &font, const string& text) {
   return pFont::size(font, text);
 }
 
@@ -182,22 +182,22 @@
   return pBrowserWindow::save(state);
 }
 
-BrowserWindow& BrowserWindow::setFilters_(const lstring &filters) {
+BrowserWindow& BrowserWindow::setFilters_(const lstring& filters) {
   state.filters = filters;
   return *this;
 }
 
-BrowserWindow& BrowserWindow::setParent(Window &parent) {
+BrowserWindow& BrowserWindow::setParent(Window& parent) {
   state.parent = &parent;
   return *this;
 }
 
-BrowserWindow& BrowserWindow::setPath(const string &path) {
+BrowserWindow& BrowserWindow::setPath(const string& path) {
   state.path = path;
   return *this;
 }
 
-BrowserWindow& BrowserWindow::setTitle(const string &title) {
+BrowserWindow& BrowserWindow::setTitle(const string& title) {
   state.title = title;
   return *this;
 }
@@ -228,17 +228,17 @@
   return pMessageWindow::question(state);
 }
 
-MessageWindow& MessageWindow::setParent(Window &parent) {
+MessageWindow& MessageWindow::setParent(Window& parent) {
   state.parent = &parent;
   return *this;
 }
 
-MessageWindow& MessageWindow::setText(const string &text) {
+MessageWindow& MessageWindow::setText(const string& text) {
   state.text = text;
   return *this;
 }
 
-MessageWindow& MessageWindow::setTitle(const string &title) {
+MessageWindow& MessageWindow::setTitle(const string& title) {
   state.title = title;
   return *this;
 }
@@ -248,7 +248,7 @@
   return pMessageWindow::warning(state);
 }
 
-MessageWindow::MessageWindow(const string &text):
+MessageWindow::MessageWindow(const string& text):
 state(*new State) {
   state.text = text;
 }
@@ -260,7 +260,7 @@
 //Object
 //======
 
-Object::Object(pObject &p):
+Object::Object(pObject& p):
 p(p) {
   Application::initialize();
   p.constructor();
@@ -304,7 +304,7 @@
   return pWindow::none();
 }
 
-void Window::append_(Layout &layout) {
+void Window::append_(Layout& layout) {
   if(state.layout.append(layout)) {
     ((Sizable&)layout).state.window = this;
     ((Sizable&)layout).state.layout = nullptr;
@@ -313,14 +313,14 @@
   }
 }
 
-void Window::append_(Menu &menu) {
+void Window::append_(Menu& menu) {
   if(state.menu.append(menu)) {
     ((Action&)menu).state.window = this;
     p.append(menu);
   }
 }
 
-void Window::append_(Widget &widget) {
+void Window::append_(Widget& widget) {
   if(state.widget.append(widget)) {
     ((Sizable&)widget).state.window = this;
     p.append(widget);
@@ -356,34 +356,34 @@
   return p.geometry();
 }
 
-void Window::remove_(Layout &layout) {
+void Window::remove_(Layout& layout) {
   if(state.layout.remove(layout)) {
     p.remove(layout);
     ((Sizable&)layout).state.window = nullptr;
   }
 }
 
-void Window::remove_(Menu &menu) {
+void Window::remove_(Menu& menu) {
   if(state.menu.remove(menu)) {
     p.remove(menu);
     ((Action&)menu).state.window = nullptr;
   }
 }
 
-void Window::remove_(Widget &widget) {
+void Window::remove_(Widget& widget) {
   if(state.widget.remove(widget)) {
     p.remove(widget);
     ((Sizable&)widget).state.window = nullptr;
   }
 }
 
-void Window::setBackgroundColor(const Color &color) {
+void Window::setBackgroundColor(const Color& color) {
   state.backgroundColorOverride = true;
   state.backgroundColor = color;
   return p.setBackgroundColor(color);
 }
 
-void Window::setFrameGeometry(const Geometry &geometry) {
+void Window::setFrameGeometry(const Geometry& geometry) {
   Geometry margin = p.frameMargin();
   return setGeometry({
     geometry.x + margin.x, geometry.y + margin.y,
@@ -400,12 +400,12 @@
   return p.setFullScreen(fullScreen);
 }
 
-void Window::setGeometry(const Geometry &geometry) {
+void Window::setGeometry(const Geometry& geometry) {
   state.geometry = geometry;
   return p.setGeometry(geometry);
 }
 
-void Window::setMenuFont(const string &font) {
+void Window::setMenuFont(const string& font) {
   state.menuFont = font;
   return p.setMenuFont(font);
 }
@@ -425,7 +425,7 @@
   return p.setResizable(resizable);
 }
 
-void Window::setSmartGeometry(const Geometry &geometry) {
+void Window::setSmartGeometry(const Geometry& geometry) {
   Geometry margin = p.frameMargin();
   return setGeometry({
     geometry.x + margin.x, geometry.y + margin.y,
@@ -433,12 +433,12 @@
   });
 }
 
-void Window::setStatusFont(const string &font) {
+void Window::setStatusFont(const string& font) {
   state.statusFont = font;
   return p.setStatusFont(font);
 }
 
-void Window::setStatusText(const string &text) {
+void Window::setStatusText(const string& text) {
   state.statusText = text;
   return p.setStatusText(text);
 }
@@ -448,7 +448,7 @@
   return p.setStatusVisible(visible);
 }
 
-void Window::setTitle(const string &text) {
+void Window::setTitle(const string& text) {
   state.title = text;
   return p.setTitle(text);
 }
@@ -459,7 +459,7 @@
   return p.setVisible(visible);
 }
 
-void Window::setWidgetFont(const string &font) {
+void Window::setWidgetFont(const string& font) {
   state.widgetFont = font;
   return p.setWidgetFont(font);
 }
@@ -510,7 +510,7 @@
   return state.visible;
 }
 
-Action::Action(pAction &p):
+Action::Action(pAction& p):
 state(*new State),
 Object(p),
 p(p) {
@@ -525,8 +525,8 @@
 //Menu
 //====
 
-void Menu::append(const group<Action&> &list) {
-  for(auto &action : list) {
+void Menu::append(const group<Action>& list) {
+  for(auto& action : list) {
     if(state.action.append(action)) {
       action.state.menu = this;
       p.append(action);
@@ -534,8 +534,8 @@
   }
 }
 
-void Menu::remove(const group<Action&> &list) {
-  for(auto &action : list) {
+void Menu::remove(const group<Action>& list) {
+  for(auto& action : list) {
     if(state.action.remove(action)) {
       action.state.menu = nullptr;
       return p.remove(action);
@@ -543,12 +543,12 @@
   }
 }
 
-void Menu::setImage(const image &image) {
+void Menu::setImage(const image& image) {
   state.image = image;
   return p.setImage(image);
 }
 
-void Menu::setText(const string &text) {
+void Menu::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -583,12 +583,12 @@
 //Item
 //====
 
-void Item::setImage(const image &image) {
+void Item::setImage(const image& image) {
   state.image = image;
   return p.setImage(image);
 }
 
-void Item::setText(const string &text) {
+void Item::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -618,7 +618,7 @@
   return p.setChecked(checked);
 }
 
-void CheckItem::setText(const string &text) {
+void CheckItem::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -639,9 +639,9 @@
 //RadioItem
 //=========
 
-void RadioItem::group(const nall::group<RadioItem&> &list) {
-  for(auto &item : list) item.p.setGroup(item.state.group = list);
-  if(list.size()) list[0].setChecked();
+void RadioItem::group(const nall::group<RadioItem>& list) {
+  for(auto& item : list) item.p.setGroup(item.state.group = list);
+  if(list.size()) list.first().setChecked();
 }
 
 bool RadioItem::checked() {
@@ -649,12 +649,12 @@
 }
 
 void RadioItem::setChecked() {
-  for(auto &item : state.group) item.state.checked = false;
+  for(auto& item : state.group) item.state.checked = false;
   state.checked = true;
   return p.setChecked();
 }
 
-void RadioItem::setText(const string &text) {
+void RadioItem::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -672,7 +672,7 @@
 }
 
 RadioItem::~RadioItem() {
-  for(auto &item : state.group) {
+  for(auto& item : state.group) {
     if(&item != this) item.state.group.remove(*this);
   }
   p.destructor();
@@ -691,7 +691,7 @@
   return state.window;
 }
 
-Sizable::Sizable(pSizable &p):
+Sizable::Sizable(pSizable& p):
 state(*new State),
 Object(p),
 p(p) {
@@ -707,7 +707,7 @@
 //Layout
 //======
 
-void Layout::append(Sizable &sizable) {
+void Layout::append(Sizable& sizable) {
   sizable.state.layout = this;
   sizable.state.window = nullptr;
 
@@ -722,7 +722,7 @@
   }
 }
 
-void Layout::remove(Sizable &sizable) {
+void Layout::remove(Sizable& sizable) {
   if(dynamic_cast<Widget*>(&sizable)) {
     Widget &widget = (Widget&)sizable;
     if(sizable.window()) sizable.window()->remove(widget);
@@ -739,7 +739,7 @@
 p(base_from_member<pLayout&>::value) {
 }
 
-Layout::Layout(pLayout &p):
+Layout::Layout(pLayout& p):
 state(*new State),
 base_from_member<pLayout&>(p),
 Sizable(p),
@@ -785,12 +785,12 @@
   return p.setFocused();
 }
 
-void Widget::setFont(const string &font) {
+void Widget::setFont(const string& font) {
   state.font = font;
   return p.setFont(font);
 }
 
-void Widget::setGeometry(const Geometry &geometry) {
+void Widget::setGeometry(const Geometry& geometry) {
   state.geometry = geometry;
   return p.setGeometry(geometry);
 }
@@ -813,7 +813,7 @@
   p.constructor();
 }
 
-Widget::Widget(pWidget &p):
+Widget::Widget(pWidget& p):
 state(*new State),
 base_from_member<pWidget&>(p),
 Sizable(base_from_member<pWidget&>::value),
@@ -829,13 +829,13 @@
 //Button
 //======
 
-void Button::setImage(const image &image, Orientation orientation) {
+void Button::setImage(const image& image, Orientation orientation) {
   state.image = image;
   state.orientation = orientation;
   return p.setImage(image, orientation);
 }
 
-void Button::setText(const string &text) {
+void Button::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -860,16 +860,16 @@
   return state.data;
 }
 
-bool Canvas::setImage(const nall::image &image) {
+bool Canvas::setImage(const nall::image& image) {
   if(image.data == nullptr || image.width == 0 || image.height == 0) return false;
   state.width = image.width;
   state.height = image.height;
-  setSize({ state.width, state.height });
+  setSize({state.width, state.height});
   memcpy(state.data, image.data, state.width * state.height * sizeof(uint32_t));
   return true;
 }
 
-void Canvas::setSize(const Size &size) {
+void Canvas::setSize(const Size& size) {
   state.width = size.width;
   state.height = size.height;
   delete[] state.data;
@@ -878,7 +878,7 @@
 }
 
 Size Canvas::size() {
-  return { state.width, state.height };
+  return {state.width, state.height};
 }
 
 void Canvas::update() {
@@ -912,7 +912,7 @@
   return p.setChecked(checked);
 }
 
-void CheckButton::setText(const string &text) {
+void CheckButton::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -933,14 +933,14 @@
 //ComboButton
 //===========
 
-void ComboButton::append_(const lstring &list) {
-  for(auto &text : list) {
+void ComboButton::append_(const lstring& list) {
+  for(auto& text : list) {
     state.text.append(text);
     p.append(text);
   }
 }
 
-void ComboButton::modify(unsigned row, const string &text) {
+void ComboButton::modify(unsigned row, const string& text) {
   state.text(row) = text;
   p.modify(row, text);
 }
@@ -1097,7 +1097,7 @@
 //Label
 //=====
 
-void Label::setText(const string &text) {
+void Label::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -1123,7 +1123,7 @@
   return p.setEditable(editable);
 }
 
-void LineEdit::setText(const string &text) {
+void LineEdit::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -1148,7 +1148,7 @@
 //ListView
 //========
 
-void ListView::append_(const lstring &text) {
+void ListView::append_(const lstring& text) {
   state.checked.append(false);
   state.text.append(text);
   return p.append(text);
@@ -1162,7 +1162,7 @@
   return p.checked(row);
 }
 
-void ListView::modify_(unsigned row, const lstring &text) {
+void ListView::modify_(unsigned row, const lstring& text) {
   state.text[row] = text;
   return p.modify(row, text);
 }
@@ -1198,7 +1198,7 @@
   return p.setChecked(row, checked);
 }
 
-void ListView::setHeaderText_(const lstring &text) {
+void ListView::setHeaderText_(const lstring& text) {
   state.headerText = text;
   return p.setHeaderText(text);
 }
@@ -1208,7 +1208,7 @@
   return p.setHeaderVisible(visible);
 }
 
-void ListView::setImage(unsigned row, unsigned column, const nall::image &image) {
+void ListView::setImage(unsigned row, unsigned column, const nall::image& image) {
   state.image(row)(column) = image;
   return p.setImage(row, column, image);
 }
@@ -1261,9 +1261,9 @@
 //RadioButton
 //===========
 
-void RadioButton::group(const nall::group<RadioButton&> &list) {
-  for(auto &item : list) item.p.setGroup(item.state.group = list);
-  if(list.size()) list[0].setChecked();
+void RadioButton::group(const nall::group<RadioButton>& list) {
+  for(auto& item : list) item.p.setGroup(item.state.group = list);
+  if(list.size()) list.first().setChecked();
 }
 
 bool RadioButton::checked() {
@@ -1276,7 +1276,7 @@
   return p.setChecked();
 }
 
-void RadioButton::setText(const string &text) {
+void RadioButton::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
@@ -1290,7 +1290,7 @@
 }
 
 RadioButton::~RadioButton() {
-  for(auto &item : state.group) {
+  for(auto& item : state.group) {
     if(&item != this) item.state.group.remove(*this);
   }
   p.destructor();
@@ -1310,7 +1310,7 @@
   return p.setEditable(editable);
 }
 
-void TextEdit::setText(const string &text) {
+void TextEdit::setText(const string& text) {
   state.text = text;
   return p.setText(text);
 }
diff -ru higan_v092r07\phoenix\core\core.hpp higan_v092r08\phoenix\core\core.hpp
--- higan_v092r07\phoenix\core\core.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\core.hpp	Thu May 02 05:48:04 2013
@@ -58,7 +58,7 @@
   static bool pendingEvents();
   static void processEvents();
   static void quit();
-  static void setName(const nall::string &name);
+  static void setName(const nall::string& name);
 
   Application() = delete;
   struct State;
@@ -108,16 +108,16 @@
   inline Geometry() : x(0), y(0), width(0), height(0) {}
   inline Geometry(const Position& position, const Size& size) : x(position.x), y(position.y), width(size.width), height(size.height) {}
   template<typename X, typename Y, typename W, typename H> inline Geometry(X x, Y y, W width, H height) : x(x), y(y), width(width), height(height) {}
-  Geometry(const nall::string &text);
+  Geometry(const nall::string& text);
 };
 
 enum class Orientation : unsigned { Horizontal, Vertical };
 
 struct Font {
-  static nall::string serif(unsigned size = 0, const nall::string &style = "");
-  static nall::string sans(unsigned size = 0, const nall::string &style = "");
-  static nall::string monospace(unsigned size = 0, const nall::string &style = "");
-  static Size size(const nall::string &font, const nall::string &text);
+  static nall::string serif(unsigned size = 0, const nall::string& style = "");
+  static nall::string sans(unsigned size = 0, const nall::string& style = "");
+  static nall::string monospace(unsigned size = 0, const nall::string& style = "");
+  static Size size(const nall::string &font, const nall::string& text);
   Font() = delete;
 };
 
@@ -144,20 +144,20 @@
 };
 
 struct BrowserWindow {
-  template<typename... Args> BrowserWindow& setFilters(const Args&... args) { return setFilters_({args...}); }
+  template<typename... Args> BrowserWindow& setFilters(Args&&... args) { return setFilters_({args...}); }
 
   nall::string directory();
   nall::string open();
   nall::string save();
   BrowserWindow& setFilters_(const nall::lstring& filters);
-  BrowserWindow& setParent(Window &parent);
-  BrowserWindow& setPath(const nall::string &path);
-  BrowserWindow& setTitle(const nall::string &title);
+  BrowserWindow& setParent(Window& parent);
+  BrowserWindow& setPath(const nall::string& path);
+  BrowserWindow& setTitle(const nall::string& title);
 
   BrowserWindow();
   ~BrowserWindow();
   struct State;
-  State &state;
+  State& state;
 };
 
 struct MessageWindow {
@@ -178,23 +178,23 @@
   Response error(Buttons = Buttons::Ok);
   Response information(Buttons = Buttons::Ok);
   Response question(Buttons = Buttons::YesNo);
-  MessageWindow& setParent(Window &parent);
-  MessageWindow& setText(const nall::string &text);
-  MessageWindow& setTitle(const nall::string &title);
+  MessageWindow& setParent(Window& parent);
+  MessageWindow& setText(const nall::string& text);
+  MessageWindow& setTitle(const nall::string& title);
   Response warning(Buttons = Buttons::Ok);
 
-  MessageWindow(const nall::string &text = "");
+  MessageWindow(const nall::string& text = "");
   ~MessageWindow();
   struct State;
-  State &state;
+  State& state;
 };
 
 struct Object {
-  Object(pObject &p);
+  Object(pObject& p);
   Object& operator=(const Object&) = delete;
   Object(const Object&) = delete;
   virtual ~Object();
-  pObject &p;
+  pObject& p;
 };
 
 struct Timer : private nall::base_from_member<pTimer&>, Object {
@@ -206,8 +206,8 @@
   Timer();
   ~Timer();
   struct State;
-  State &state;
-  pTimer &p;
+  State& state;
+  pTimer& p;
 };
 
 struct Window : private nall::base_from_member<pWindow&>, Object {
@@ -221,37 +221,37 @@
 
   inline void append() {}
   inline void remove() {}
-  template<typename T, typename... Args> void append(T &arg, Args&... args) { append_(arg); append(args...); }
-  template<typename T, typename... Args> void remove(T &arg, Args&... args) { remove_(arg); remove(args...); }
+  template<typename T, typename... Args> void append(T& arg, Args&&... args) { append_(arg); append(args...); }
+  template<typename T, typename... Args> void remove(T& arg, Args&&... args) { remove_(arg); remove(args...); }
 
-  void append_(Layout &layout);
-  void append_(Menu &menu);
-  void append_(Widget &widget);
+  void append_(Layout& layout);
+  void append_(Menu& menu);
+  void append_(Widget& widget);
   Color backgroundColor();
   Geometry frameGeometry();
   Geometry frameMargin();
   bool focused();
   bool fullScreen();
   Geometry geometry();
-  void remove_(Layout &layout);
-  void remove_(Menu &menu);
-  void remove_(Widget &widget);
-  void setBackgroundColor(const Color &color);
-  void setFrameGeometry(const Geometry &geometry);
+  void remove_(Layout& layout);
+  void remove_(Menu& menu);
+  void remove_(Widget& widget);
+  void setBackgroundColor(const Color& color);
+  void setFrameGeometry(const Geometry& geometry);
   void setFocused();
   void setFullScreen(bool fullScreen = true);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const nall::string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const nall::string& font);
   void setMenuVisible(bool visible = true);
   void setModal(bool modal = true);
   void setResizable(bool resizable = true);
-  void setSmartGeometry(const Geometry &geometry);
-  void setStatusFont(const nall::string &font);
-  void setStatusText(const nall::string &text);
+  void setSmartGeometry(const Geometry& geometry);
+  void setStatusFont(const nall::string& font);
+  void setStatusText(const nall::string& text);
   void setStatusVisible(bool visible = true);
-  void setTitle(const nall::string &text);
+  void setTitle(const nall::string& text);
   void setVisible(bool visible = true);
-  void setWidgetFont(const nall::string &font);
+  void setWidgetFont(const nall::string& font);
   nall::string statusText();
   void synchronizeLayout();
   bool visible();
@@ -259,8 +259,8 @@
   Window();
   ~Window();
   struct State;
-  State &state;
-  pWindow &p;
+  State& state;
+  pWindow& p;
 };
 
 struct Action : Object {
@@ -269,46 +269,46 @@
   void setVisible(bool visible = true);
   bool visible();
 
-  Action(pAction &p);
+  Action(pAction& p);
   ~Action();
   struct State;
-  State &state;
-  pAction &p;
+  State& state;
+  pAction& p;
 };
 
 struct Menu : private nall::base_from_member<pMenu&>, Action {
-  template<typename... Args> void append(Args&... args) { append({args...}); }
-  template<typename... Args> void remove(Args&... args) { remove({args...}); }
+  template<typename... Args> void append(Args&&... args) { append({std::forward<Args>(args)...}); }
+  template<typename... Args> void remove(Args&&... args) { remove({std::forward<Args>(args)...}); }
 
-  void append(const nall::group<Action&> &list);
-  void remove(const nall::group<Action&> &list);
-  void setImage(const nall::image &image = nall::image{});
-  void setText(const nall::string &text);
+  void append(const nall::group<Action>& list);
+  void remove(const nall::group<Action>& list);
+  void setImage(const nall::image& image = nall::image{});
+  void setText(const nall::string& text);
 
   Menu();
   ~Menu();
   struct State;
-  State &state;
-  pMenu &p;
+  State& state;
+  pMenu& p;
 };
 
 struct Separator : private nall::base_from_member<pSeparator&>, Action {
   Separator();
   ~Separator();
-  pSeparator &p;
+  pSeparator& p;
 };
 
 struct Item : private nall::base_from_member<pItem&>, Action {
   nall::function<void ()> onActivate;
 
-  void setImage(const nall::image &image = nall::image{});
-  void setText(const nall::string &text);
+  void setImage(const nall::image& image = nall::image{});
+  void setText(const nall::string& text);
 
   Item();
   ~Item();
   struct State;
-  State &state;
-  pItem &p;
+  State& state;
+  pItem& p;
 };
 
 struct CheckItem : private nall::base_from_member<pCheckItem&>, Action {
@@ -316,31 +316,31 @@
 
   bool checked();
   void setChecked(bool checked = true);
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
 
   CheckItem();
   ~CheckItem();
   struct State;
-  State &state;
-  pCheckItem &p;
+  State& state;
+  pCheckItem& p;
 };
 
 struct RadioItem : private nall::base_from_member<pRadioItem&>, Action {
-  template<typename... Args> static void group(Args&... args) { group({args...}); }
-  static void group(const nall::group<RadioItem&> &list);
+  template<typename... Args> static void group(Args&&... args) { group({std::forward<Args>(args)...}); }
+  static void group(const nall::group<RadioItem>& list);
 
   nall::function<void ()> onActivate;
 
   bool checked();
   void setChecked();
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
   nall::string text();
 
   RadioItem();
   ~RadioItem();
   struct State;
-  State &state;
-  pRadioItem &p;
+  State& state;
+  pRadioItem& p;
 };
 
 struct Sizable : Object {
@@ -348,30 +348,30 @@
   Layout* layout();
   virtual Size minimumSize() = 0;
   virtual void setEnabled(bool enabled = true) = 0;
-  virtual void setGeometry(const Geometry &geometry) = 0;
+  virtual void setGeometry(const Geometry& geometry) = 0;
   virtual void setVisible(bool visible = true) = 0;
   virtual bool visible() = 0;
   Window* window();
 
-  Sizable(pSizable &p);
+  Sizable(pSizable& p);
   ~Sizable();
   struct State;
-  State &state;
-  pSizable &p;
+  State& state;
+  pSizable& p;
 };
 
 struct Layout : private nall::base_from_member<pLayout&>, Sizable {
-  virtual void append(Sizable &sizable);
-  virtual void remove(Sizable &sizable);
+  virtual void append(Sizable& sizable);
+  virtual void remove(Sizable& sizable);
   virtual void reset() {}
   virtual void synchronizeLayout() = 0;
 
   Layout();
-  Layout(pLayout &p);
+  Layout(pLayout& p);
   ~Layout();
   struct State;
-  State &state;
-  pLayout &p;
+  State& state;
+  pLayout& p;
 };
 
 struct Widget : private nall::base_from_member<pWidget&>, Sizable {
@@ -382,30 +382,30 @@
   Size minimumSize();
   void setEnabled(bool enabled = true);
   void setFocused();
-  void setFont(const nall::string &font);
-  void setGeometry(const Geometry &geometry);
+  void setFont(const nall::string& font);
+  void setGeometry(const Geometry& geometry);
   void setVisible(bool visible = true);
   bool visible();
 
   Widget();
-  Widget(pWidget &p);
+  Widget(pWidget& p);
   ~Widget();
   struct State;
-  State &state;
-  pWidget &p;
+  State& state;
+  pWidget& p;
 };
 
 struct Button : private nall::base_from_member<pButton&>, Widget {
   nall::function<void ()> onActivate;
 
-  void setImage(const nall::image &image = nall::image{}, Orientation = Orientation::Horizontal);
-  void setText(const nall::string &text);
+  void setImage(const nall::image& image = nall::image{}, Orientation = Orientation::Horizontal);
+  void setText(const nall::string& text);
 
   Button();
   ~Button();
   struct State;
-  State &state;
-  pButton &p;
+  State& state;
+  pButton& p;
 };
 
 struct Canvas : private nall::base_from_member<pCanvas&>, Widget {
@@ -415,16 +415,16 @@
   nall::function<void (Mouse::Button)> onMouseRelease;
 
   uint32_t* data();
-  bool setImage(const nall::image &image);
-  void setSize(const Size &size);
+  bool setImage(const nall::image& image);
+  void setSize(const Size& size);
   Size size();
   void update();
 
   Canvas();
   ~Canvas();
   struct State;
-  State &state;
-  pCanvas &p;
+  State& state;
+  pCanvas& p;
 };
 
 struct CheckButton : private nall::base_from_member<pCheckButton&>, Widget {
@@ -437,17 +437,17 @@
   CheckButton();
   ~CheckButton();
   struct State;
-  State &state;
-  pCheckButton &p;
+  State& state;
+  pCheckButton& p;
 };
 
 struct ComboButton : private nall::base_from_member<pComboButton&>, Widget {
   nall::function<void ()> onChange;
 
-  template<typename... Args> void append(const Args&... args) { append_({args...}); }
+  template<typename... Args> void append(Args&&... args) { append_({args...}); }
 
-  void append_(const nall::lstring &list);
-  void modify(unsigned row, const nall::string &text);
+  void append_(const nall::lstring& list);
+  void modify(unsigned row, const nall::string& text);
   void remove(unsigned row);
   void reset();
   unsigned selection();
@@ -458,8 +458,8 @@
   ComboButton();
   ~ComboButton();
   struct State;
-  State &state;
-  pComboButton &p;
+  State& state;
+  pComboButton& p;
 };
 
 struct HexEdit : private nall::base_from_member<pHexEdit&>, Widget {
@@ -475,8 +475,8 @@
   HexEdit();
   ~HexEdit();
   struct State;
-  State &state;
-  pHexEdit &p;
+  State& state;
+  pHexEdit& p;
 };
 
 struct HorizontalScroller : private nall::base_from_member<pHorizontalScroller&>, Widget {
@@ -490,8 +490,8 @@
   HorizontalScroller();
   ~HorizontalScroller();
   struct State;
-  State &state;
-  pHorizontalScroller &p;
+  State& state;
+  pHorizontalScroller& p;
 };
 
 struct HorizontalSlider : private nall::base_from_member<pHorizontalSlider&>, Widget {
@@ -505,18 +505,18 @@
   HorizontalSlider();
   ~HorizontalSlider();
   struct State;
-  State &state;
-  pHorizontalSlider &p;
+  State& state;
+  pHorizontalSlider& p;
 };
 
 struct Label : private nall::base_from_member<pLabel&>, Widget {
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
 
   Label();
   ~Label();
   struct State;
-  State &state;
-  pLabel &p;
+  State& state;
+  pLabel& p;
 };
 
 struct LineEdit : private nall::base_from_member<pLineEdit&>, Widget {
@@ -524,14 +524,14 @@
   nall::function<void ()> onChange;
 
   void setEditable(bool editable = true);
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
   nall::string text();
 
   LineEdit();
   ~LineEdit();
   struct State;
-  State &state;
-  pLineEdit &p;
+  State& state;
+  pLineEdit& p;
 };
 
 struct ListView : private nall::base_from_member<pListView&>, Widget {
@@ -539,31 +539,31 @@
   nall::function<void ()> onChange;
   nall::function<void (unsigned)> onToggle;
 
-  template<typename... Args> void append(const Args&... args) { append_({args...}); }
-  template<typename... Args> void modify(unsigned row, const Args&... args) { modify_(row, {args...}); }
-  template<typename... Args> void setHeaderText(const Args&... args) { setHeaderText_({args...}); }
+  template<typename... Args> void append(Args&&... args) { append_({args...}); }
+  template<typename... Args> void modify(unsigned row, Args&&... args) { modify_(row, {args...}); }
+  template<typename... Args> void setHeaderText(Args&&... args) { setHeaderText_({args...}); }
 
-  void append_(const nall::lstring &list);
+  void append_(const nall::lstring& list);
   void autoSizeColumns();
   bool checked(unsigned row);
-  void modify_(unsigned row, const nall::lstring &list);
+  void modify_(unsigned row, const nall::lstring& list);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable = true);
   void setChecked(unsigned row, bool checked = true);
-  void setHeaderText_(const nall::lstring &list);
+  void setHeaderText_(const nall::lstring& list);
   void setHeaderVisible(bool visible = true);
-  void setImage(unsigned row, unsigned column, const nall::image &image = nall::image{});
+  void setImage(unsigned row, unsigned column, const nall::image& image = nall::image{});
   void setSelected(bool selected = true);
   void setSelection(unsigned row);
 
   ListView();
   ~ListView();
   struct State;
-  State &state;
-  pListView &p;
+  State& state;
+  pListView& p;
 };
 
 struct ProgressBar : private nall::base_from_member<pProgressBar&>, Widget {
@@ -572,25 +572,25 @@
   ProgressBar();
   ~ProgressBar();
   struct State;
-  State &state;
-  pProgressBar &p;
+  State& state;
+  pProgressBar& p;
 };
 
 struct RadioButton : private nall::base_from_member<pRadioButton&>, Widget {
-  template<typename... Args> static void group(Args&... args) { group({args...}); }
-  static void group(const nall::group<RadioButton&> &list);
+  template<typename... Args> static void group(Args&&... args) { group({std::forward<Args>(args)...}); }
+  static void group(const nall::group<RadioButton>& list);
 
   nall::function<void ()> onActivate;
 
   bool checked();
   void setChecked();
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
 
   RadioButton();
   ~RadioButton();
   struct State;
-  State &state;
-  pRadioButton &p;
+  State& state;
+  pRadioButton& p;
 };
 
 struct TextEdit : private nall::base_from_member<pTextEdit&>, Widget {
@@ -598,7 +598,7 @@
 
   void setCursorPosition(unsigned position);
   void setEditable(bool editable = true);
-  void setText(const nall::string &text);
+  void setText(const nall::string& text);
   void setWordWrap(bool wordWrap = true);
   nall::string text();
   bool wordWrap();
@@ -606,8 +606,8 @@
   TextEdit();
   ~TextEdit();
   struct State;
-  State &state;
-  pTextEdit &p;
+  State& state;
+  pTextEdit& p;
 };
 
 struct VerticalScroller : private nall::base_from_member<pVerticalScroller&>, Widget {
@@ -621,8 +621,8 @@
   VerticalScroller();
   ~VerticalScroller();
   struct State;
-  State &state;
-  pVerticalScroller &p;
+  State& state;
+  pVerticalScroller& p;
 };
 
 struct VerticalSlider : private nall::base_from_member<pVerticalSlider&>, Widget {
@@ -636,8 +636,8 @@
   VerticalSlider();
   ~VerticalSlider();
   struct State;
-  State &state;
-  pVerticalSlider &p;
+  State& state;
+  pVerticalSlider& p;
 };
 
 struct Viewport : private nall::base_from_member<pViewport&>, Widget {
@@ -650,7 +650,7 @@
 
   Viewport();
   ~Viewport();
-  pViewport &p;
+  pViewport& p;
 };
 
 #include "layout/fixed-layout.hpp"
diff -ru higan_v092r07\phoenix\core\layout\fixed-layout.cpp higan_v092r08\phoenix\core\layout\fixed-layout.cpp
--- higan_v092r07\phoenix\core\layout\fixed-layout.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\fixed-layout.cpp	Thu May 02 05:48:04 2013
@@ -1,11 +1,11 @@
-void FixedLayout::append(Sizable &sizable, const Geometry &geometry) {
+void FixedLayout::append(Sizable& sizable, const Geometry& geometry) {
   children.append({&sizable, geometry});
   synchronizeLayout();
   if(window()) window()->synchronizeLayout();
 }
 
-void FixedLayout::append(Sizable &sizable) {
-  for(auto &child : children) if(child.sizable == &sizable) return;
+void FixedLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
   Layout::append(sizable);
   if(window()) window()->synchronizeLayout();
 }
@@ -17,14 +17,14 @@
 
 Size FixedLayout::minimumSize() {
   unsigned width = MinimumSize, height = MinimumSize;
-  for(auto &child : children) {
+  for(auto& child : children) {
     width  = max(width,  child.sizable->minimumSize().width);
     height = max(height, child.sizable->minimumSize().height);
   }
   return {width, height};
 }
 
-void FixedLayout::remove(Sizable &sizable) {
+void FixedLayout::remove(Sizable& sizable) {
   for(unsigned n = 0; n < children.size(); n++) {
     if(children[n].sizable == &sizable) {
       children.remove(n);
@@ -36,30 +36,30 @@
 }
 
 void FixedLayout::reset() {
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
   }
 }
 
 void FixedLayout::setEnabled(bool enabled) {
   state.enabled = enabled;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setVisible(dynamic_cast<Widget*>(child.sizable) ? child.sizable->enabled() : enabled);
   }
 }
 
-void FixedLayout::setGeometry(const Geometry &geometry) {
+void FixedLayout::setGeometry(const Geometry& geometry) {
 }
 
 void FixedLayout::setVisible(bool visible) {
   state.visible = visible;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setVisible(dynamic_cast<Widget*>(child.sizable) ? child.sizable->visible() : visible);
   }
 }
 
 void FixedLayout::synchronizeLayout() {
-  for(auto &child : children) {
+  for(auto& child : children) {
     Layout::append(*child.sizable);
     child.sizable->setGeometry(child.geometry);
   }
diff -ru higan_v092r07\phoenix\core\layout\fixed-layout.hpp higan_v092r08\phoenix\core\layout\fixed-layout.hpp
--- higan_v092r07\phoenix\core\layout\fixed-layout.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\fixed-layout.hpp	Thu May 02 05:48:04 2013
@@ -1,12 +1,12 @@
 struct FixedLayout : Layout {
-  void append(Sizable &sizable, const Geometry &geometry);
-  void append(Sizable &sizable);
+  void append(Sizable& sizable, const Geometry& geometry);
+  void append(Sizable& sizable);
   bool enabled();
   Size minimumSize();
-  void remove(Sizable &sizable);
+  void remove(Sizable& sizable);
   void reset();
   void setEnabled(bool enabled = true);
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setVisible(bool visible = true);
   void synchronizeLayout();
   bool visible();
@@ -20,7 +20,7 @@
   } state;
 
   struct Children {
-    Sizable *sizable;
+    Sizable* sizable;
     Geometry geometry;
   };
   nall::vector<Children> children;
diff -ru higan_v092r07\phoenix\core\layout\horizontal-layout.cpp higan_v092r08\phoenix\core\layout\horizontal-layout.cpp
--- higan_v092r07\phoenix\core\layout\horizontal-layout.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\horizontal-layout.cpp	Thu May 02 05:48:04 2013
@@ -1,12 +1,12 @@
-void HorizontalLayout::append(Sizable &sizable, const Size &size, unsigned spacing) {
-  for(auto &child : children) if(child.sizable == &sizable) return;
+void HorizontalLayout::append(Sizable& sizable, const Size& size, unsigned spacing) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
   children.append({&sizable, size.width, size.height, spacing});
   synchronizeLayout();
   if(window()) window()->synchronizeLayout();
 }
 
-void HorizontalLayout::append(Sizable &sizable) {
-  for(auto &child : children) if(child.sizable == &sizable) return;
+void HorizontalLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
   Layout::append(sizable);
   if(window()) window()->synchronizeLayout();
 }
@@ -19,7 +19,7 @@
 Size HorizontalLayout::minimumSize() {
   unsigned width = 0, height = 0;
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     width += child.spacing;
     if(child.width == MinimumSize || child.width == MaximumSize) {
       width += child.sizable->minimumSize().width;
@@ -28,7 +28,7 @@
     width += child.width;
   }
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.height == MinimumSize || child.height == MaximumSize) {
       height = max(height, child.sizable->minimumSize().height);
       continue;
@@ -39,7 +39,7 @@
   return {state.margin * 2 + width, state.margin * 2 + height};
 }
 
-void HorizontalLayout::remove(Sizable &sizable) {
+void HorizontalLayout::remove(Sizable& sizable) {
   for(unsigned n = 0; n < children.size(); n++) {
     if(children[n].sizable == &sizable) {
       if(dynamic_cast<Layout*>(children[n].sizable)) {
@@ -55,7 +55,7 @@
 }
 
 void HorizontalLayout::reset() {
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(window() && dynamic_cast<Layout*>(child.sizable)) ((Layout*)child.sizable)->reset();
     if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
   }
@@ -67,14 +67,14 @@
 
 void HorizontalLayout::setEnabled(bool enabled) {
   state.enabled = enabled;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setEnabled(dynamic_cast<Widget*>(child.sizable) ? child.sizable->enabled() : enabled);
   }
 }
 
-void HorizontalLayout::setGeometry(const Geometry &containerGeometry) {
+void HorizontalLayout::setGeometry(const Geometry& containerGeometry) {
   auto children = this->children;
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width  == MinimumSize) child.width  = child.sizable->minimumSize().width;
     if(child.height == MinimumSize) child.height = child.sizable->minimumSize().height;
   }
@@ -86,21 +86,21 @@
   geometry.height -= state.margin * 2;
 
   unsigned minimumWidth = 0, maximumWidthCounter = 0;
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width == MaximumSize) maximumWidthCounter++;
     if(child.width != MaximumSize) minimumWidth += child.width;
     minimumWidth += child.spacing;
   }
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width  == MaximumSize) child.width  = (geometry.width - minimumWidth) / maximumWidthCounter;
     if(child.height == MaximumSize) child.height = geometry.height;
   }
 
   unsigned maximumHeight = 0;
-  for(auto &child : children) maximumHeight = max(maximumHeight, child.height);
+  for(auto& child : children) maximumHeight = max(maximumHeight, child.height);
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     unsigned pivot = (maximumHeight - child.height) * state.alignment;
     Geometry childGeometry = {geometry.x, geometry.y + pivot, child.width, child.height};
     child.sizable->setGeometry(childGeometry);
@@ -116,13 +116,13 @@
 
 void HorizontalLayout::setVisible(bool visible) {
   state.visible = visible;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setVisible(dynamic_cast<Widget*>(child.sizable) ? child.sizable->visible() : visible);
   }
 }
 
 void HorizontalLayout::synchronizeLayout() {
-  for(auto &child : children) Layout::append(*child.sizable);
+  for(auto& child : children) Layout::append(*child.sizable);
 }
 
 bool HorizontalLayout::visible() {
diff -ru higan_v092r07\phoenix\core\layout\horizontal-layout.hpp higan_v092r08\phoenix\core\layout\horizontal-layout.hpp
--- higan_v092r07\phoenix\core\layout\horizontal-layout.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\horizontal-layout.hpp	Thu May 02 05:48:04 2013
@@ -1,13 +1,13 @@
 struct HorizontalLayout : public Layout {
-  void append(Sizable &sizable, const Size &size, unsigned spacing = 0);
-  void append(Sizable &sizable);
+  void append(Sizable& sizable, const Size& size, unsigned spacing = 0);
+  void append(Sizable& sizable);
   bool enabled();
   Size minimumSize();
-  void remove(Sizable &sizable);
+  void remove(Sizable& sizable);
   void reset();
   void setAlignment(double alignment);
   void setEnabled(bool enabled = true);
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setMargin(unsigned margin);
   void setVisible(bool visible = true);
   void synchronizeLayout();
@@ -24,7 +24,7 @@
   } state;
 
   struct Children {
-    Sizable *sizable;
+    Sizable* sizable;
     unsigned width, height, spacing;
   };
   nall::vector<Children> children;
diff -ru higan_v092r07\phoenix\core\layout\vertical-layout.cpp higan_v092r08\phoenix\core\layout\vertical-layout.cpp
--- higan_v092r07\phoenix\core\layout\vertical-layout.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\vertical-layout.cpp	Thu May 02 05:48:04 2013
@@ -1,12 +1,12 @@
-void VerticalLayout::append(Sizable &sizable, const Size &size, unsigned spacing) {
-  for(auto &child : children) if(child.sizable == &sizable) return;
+void VerticalLayout::append(Sizable& sizable, const Size& size, unsigned spacing) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
   children.append({&sizable, size.width, size.height, spacing});
   synchronizeLayout();
   if(window()) window()->synchronizeLayout();
 }
 
-void VerticalLayout::append(Sizable &sizable) {
-  for(auto &child : children) if(child.sizable == &sizable) return;
+void VerticalLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
   Layout::append(sizable);
   if(window()) window()->synchronizeLayout();
 }
@@ -19,7 +19,7 @@
 Size VerticalLayout::minimumSize() {
   unsigned width = 0, height = 0;
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width == MinimumSize || child.width == MaximumSize) {
       width = max(width, child.sizable->minimumSize().width);
       continue;
@@ -27,7 +27,7 @@
     width = max(width, child.width);
   }
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     height += child.spacing;
     if(child.height == MinimumSize || child.height == MaximumSize) {
       height += child.sizable->minimumSize().height;
@@ -39,7 +39,7 @@
   return {state.margin * 2 + width, state.margin * 2 + height};
 }
 
-void VerticalLayout::remove(Sizable &sizable) {
+void VerticalLayout::remove(Sizable& sizable) {
   for(unsigned n = 0; n < children.size(); n++) {
     if(children[n].sizable == &sizable) {
       if(dynamic_cast<Layout*>(children[n].sizable)) {
@@ -55,7 +55,7 @@
 }
 
 void VerticalLayout::reset() {
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(window() && dynamic_cast<Layout*>(child.sizable)) ((Layout*)child.sizable)->reset();
     if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
   }
@@ -67,14 +67,14 @@
 
 void VerticalLayout::setEnabled(bool enabled) {
   state.enabled = enabled;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setEnabled(dynamic_cast<Widget*>(child.sizable) ? child.sizable->enabled() : enabled);
   }
 }
 
-void VerticalLayout::setGeometry(const Geometry &containerGeometry) {
+void VerticalLayout::setGeometry(const Geometry& containerGeometry) {
   auto children = this->children;
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width  == MinimumSize) child.width  = child.sizable->minimumSize().width;
     if(child.height == MinimumSize) child.height = child.sizable->minimumSize().height;
   }
@@ -86,21 +86,21 @@
   geometry.height -= state.margin * 2;
 
   unsigned minimumHeight = 0, maximumHeightCounter = 0;
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.height == MaximumSize) maximumHeightCounter++;
     if(child.height != MaximumSize) minimumHeight += child.height;
     minimumHeight += child.spacing;
   }
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     if(child.width  == MaximumSize) child.width  = geometry.width;
     if(child.height == MaximumSize) child.height = (geometry.height - minimumHeight) / maximumHeightCounter;
   }
 
   unsigned maximumWidth = 0;
-  for(auto &child : children) maximumWidth = max(maximumWidth, child.width);
+  for(auto& child : children) maximumWidth = max(maximumWidth, child.width);
 
-  for(auto &child : children) {
+  for(auto& child : children) {
     unsigned pivot = (maximumWidth - child.width) * state.alignment;
     Geometry childGeometry = {geometry.x + pivot, geometry.y, child.width, child.height};
     child.sizable->setGeometry(childGeometry);
@@ -116,13 +116,13 @@
 
 void VerticalLayout::setVisible(bool visible) {
   state.visible = visible;
-  for(auto &child : children) {
+  for(auto& child : children) {
     child.sizable->setVisible(dynamic_cast<Widget*>(child.sizable) ? child.sizable->visible() : visible);
   }
 }
 
 void VerticalLayout::synchronizeLayout() {
-  for(auto &child : children) Layout::append(*child.sizable);
+  for(auto& child : children) Layout::append(*child.sizable);
 }
 
 bool VerticalLayout::visible() {
diff -ru higan_v092r07\phoenix\core\layout\vertical-layout.hpp higan_v092r08\phoenix\core\layout\vertical-layout.hpp
--- higan_v092r07\phoenix\core\layout\vertical-layout.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\layout\vertical-layout.hpp	Thu May 02 05:48:04 2013
@@ -1,13 +1,13 @@
 struct VerticalLayout : public Layout {
-  void append(Sizable &sizable, const Size &size, unsigned spacing = 0);
-  void append(Sizable &sizable);
+  void append(Sizable& sizable, const Size& size, unsigned spacing = 0);
+  void append(Sizable& sizable);
   bool enabled();
   Size minimumSize();
-  void remove(Sizable &sizable);
+  void remove(Sizable& sizable);
   void reset();
   void setAlignment(double alignment);
   void setEnabled(bool enabled = true);
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void setMargin(unsigned margin);
   void setVisible(bool visible = true);
   void synchronizeLayout();
@@ -24,7 +24,7 @@
   } state;
 
   struct Children {
-    Sizable *sizable;
+    Sizable* sizable;
     unsigned width, height, spacing;
   };
   nall::vector<Children> children;
diff -ru higan_v092r07\phoenix\core\state.hpp higan_v092r08\phoenix\core\state.hpp
--- higan_v092r07\phoenix\core\state.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\core\state.hpp	Thu May 02 05:48:04 2013
@@ -10,14 +10,14 @@
 
 struct BrowserWindow::State {
   lstring filters;
-  Window *parent = nullptr;
+  Window* parent = nullptr;
   string path;
   string title;
 };
 
 struct MessageWindow::State {
   MessageWindow::Buttons buttons = MessageWindow::Buttons::Ok;
-  Window *parent = nullptr;
+  Window* parent = nullptr;
   string text;
   string title;
 };
@@ -27,8 +27,8 @@
   Color backgroundColor = {0, 0, 0, 255};
   bool fullScreen = false;
   Geometry geometry = {128, 128, 256, 256};
-  group<Layout&> layout;
-  group<Menu&> menu;
+  group<Layout> layout;
+  group<Menu> menu;
   string menuFont;
   bool menuVisible = false;
   bool modal = false;
@@ -38,19 +38,19 @@
   bool statusVisible = false;
   string title;
   bool visible = false;
-  group<Widget&> widget;
+  group<Widget> widget;
   string widgetFont;
 };
 
 struct Action::State {
   bool enabled = true;
-  Menu *menu = nullptr;
+  Menu* menu = nullptr;
   bool visible = true;
-  Window *window = nullptr;
+  Window* window = nullptr;
 };
 
 struct Menu::State {
-  group<Action&> action;
+  group<Action> action;
   nall::image image = {0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0};
   string text;
 };
@@ -67,13 +67,13 @@
 
 struct RadioItem::State {
   bool checked = true;
-  nall::group<RadioItem&> group;
+  nall::group<RadioItem> group;
   string text;
 };
 
 struct Sizable::State {
-  Layout *layout = nullptr;
-  Window *window = nullptr;
+  Layout* layout = nullptr;
+  Window* window = nullptr;
 };
 
 struct Layout::State {
@@ -94,7 +94,7 @@
 };
 
 struct Canvas::State {
-  uint32_t *data = nullptr;
+  uint32_t* data = nullptr;
   unsigned width = 256;
   unsigned height = 256;
 };
@@ -152,7 +152,7 @@
 
 struct RadioButton::State {
   bool checked = true;
-  nall::group<RadioButton&> group;
+  nall::group<RadioButton> group;
   string text;
 };
 
diff -ru higan_v092r07\phoenix\gtk\action\action.cpp higan_v092r08\phoenix\gtk\action\action.cpp
--- higan_v092r07\phoenix\gtk\action\action.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\action\action.cpp	Thu May 02 05:48:04 2013
@@ -24,7 +24,7 @@
   return text;
 }
 
-void pAction::setFont(const string &font) {
+void pAction::setFont(const string& font) {
   pFont::setFont(widget, font);
 }
 
diff -ru higan_v092r07\phoenix\gtk\action\check-item.cpp higan_v092r08\phoenix\gtk\action\check-item.cpp
--- higan_v092r07\phoenix\gtk\action\check-item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\action\check-item.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void CheckItem_toggle(CheckItem *self) {
+static void CheckItem_toggle(CheckItem* self) {
   if(self->p.locked == false && self->onToggle) self->onToggle();
 }
 
@@ -14,7 +14,7 @@
   locked = false;
 }
 
-void pCheckItem::setText(const string &text) {
+void pCheckItem::setText(const string& text) {
   gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
 }
 
diff -ru higan_v092r07\phoenix\gtk\action\item.cpp higan_v092r08\phoenix\gtk\action\item.cpp
--- higan_v092r07\phoenix\gtk\action\item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\action\item.cpp	Thu May 02 05:48:04 2013
@@ -1,19 +1,19 @@
 namespace phoenix {
 
-static void Item_activate(Item *self) {
+static void Item_activate(Item* self) {
   if(self->onActivate) self->onActivate();
 }
 
-void pItem::setImage(const image &image) {
+void pItem::setImage(const image& image) {
   if(image.empty() == false) {
-    GtkImage *gtkImage = CreateImage(image, true);
+    GtkImage* gtkImage = CreateImage(image, true);
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
   } else {
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
   }
 }
 
-void pItem::setText(const string &text) {
+void pItem::setText(const string& text) {
   gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
 }
 
diff -ru higan_v092r07\phoenix\gtk\action\menu.cpp higan_v092r08\phoenix\gtk\action\menu.cpp
--- higan_v092r07\phoenix\gtk\action\menu.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\action\menu.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pMenu::append(Action &action) {
+void pMenu::append(Action& action) {
   action.state.window = this->action.state.window;
 
   gtk_menu_shell_append(GTK_MENU_SHELL(gtkMenu), action.p.widget);
@@ -10,21 +10,21 @@
   gtk_widget_show(action.p.widget);
 }
 
-void pMenu::remove(Action &action) {
+void pMenu::remove(Action& action) {
   action.p.orphan();
   action.state.window = nullptr;
 }
 
-void pMenu::setImage(const image &image) {
+void pMenu::setImage(const image& image) {
   if(image.empty() == false) {
-    GtkImage *gtkImage = CreateImage(image, true);
+    GtkImage* gtkImage = CreateImage(image, true);
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
   } else {
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
   }
 }
 
-void pMenu::setText(const string &text) {
+void pMenu::setText(const string& text) {
   gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
 }
 
@@ -41,15 +41,15 @@
 }
 
 void pMenu::orphan() {
-  for(auto &action : menu.state.action) action.p.orphan();
+  for(auto& action : menu.state.action) action.p.orphan();
   destructor();
   constructor();
-  for(auto &action : menu.state.action) append(action);
+  for(auto& action : menu.state.action) append(action);
 }
 
-void pMenu::setFont(const string &font) {
+void pMenu::setFont(const string& font) {
   pAction::setFont(font);
-  for(auto &item : menu.state.action) item.p.setFont(font);
+  for(auto& item : menu.state.action) item.p.setFont(font);
 }
 
 }
diff -ru higan_v092r07\phoenix\gtk\action\radio-item.cpp higan_v092r08\phoenix\gtk\action\radio-item.cpp
--- higan_v092r07\phoenix\gtk\action\radio-item.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\action\radio-item.cpp	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
-static void RadioItem_activate(RadioItem *self) {
-  for(auto &item : self->state.group) item.state.checked = (&item == self);
+static void RadioItem_activate(RadioItem* self) {
+  for(auto& item : self->state.group) item.state.checked = (&item == self);
   if(self->p.locked == false && self->checked() && self->onActivate) self->onActivate();
 }
 
@@ -11,22 +11,22 @@
 
 void pRadioItem::setChecked() {
   locked = true;
-  for(auto &item : radioItem.state.group) gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item.p.widget), false);
+  for(auto& item : radioItem.state.group) gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item.p.widget), false);
   gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widget), true);
   locked = false;
 }
 
-void pRadioItem::setGroup(const group<RadioItem&> &group) {
-  for(unsigned n = 0; n < group.size(); n++) {
-    if(n == 0) continue;
-    GSList *currentGroup = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(group[0].p.widget));
-    if(currentGroup != gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(group[n].p.widget))) {
-      gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(group[n].p.widget), currentGroup);
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+  for(auto& item : group) {
+    if(&item == &group.first()) continue;
+    GSList* currentGroup = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(group.first().p.widget));
+    if(currentGroup != gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(item.p.widget))) {
+      gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(item.p.widget), currentGroup);
     }
   }
 }
 
-void pRadioItem::setText(const string &text) {
+void pRadioItem::setText(const string& text) {
   gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
 }
 
@@ -34,7 +34,7 @@
   widget = gtk_radio_menu_item_new_with_mnemonic(0, "");
   setGroup(radioItem.state.group);
   setText(radioItem.state.text);
-  for(auto &item : radioItem.state.group) {
+  for(auto& item : radioItem.state.group) {
     gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item.p.widget), item.state.checked);
   }
   g_signal_connect_swapped(G_OBJECT(widget), "toggled", G_CALLBACK(RadioItem_activate), (gpointer)&radioItem);
diff -ru higan_v092r07\phoenix\gtk\application.cpp higan_v092r08\phoenix\gtk\application.cpp
--- higan_v092r07\phoenix\gtk\application.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\application.cpp	Thu May 02 05:48:04 2013
@@ -33,14 +33,12 @@
   settings->load();
 
   int argc = 1;
-  char *argv[2];
-  argv[0] = new char[8];
-  argv[1] = nullptr;
+  char* argv[] = {new char[8], nullptr};
   strcpy(argv[0], "phoenix");
-  char **argvp = argv;
+  char** argvp = argv;
   gtk_init(&argc, &argvp);
 
-  GtkSettings *gtkSettings = gtk_settings_get_default();
+  GtkSettings* gtkSettings = gtk_settings_get_default();
   g_object_set(gtkSettings, "gtk-button-images", true, nullptr);
 
   gtk_rc_parse_string(R"(
diff -ru higan_v092r07\phoenix\gtk\browser-window.cpp higan_v092r08\phoenix\gtk\browser-window.cpp
--- higan_v092r07\phoenix\gtk\browser-window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\browser-window.cpp	Thu May 02 05:48:04 2013
@@ -1,19 +1,19 @@
 namespace phoenix {
 
-static void BrowserWindow_addFilters(GtkWidget *dialog, lstring filters) {
-  for(auto &filter : filters) {
-    GtkFileFilter *gtkFilter = gtk_file_filter_new();
+static void BrowserWindow_addFilters(GtkWidget* dialog, lstring filters) {
+  for(auto& filter : filters) {
+    GtkFileFilter* gtkFilter = gtk_file_filter_new();
     gtk_file_filter_set_name(gtkFilter, filter);
     lstring patterns = filter.split<1>("(")(1).rtrim<1>(")").split(",");
-    for(auto &pattern : patterns) gtk_file_filter_add_pattern(gtkFilter, pattern.strip());
+    for(auto& pattern : patterns) gtk_file_filter_add_pattern(gtkFilter, pattern.strip());
     gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), gtkFilter);
   }
 }
 
-string pBrowserWindow::directory(BrowserWindow::State &state) {
+string pBrowserWindow::directory(BrowserWindow::State& state) {
   string name;
 
-  GtkWidget *dialog = gtk_file_chooser_dialog_new(
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
     state.title ? state.title : "Select Directory",
     state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
     GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
@@ -25,7 +25,7 @@
   if(state.path) gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), state.path);
 
   if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
-    char *temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
     name = temp;
     g_free(temp);
   }
@@ -35,10 +35,10 @@
   return name;
 }
 
-string pBrowserWindow::open(BrowserWindow::State &state) {
+string pBrowserWindow::open(BrowserWindow::State& state) {
   string name;
 
-  GtkWidget *dialog = gtk_file_chooser_dialog_new(
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
     state.title ? state.title : "Open File",
     state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
     GTK_FILE_CHOOSER_ACTION_OPEN,
@@ -51,7 +51,7 @@
   BrowserWindow_addFilters(dialog, state.filters);
 
   if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
-    char *temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
     name = temp;
     g_free(temp);
   }
@@ -60,10 +60,10 @@
   return name;
 }
 
-string pBrowserWindow::save(BrowserWindow::State &state) {
+string pBrowserWindow::save(BrowserWindow::State& state) {
   string name;
 
-  GtkWidget *dialog = gtk_file_chooser_dialog_new(
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
     state.title ? state.title : "Save File",
     state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
     GTK_FILE_CHOOSER_ACTION_SAVE,
@@ -76,7 +76,7 @@
   BrowserWindow_addFilters(dialog, state.filters);
 
   if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
-    char *temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
     name = temp;
     g_free(temp);
   }
diff -ru higan_v092r07\phoenix\gtk\desktop.cpp higan_v092r08\phoenix\gtk\desktop.cpp
--- higan_v092r07\phoenix\gtk\desktop.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\desktop.cpp	Thu May 02 05:48:04 2013
@@ -8,14 +8,14 @@
 }
 
 Geometry pDesktop::workspace() {
-  XlibDisplay *display = XOpenDisplay(nullptr);
+  XlibDisplay* display = XOpenDisplay(nullptr);
   int screen = DefaultScreen(display);
 
   static Atom atom = XlibNone;
   if(atom == XlibNone) atom = XInternAtom(display, "_NET_WORKAREA", True);
 
   int format;
-  unsigned char *data = nullptr;
+  unsigned char* data = nullptr;
   unsigned long items, after;
   Atom returnAtom;
 
@@ -27,7 +27,7 @@
 
   if(result == Success && returnAtom == XA_CARDINAL && format == 32 && items == 4) {
     unsigned long *workarea = (unsigned long*)data;
-    return { (signed)workarea[0], (signed)workarea[1], (unsigned)workarea[2], (unsigned)workarea[3] };
+    return {(signed)workarea[0], (signed)workarea[1], (unsigned)workarea[2], (unsigned)workarea[3]};
   }
 
   return {
diff -ru higan_v092r07\phoenix\gtk\font.cpp higan_v092r08\phoenix\gtk\font.cpp
--- higan_v092r07\phoenix\gtk\font.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\font.cpp	Thu May 02 05:48:04 2013
@@ -17,17 +17,17 @@
   return {"Liberation Mono, ", size, ", ", style};
 }
 
-Size pFont::size(const string &font, const string &text) {
-  PangoFontDescription *description = create(font);
+Size pFont::size(const string& font, const string& text) {
+  PangoFontDescription* description = create(font);
   Size size = pFont::size(description, text);
   free(description);
   return size;
 }
 
-PangoFontDescription* pFont::create(const string &description) {
+PangoFontDescription* pFont::create(const string& description) {
   lstring part;
   part.split<2>(",", description);
-  for(auto &item : part) item.trim(" ");
+  for(auto& item : part) item.trim(" ");
 
   string family = "Sans";
   unsigned size = 8u;
@@ -39,7 +39,7 @@
   if(part.size() >= 3) bold = part[2].position("Bold");
   if(part.size() >= 3) italic = part[2].position("Italic");
 
-  PangoFontDescription *font = pango_font_description_new();
+  PangoFontDescription* font = pango_font_description_new();
   pango_font_description_set_family(font, family);
   pango_font_description_set_size(font, size * PANGO_SCALE);
   pango_font_description_set_weight(font, !bold ? PANGO_WEIGHT_NORMAL : PANGO_WEIGHT_BOLD);
@@ -47,13 +47,13 @@
   return font;
 }
 
-void pFont::free(PangoFontDescription *font) {
+void pFont::free(PangoFontDescription* font) {
   pango_font_description_free(font);
 }
 
-Size pFont::size(PangoFontDescription *font, const string &text) {
-  PangoContext *context = gdk_pango_context_get_for_screen(gdk_screen_get_default());
-  PangoLayout *layout = pango_layout_new(context);
+Size pFont::size(PangoFontDescription* font, const string& text) {
+  PangoContext* context = gdk_pango_context_get_for_screen(gdk_screen_get_default());
+  PangoLayout* layout = pango_layout_new(context);
   pango_layout_set_font_description(layout, font);
   pango_layout_set_text(layout, text, -1);
   int width = 0, height = 0;
@@ -62,13 +62,13 @@
   return {width, height};
 }
 
-void pFont::setFont(GtkWidget *widget, const string &font) {
+void pFont::setFont(GtkWidget* widget, const string& font) {
   auto gtkFont = pFont::create(font);
   pFont::setFont(widget, (gpointer)gtkFont);
   pFont::free(gtkFont);
 }
 
-void pFont::setFont(GtkWidget *widget, gpointer font) {
+void pFont::setFont(GtkWidget* widget, gpointer font) {
   if(font == nullptr) return;
   gtk_widget_modify_font(widget, (PangoFontDescription*)font);
   if(GTK_IS_CONTAINER(widget)) {
diff -ru higan_v092r07\phoenix\gtk\keyboard.cpp higan_v092r08\phoenix\gtk\keyboard.cpp
--- higan_v092r07\phoenix\gtk\keyboard.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\keyboard.cpp	Thu May 02 05:48:04 2013
@@ -123,20 +123,23 @@
 bool pKeyboard::pressed(Keyboard::Scancode scancode) {
   char state[256];
   XQueryKeymap(pApplication::display, state);
-  unsigned id = settings->keymap.lhs[scancode];
-  return state[id >> 3] & (1 << (id & 7));
+  if(auto result = settings->keymap.find(scancode)) {
+    unsigned id = result();
+    return state[id >> 3] & (1 << (id & 7));
+  }
+  return false;
 }
 
 vector<bool> pKeyboard::state() {
   vector<bool> output;
   output.resize((unsigned)Keyboard::Scancode::Limit);
-  for(auto &n : output) n = false;
+  for(auto& n : output) n = false;
 
   char state[256];
   XQueryKeymap(pApplication::display, state);
-  for(auto &n : settings->keymap.rhs) {
-    if(state[n.name >> 3] & (1 << (n.name & 7))) {
-      output[(unsigned)n.data] = true;
+  for(auto node : settings->keymap) {
+    if(state[node.value >> 3] & (1 << (node.value & 7))) {
+      output[(unsigned)node.key] = true;
     }
   }
 
diff -ru higan_v092r07\phoenix\gtk\message-window.cpp higan_v092r08\phoenix\gtk\message-window.cpp
--- higan_v092r07\phoenix\gtk\message-window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\message-window.cpp	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
-static MessageWindow::Response Message(MessageWindow::State &state, GtkMessageType messageStyle) {
-  GtkWidget *dialog = gtk_message_dialog_new(
+static MessageWindow::Response Message(MessageWindow::State& state, GtkMessageType messageStyle) {
+  GtkWidget* dialog = gtk_message_dialog_new(
     state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
     GTK_DIALOG_MODAL, messageStyle, GTK_BUTTONS_NONE, "%s", (const char*)state.text
   );
@@ -41,19 +41,19 @@
   throw;
 }
 
-MessageWindow::Response pMessageWindow::error(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
   return Message(state, GTK_MESSAGE_ERROR);
 }
 
-MessageWindow::Response pMessageWindow::information(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
   return Message(state, GTK_MESSAGE_INFO);
 }
 
-MessageWindow::Response pMessageWindow::question(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
   return Message(state, GTK_MESSAGE_QUESTION);
 }
 
-MessageWindow::Response pMessageWindow::warning(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
   return Message(state, GTK_MESSAGE_WARNING);
 }
 
diff -ru higan_v092r07\phoenix\gtk\platform.hpp higan_v092r08\phoenix\gtk\platform.hpp
--- higan_v092r07\phoenix\gtk\platform.hpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\platform.hpp	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
 struct pApplication {
-  static XlibDisplay *display;
+  static XlibDisplay* display;
 
   static void run();
   static bool pendingEvents();
@@ -12,7 +12,7 @@
 };
 
 struct Settings : Configuration::Document {
-  bidirectional_map<Keyboard::Scancode, unsigned> keymap;
+  bimap<Keyboard::Scancode, unsigned> keymap;
 
   struct Geometry : Configuration::Node {
     unsigned frameX;
@@ -41,13 +41,13 @@
   static string serif(unsigned size, string style);
   static string sans(unsigned size, string style);
   static string monospace(unsigned size, string style);
-  static Size size(const string &font, const string &text);
+  static Size size(const string& font, const string& text);
 
-  static PangoFontDescription* create(const string &description);
-  static void free(PangoFontDescription *font);
-  static Size size(PangoFontDescription *font, const string &text);
-  static void setFont(GtkWidget *widget, const string &font);
-  static void setFont(GtkWidget *widget, gpointer font);
+  static PangoFontDescription* create(const string& description);
+  static void free(PangoFontDescription* font);
+  static Size size(PangoFontDescription* font, const string& text);
+  static void setFont(GtkWidget* widget, const string& font);
+  static void setFont(GtkWidget* widget, gpointer font);
 };
 
 struct pDesktop {
@@ -68,23 +68,23 @@
 };
 
 struct pBrowserWindow {
-  static string directory(BrowserWindow::State &state);
-  static string open(BrowserWindow::State &state);
-  static string save(BrowserWindow::State &state);
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
 };
 
 struct pMessageWindow {
-  static MessageWindow::Response error(MessageWindow::State &state);
-  static MessageWindow::Response information(MessageWindow::State &state);
-  static MessageWindow::Response question(MessageWindow::State &state);
-  static MessageWindow::Response warning(MessageWindow::State &state);
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
 };
 
 struct pObject {
-  Object &object;
+  Object& object;
   bool locked;
 
-  pObject(Object &object) : object(object), locked(false) {}
+  pObject(Object& object) : object(object), locked(false) {}
   virtual ~pObject() {}
 
   void constructor() {}
@@ -92,67 +92,67 @@
 };
 
 struct pTimer : public pObject {
-  Timer &timer;
+  Timer& timer;
 
   void setEnabled(bool enabled);
   void setInterval(unsigned milliseconds);
 
-  pTimer(Timer &timer) : pObject(timer), timer(timer) {}
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
   void constructor();
 };
 
 struct pWindow : public pObject {
-  Window &window;
-  GtkWidget *widget;
-  GtkWidget *menuContainer;
-  GtkWidget *formContainer;
-  GtkWidget *statusContainer;
-  GtkWidget *menu;
-  GtkWidget *status;
+  Window& window;
+  GtkWidget* widget;
+  GtkWidget* menuContainer;
+  GtkWidget* formContainer;
+  GtkWidget* statusContainer;
+  GtkWidget* menu;
+  GtkWidget* status;
   GtkAllocation lastAllocation;
   bool onSizePending;
 
   static Window& none();
 
-  void append(Layout &layout);
-  void append(Menu &menu);
-  void append(Widget &widget);
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
   Color backgroundColor();
   bool focused();
   Geometry frameMargin();
   Geometry geometry();
-  void remove(Layout &layout);
-  void remove(Menu &menu);
-  void remove(Widget &widget);
-  void setBackgroundColor(const Color &color);
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(const Color& color);
   void setFocused();
   void setFullScreen(bool fullScreen);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const string& font);
   void setMenuVisible(bool visible);
   void setModal(bool modal);
   void setResizable(bool resizable);
-  void setStatusFont(const string &font);
-  void setStatusText(const string &text);
+  void setStatusFont(const string& font);
+  void setStatusText(const string& text);
   void setStatusVisible(bool visible);
-  void setTitle(const string &text);
+  void setTitle(const string& text);
   void setVisible(bool visible);
-  void setWidgetFont(const string &font);
+  void setWidgetFont(const string& font);
 
-  pWindow(Window &window) : pObject(window), window(window) {}
+  pWindow(Window& window) : pObject(window), window(window) {}
   void constructor();
   unsigned menuHeight();
   unsigned statusHeight();
 };
 
 struct pAction : public pObject {
-  Action &action;
-  GtkWidget *widget;
+  Action& action;
+  GtkWidget* widget;
 
   void setEnabled(bool enabled);
   void setVisible(bool visible);
 
-  pAction(Action &action) : pObject(action), action(action) {}
+  pAction(Action& action) : pObject(action), action(action) {}
   void constructor();
   virtual void orphan();
   string mnemonic(string text);
@@ -160,165 +160,165 @@
 };
 
 struct pMenu : public pAction {
-  Menu &menu;
-  GtkWidget *gtkMenu;
+  Menu& menu;
+  GtkWidget* gtkMenu;
 
-  void append(Action &action);
-  void remove(Action &action);
-  void setImage(const image &image);
-  void setText(const string &text);
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(const string& text);
 
   pMenu(Menu &menu) : pAction(menu), menu(menu) {}
   void constructor();
   void destructor();
   void orphan();
-  void setFont(const string &font);
+  void setFont(const string& font);
 };
 
 struct pSeparator : public pAction {
-  Separator &separator;
+  Separator& separator;
 
-  pSeparator(Separator &separator) : pAction(separator), separator(separator) {}
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pItem : public pAction {
-  Item &item;
+  Item& item;
 
-  void setImage(const image &image);
-  void setText(const string &text);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pItem(Item &item) : pAction(item), item(item) {}
+  pItem(Item& item) : pAction(item), item(item) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pCheckItem : public pAction {
-  CheckItem &checkItem;
+  CheckItem& checkItem;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckItem(CheckItem &checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pRadioItem : public pAction {
-  RadioItem &radioItem;
+  RadioItem& radioItem;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioItem&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioItem>& group);
+  void setText(const string& text);
 
-  pRadioItem(RadioItem &radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pSizable : public pObject {
-  Sizable &sizable;
+  Sizable& sizable;
 
   pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
 };
 
 struct pLayout : public pSizable {
-  Layout &layout;
+  Layout& layout;
 
-  pLayout(Layout &layout) : pSizable(layout), layout(layout) {}
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
 };
 
 struct pWidget : public pSizable {
-  Widget &widget;
-  GtkWidget *gtkWidget;
+  Widget& widget;
+  GtkWidget* gtkWidget;
 
   bool enabled();
   virtual bool focused();
   virtual Size minimumSize();
   void setEnabled(bool enabled);
   virtual void setFocused();
-  virtual void setFont(const string &font);
-  virtual void setGeometry(const Geometry &geometry);
+  virtual void setFont(const string& font);
+  virtual void setGeometry(const Geometry& geometry);
   void setVisible(bool visible);
 
-  pWidget(Widget &widget) : pSizable(widget), widget(widget) {}
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
   void constructor();
   void destructor();
   virtual void orphan();
 };
 
 struct pButton : public pWidget {
-  Button &button;
+  Button& button;
 
   Size minimumSize();
-  void setImage(const image &image, Orientation orientation);
-  void setText(const string &text);
+  void setImage(const image& image, Orientation orientation);
+  void setText(const string& text);
 
-  pButton(Button &button) : pWidget(button), button(button) {}
+  pButton(Button& button) : pWidget(button), button(button) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pCanvas : public pWidget {
-  Canvas &canvas;
-  cairo_surface_t *surface;
+  Canvas& canvas;
+  cairo_surface_t* surface;
 
-  void setSize(const Size &size);
+  void setSize(const Size& size);
   void update();
 
-  pCanvas(Canvas &canvas) : pWidget(canvas), canvas(canvas) {}
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pCheckButton : public pWidget {
-  CheckButton &checkButton;
+  CheckButton& checkButton;
 
   bool checked();
   Size minimumSize();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckButton(CheckButton &checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pComboButton : public pWidget {
-  ComboButton &comboButton;
+  ComboButton& comboButton;
   unsigned itemCounter;
 
-  void append(const string &text);
-  void modify(unsigned row, const string &text);
+  void append(const string& text);
+  void modify(unsigned row, const string& text);
   void remove(unsigned row);
   Size minimumSize();
   void reset();
   unsigned selection();
   void setSelection(unsigned row);
 
-  pComboButton(ComboButton &comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pHexEdit : public pWidget {
-  HexEdit &hexEdit;
-  GtkWidget *container;
-  GtkWidget *subWidget;
-  GtkWidget *scrollBar;
-  GtkTextBuffer *textBuffer;
-  GtkTextMark *textCursor;
+  HexEdit& hexEdit;
+  GtkWidget* container;
+  GtkWidget* subWidget;
+  GtkWidget* scrollBar;
+  GtkTextBuffer* textBuffer;
+  GtkTextMark* textCursor;
 
   bool focused();
   void setColumns(unsigned columns);
@@ -327,7 +327,7 @@
   void setRows(unsigned rows);
   void update();
 
-  pHexEdit(HexEdit &hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
   void constructor();
   void destructor();
   void orphan();
@@ -340,117 +340,119 @@
 };
 
 struct pHorizontalScroller : public pWidget {
-  HorizontalScroller &horizontalScroller;
+  HorizontalScroller& horizontalScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalScroller(HorizontalScroller &horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pHorizontalSlider : public pWidget {
-  HorizontalSlider &horizontalSlider;
+  HorizontalSlider& horizontalSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalSlider(HorizontalSlider &horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pLabel : public pWidget {
-  Label &label;
+  Label& label;
 
   Size minimumSize();
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pLabel(Label &label) : pWidget(label), label(label) {}
+  pLabel(Label& label) : pWidget(label), label(label) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pLineEdit : public pWidget {
-  LineEdit &lineEdit;
+  LineEdit& lineEdit;
 
   Size minimumSize();
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   string text();
 
-  pLineEdit(LineEdit &lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pListView : public pWidget {
-  ListView &listView;
-  GtkWidget *subWidget;
-  GtkListStore *store;
+  ListView& listView;
+  GtkWidget* subWidget;
+  GtkListStore* store;
   struct GtkColumn {
-    GtkTreeViewColumn *column;
-    GtkCellRenderer *checkbutton, *icon, *text;
+    GtkTreeViewColumn* column;
+    GtkCellRenderer* checkbutton;
+    GtkCellRenderer* icon;
+    GtkCellRenderer* text;
     GtkWidget *label;
   };
   vector<GtkColumn> column;
 
-  void append(const lstring &text);
+  void append(const lstring& text);
   void autoSizeColumns();
   bool checked(unsigned row);
   bool focused();
-  void modify(unsigned row, const lstring &text);
+  void modify(unsigned row, const lstring& text);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable);
   void setChecked(unsigned row, bool checked);
-  void setHeaderText(const lstring &text);
+  void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
-  void setImage(unsigned row, unsigned column, const nall::image &image);
+  void setImage(unsigned row, unsigned column, const nall::image& image);
   void setSelected(bool selected);
   void setSelection(unsigned row);
 
-  pListView(ListView &listView) : pWidget(listView), listView(listView) {}
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
   void constructor();
   void destructor();
   void orphan();
   void setFocused();
-  void setFont(const string &font);
+  void setFont(const string& font);
 };
 
 struct pProgressBar : public pWidget {
-  ProgressBar &progressBar;
+  ProgressBar& progressBar;
 
   Size minimumSize();
   void setPosition(unsigned position);
 
-  pProgressBar(ProgressBar &progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pRadioButton : public pWidget {
-  RadioButton &radioButton;
+  RadioButton& radioButton;
 
   bool checked();
   Size minimumSize();
   void setChecked();
-  void setGroup(const group<RadioButton&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioButton>& group);
+  void setText(const string& text);
 
-  pRadioButton(RadioButton &radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
   void onActivate();
   pRadioButton& parent();
   void constructor();
@@ -459,57 +461,57 @@
 };
 
 struct pTextEdit : public pWidget {
-  TextEdit &textEdit;
-  GtkWidget *subWidget;
-  GtkTextBuffer *textBuffer;
+  TextEdit& textEdit;
+  GtkWidget* subWidget;
+  GtkTextBuffer* textBuffer;
 
   bool focused();
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   void setWordWrap(bool wordWrap);
   string text();
 
-  pTextEdit(TextEdit &textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pVerticalScroller : public pWidget {
-  VerticalScroller &verticalScroller;
+  VerticalScroller& verticalScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalScroller(VerticalScroller &verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pVerticalSlider : public pWidget {
-  VerticalSlider &verticalSlider;
+  VerticalSlider& verticalSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalSlider(VerticalSlider &verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pViewport : public pWidget {
-  Viewport &viewport;
+  Viewport& viewport;
 
   uintptr_t handle();
 
-  pViewport(Viewport &viewport) : pWidget(viewport), viewport(viewport) {}
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
   void constructor();
   void destructor();
   void orphan();
diff -ru higan_v092r07\phoenix\gtk\settings.cpp higan_v092r08\phoenix\gtk\settings.cpp
--- higan_v092r07\phoenix\gtk\settings.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\settings.cpp	Thu May 02 05:48:04 2013
@@ -1,17 +1,16 @@
 namespace phoenix {
 
-static Settings *settings = nullptr;
+static Settings* settings = nullptr;
 
 void Settings::load() {
-  string path = {userpath(), ".config/phoenix/gtk.bml"};
-  Configuration::Document::load(path);
+  string path = {userpath(), ".config/phoenix/"};
+  Configuration::Document::load({path, "gtk.bml"});
 }
 
 void Settings::save() {
   string path = {userpath(), ".config/phoenix/"};
   directory::create(path, 0755);
-  path.append("gtk.bml");
-  Configuration::Document::save(path);
+  Configuration::Document::save({path, "gtk.bml"});
 }
 
 Settings::Settings() {
diff -ru higan_v092r07\phoenix\gtk\timer.cpp higan_v092r08\phoenix\gtk\timer.cpp
--- higan_v092r07\phoenix\gtk\timer.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\timer.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static guint Timer_trigger(pTimer *self) {
+static guint Timer_trigger(pTimer* self) {
   //timer may have been disabled prior to triggering, so check state
   if(self->timer.state.enabled) {
     if(self->timer.onActivate) self->timer.onActivate();
diff -ru higan_v092r07\phoenix\gtk\utility.cpp higan_v092r08\phoenix\gtk\utility.cpp
--- higan_v092r07\phoenix\gtk\utility.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\utility.cpp	Thu May 02 05:48:04 2013
@@ -1,19 +1,19 @@
 namespace phoenix {
 
-static GdkPixbuf* CreatePixbuf(const nall::image &image, bool scale = false) {
+static GdkPixbuf* CreatePixbuf(const nall::image& image, bool scale = false) {
   nall::image gdkImage = image;
   gdkImage.transform(0, 32, 255u << 24, 255u << 0, 255u << 8, 255u << 16);
   if(scale) gdkImage.scale(15, 15, Interpolation::Linear);
 
-  GdkPixbuf *pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, gdkImage.width, gdkImage.height);
+  GdkPixbuf* pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, gdkImage.width, gdkImage.height);
   memcpy(gdk_pixbuf_get_pixels(pixbuf), gdkImage.data, gdkImage.width * gdkImage.height * 4);
 
   return pixbuf;
 }
 
-static GtkImage* CreateImage(const nall::image &image, bool scale = false) {
-  GdkPixbuf *pixbuf = CreatePixbuf(image, scale);
-  GtkImage *gtkImage = (GtkImage*)gtk_image_new_from_pixbuf(pixbuf);
+static GtkImage* CreateImage(const nall::image& image, bool scale = false) {
+  GdkPixbuf* pixbuf = CreatePixbuf(image, scale);
+  GtkImage* gtkImage = (GtkImage*)gtk_image_new_from_pixbuf(pixbuf);
   g_object_unref(pixbuf);
   return gtkImage;
 }
diff -ru higan_v092r07\phoenix\gtk\widget\button.cpp higan_v092r08\phoenix\gtk\widget\button.cpp
--- higan_v092r07\phoenix\gtk\widget\button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\button.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void Button_activate(Button *self) {
+static void Button_activate(Button* self) {
   if(self->onActivate) self->onActivate();
 }
 
@@ -20,9 +20,9 @@
   return {size.width + 24, size.height + 12};
 }
 
-void pButton::setImage(const image &image, Orientation orientation) {
+void pButton::setImage(const image& image, Orientation orientation) {
   if(image.empty() == false) {
-    GtkImage *gtkImage = CreateImage(image);
+    GtkImage* gtkImage = CreateImage(image);
     gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
   } else {
     gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
@@ -33,7 +33,7 @@
   }
 }
 
-void pButton::setText(const string &text) {
+void pButton::setText(const string& text) {
   gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
   setFont(widget.state.font);
 }
diff -ru higan_v092r07\phoenix\gtk\widget\canvas.cpp higan_v092r08\phoenix\gtk\widget\canvas.cpp
--- higan_v092r07\phoenix\gtk\widget\canvas.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\canvas.cpp	Thu May 02 05:48:04 2013
@@ -1,24 +1,24 @@
 namespace phoenix {
 
-static gboolean Canvas_expose(GtkWidget *widget, GdkEvent *event, pCanvas *self) {
-  cairo_t *context = gdk_cairo_create(gtk_widget_get_window(widget));
+static gboolean Canvas_expose(GtkWidget* widget, GdkEvent* event, pCanvas* self) {
+  cairo_t* context = gdk_cairo_create(gtk_widget_get_window(widget));
   cairo_set_source_surface(context, self->surface, 0, 0);
   cairo_paint(context);
   cairo_destroy(context);
   return true;
 }
 
-static gboolean Canvas_mouseLeave(GtkWidget *widget, GdkEventButton *event, pCanvas *self) {
+static gboolean Canvas_mouseLeave(GtkWidget* widget, GdkEventButton* event, pCanvas* self) {
   if(self->canvas.onMouseLeave) self->canvas.onMouseLeave();
   return true;
 }
 
-static gboolean Canvas_mouseMove(GtkWidget *widget, GdkEventButton *event, pCanvas *self) {
-  if(self->canvas.onMouseMove) self->canvas.onMouseMove({ (signed)event->x, (signed)event->y });
+static gboolean Canvas_mouseMove(GtkWidget* widget, GdkEventButton* event, pCanvas* self) {
+  if(self->canvas.onMouseMove) self->canvas.onMouseMove({(signed)event->x, (signed)event->y});
   return true;
 }
 
-static gboolean Canvas_mousePress(GtkWidget *widget, GdkEventButton *event, pCanvas *self) {
+static gboolean Canvas_mousePress(GtkWidget* widget, GdkEventButton* event, pCanvas* self) {
   if(self->canvas.onMousePress) switch(event->button) {
   case 1: self->canvas.onMousePress(Mouse::Button::Left); break;
   case 2: self->canvas.onMousePress(Mouse::Button::Middle); break;
@@ -27,7 +27,7 @@
   return true;
 }
 
-static gboolean Canvas_mouseRelease(GtkWidget *widget, GdkEventButton *event, pCanvas *self) {
+static gboolean Canvas_mouseRelease(GtkWidget* widget, GdkEventButton* event, pCanvas* self) {
   if(self->canvas.onMouseRelease) switch(event->button) {
   case 1: self->canvas.onMouseRelease(Mouse::Button::Left); break;
   case 2: self->canvas.onMouseRelease(Mouse::Button::Middle); break;
@@ -36,7 +36,7 @@
   return true;
 }
 
-void pCanvas::setSize(const Size &size) {
+void pCanvas::setSize(const Size& size) {
   cairo_surface_destroy(surface);
   surface = cairo_image_surface_create(CAIRO_FORMAT_RGB24, canvas.state.width, canvas.state.height);
 }
diff -ru higan_v092r07\phoenix\gtk\widget\check-button.cpp higan_v092r08\phoenix\gtk\widget\check-button.cpp
--- higan_v092r07\phoenix\gtk\widget\check-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\check-button.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void CheckButton_toggle(CheckButton *self) {
+static void CheckButton_toggle(CheckButton* self) {
   self->state.checked = self->checked();
   if(self->p.locked == false && self->onToggle) self->onToggle();
 }
@@ -20,7 +20,7 @@
   locked = false;
 }
 
-void pCheckButton::setText(const string &text) {
+void pCheckButton::setText(const string& text) {
   gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
 }
 
diff -ru higan_v092r07\phoenix\gtk\widget\combo-button.cpp higan_v092r08\phoenix\gtk\widget\combo-button.cpp
--- higan_v092r07\phoenix\gtk\widget\combo-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\combo-button.cpp	Thu May 02 05:48:04 2013
@@ -1,26 +1,26 @@
 namespace phoenix {
 
-static void ComboButton_change(ComboButton *self) {
+static void ComboButton_change(ComboButton* self) {
   if(self->p.locked == false) {
     self->state.selection = self->selection();
     if(self->onChange) self->onChange();
   }
 }
 
-void pComboButton::append(const string &text) {
+void pComboButton::append(const string& text) {
   gtk_combo_box_append_text(GTK_COMBO_BOX(gtkWidget), text);
   if(itemCounter++ == 0) setSelection(0);
 }
 
 Size pComboButton::minimumSize() {
   unsigned maximumWidth = 0;
-  for(auto &item : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(widget.state.font, item).width);
+  for(auto& item : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(widget.state.font, item).width);
 
   Size size = pFont::size(widget.state.font, " ");
   return {maximumWidth + 44, size.height + 12};
 }
 
-void pComboButton::modify(unsigned row, const string &text) {
+void pComboButton::modify(unsigned row, const string& text) {
   locked = true;
   unsigned position = selection();
   gtk_combo_box_remove_text(GTK_COMBO_BOX(gtkWidget), row);
@@ -60,7 +60,7 @@
   g_signal_connect_swapped(G_OBJECT(gtkWidget), "changed", G_CALLBACK(ComboButton_change), (gpointer)&comboButton);
 
   locked = true;
-  for(auto &text : comboButton.state.text) append(text);
+  for(auto& text : comboButton.state.text) append(text);
   locked = false;
   setSelection(comboButton.state.selection);
 }
diff -ru higan_v092r07\phoenix\gtk\widget\hex-edit.cpp higan_v092r08\phoenix\gtk\widget\hex-edit.cpp
--- higan_v092r07\phoenix\gtk\widget\hex-edit.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\hex-edit.cpp	Thu May 02 05:48:04 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
-static bool HexEdit_keyPress(GtkWidget *widget, GdkEventKey *event, HexEdit *self) {
+static bool HexEdit_keyPress(GtkWidget* widget, GdkEventKey* event, HexEdit* self) {
   return self->p.keyPress(event->keyval);
 }
 
-static bool HexEdit_scroll(GtkRange *range, GtkScrollType scroll, gdouble value, HexEdit *self) {
+static bool HexEdit_scroll(GtkRange* range, GtkScrollType scroll, gdouble value, HexEdit* self) {
   self->p.scroll((unsigned)value);
   return false;
 }
diff -ru higan_v092r07\phoenix\gtk\widget\horizontal-scroller.cpp higan_v092r08\phoenix\gtk\widget\horizontal-scroller.cpp
--- higan_v092r07\phoenix\gtk\widget\horizontal-scroller.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\horizontal-scroller.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void HorizontalScroller_change(HorizontalScroller *self) {
+static void HorizontalScroller_change(HorizontalScroller* self) {
   if(self->state.position == self->position()) return;
   self->state.position = self->position();
   if(self->p.locked == false && self->onChange) self->onChange();
diff -ru higan_v092r07\phoenix\gtk\widget\horizontal-slider.cpp higan_v092r08\phoenix\gtk\widget\horizontal-slider.cpp
--- higan_v092r07\phoenix\gtk\widget\horizontal-slider.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\horizontal-slider.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void HorizontalSlider_change(HorizontalSlider *self) {
+static void HorizontalSlider_change(HorizontalSlider* self) {
   if(self->state.position == self->position()) return;
   self->state.position = self->position();
   if(self->onChange) self->onChange();
diff -ru higan_v092r07\phoenix\gtk\widget\label.cpp higan_v092r08\phoenix\gtk\widget\label.cpp
--- higan_v092r07\phoenix\gtk\widget\label.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\label.cpp	Thu May 02 05:48:04 2013
@@ -5,7 +5,7 @@
   return {size.width, size.height};
 }
 
-void pLabel::setText(const string &text) {
+void pLabel::setText(const string& text) {
   gtk_label_set_text(GTK_LABEL(gtkWidget), text);
 }
 
diff -ru higan_v092r07\phoenix\gtk\widget\line-edit.cpp higan_v092r08\phoenix\gtk\widget\line-edit.cpp
--- higan_v092r07\phoenix\gtk\widget\line-edit.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\line-edit.cpp	Thu May 02 05:48:04 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
-static void LineEdit_activate(LineEdit *self) {
+static void LineEdit_activate(LineEdit* self) {
   if(self->onActivate) self->onActivate();
 }
 
-static void LineEdit_change(LineEdit *self) {
+static void LineEdit_change(LineEdit* self) {
   self->state.text = self->text();
   if(self->p.locked == false && self->onChange) self->onChange();
 }
@@ -18,7 +18,7 @@
   gtk_editable_set_editable(GTK_EDITABLE(gtkWidget), editable);
 }
 
-void pLineEdit::setText(const string &text) {
+void pLineEdit::setText(const string& text) {
   locked = true;
   gtk_entry_set_text(GTK_ENTRY(gtkWidget), text);
   locked = false;
diff -ru higan_v092r07\phoenix\gtk\widget\list-view.cpp higan_v092r08\phoenix\gtk\widget\list-view.cpp
--- higan_v092r07\phoenix\gtk\widget\list-view.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\list-view.cpp	Thu May 02 05:48:04 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
-static void ListView_activate(ListView *self) {
+static void ListView_activate(ListView* self) {
   if(self->onActivate) self->onActivate();
 }
 
-static void ListView_change(ListView *self) {
+static void ListView_change(ListView* self) {
   if(self->state.selected == false || self->state.selection != self->selection()) {
     self->state.selected = true;
     self->state.selection = self->selection();
@@ -12,13 +12,13 @@
   }
 }
 
-static void ListView_toggle(GtkCellRendererToggle *cell, gchar *path, ListView *self) {
+static void ListView_toggle(GtkCellRendererToggle* cell, gchar* path, ListView* self) {
   unsigned row = decimal(path);
   self->setChecked(row, !self->checked(row));
   if(self->onToggle) self->onToggle(row);
 }
 
-void pListView::append(const lstring &text) {
+void pListView::append(const lstring& text) {
   GtkTreeIter iter;
   gtk_list_store_append(store, &iter);
   for(unsigned n = 0; n < text.size(); n++) gtk_list_store_set(store, &iter, 1 + n * 2 + 1, (const char*)text[n], -1);
@@ -29,7 +29,7 @@
 }
 
 bool pListView::checked(unsigned row) {
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   bool state;
   if(gtk_tree_model_get_iter_from_string(model, &iter, string(row)) == false) return false;
@@ -41,15 +41,15 @@
   return GTK_WIDGET_HAS_FOCUS(subWidget);
 }
 
-void pListView::modify(unsigned row, const lstring &text) {
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+void pListView::modify(unsigned row, const lstring& text) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   gtk_tree_model_get_iter_from_string(model, &iter, string(row));
   for(unsigned n = 0; n < text.size(); n++) gtk_list_store_set(store, &iter, 1 + n * 2 + 1, (const char*)text[n], -1);
 }
 
 void pListView::remove(unsigned row) {
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   gtk_tree_model_get_iter_from_string(model, &iter, string(row));
   gtk_list_store_remove(store, &iter);
@@ -66,16 +66,16 @@
 }
 
 bool pListView::selected() {
-  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+  GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
   return gtk_tree_selection_get_selected(selection, 0, 0);
 }
 
 unsigned pListView::selection() {
-  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   if(gtk_tree_selection_get_selected(selection, 0, &iter) == false) return listView.state.selection;
-  char *path = gtk_tree_model_get_string_from_iter(model, &iter);
+  char* path = gtk_tree_model_get_string_from_iter(model, &iter);
   unsigned row = decimal(path);
   g_free(path);
   return row;
@@ -86,13 +86,13 @@
 }
 
 void pListView::setChecked(unsigned row, bool checked) {
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   gtk_tree_model_get_iter_from_string(model, &iter, string(row));
   gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, checked, -1);
 }
 
-void pListView::setHeaderText(const lstring &text) {
+void pListView::setHeaderText(const lstring& text) {
   destructor();
   constructor();
 }
@@ -101,12 +101,12 @@
   gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(subWidget), visible);
 }
 
-void pListView::setImage(unsigned row, unsigned column, const nall::image &image) {
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+void pListView::setImage(unsigned row, unsigned column, const nall::image& image) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   GtkTreeIter iter;
   gtk_tree_model_get_iter_from_string(model, &iter, string(row));
   if(image.empty() == false) {
-    GdkPixbuf *pixbuf = CreatePixbuf(image, true);
+    GdkPixbuf* pixbuf = CreatePixbuf(image, true);
     gtk_list_store_set(store, &iter, 1 + column * 2, pixbuf, -1);
   } else {
     gtk_list_store_set(store, &iter, 1 + column * 2, nullptr, -1);
@@ -115,7 +115,7 @@
 
 void pListView::setSelected(bool selected) {
   if(selected == false) {
-    GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
     gtk_tree_selection_unselect_all(selection);
   } else {
     setSelection(listView.state.selection);
@@ -123,16 +123,16 @@
 }
 
 void pListView::setSelection(unsigned row) {
-  GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
-  GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
   gtk_tree_selection_unselect_all(selection);
   GtkTreeIter iter;
   if(gtk_tree_model_get_iter_from_string(model, &iter, string(row)) == false) return;
   gtk_tree_selection_select_iter(selection, &iter);
 
   //scroll window to selected item
-  char *path = gtk_tree_model_get_string_from_iter(model, &iter);
-  GtkTreePath *treePath = gtk_tree_path_new_from_string(path);
+  char* path = gtk_tree_model_get_string_from_iter(model, &iter);
+  GtkTreePath* treePath = gtk_tree_path_new_from_string(path);
   gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(subWidget), treePath, nullptr, true, 0.5, 0.0);
   gtk_tree_path_free(treePath);
   g_free(path);
@@ -148,7 +148,7 @@
 
   column.reset();
   vector<GType> gtype;
-  for(auto &text : headerText) {
+  for(auto& text : headerText) {
     GtkColumn cell;
     cell.label = gtk_label_new(text);
     cell.column = gtk_tree_view_column_new();
@@ -181,7 +181,7 @@
   gtk_container_add(GTK_CONTAINER(gtkWidget), subWidget);
   g_object_unref(G_OBJECT(store));
 
-  for(auto &cell : column) {
+  for(auto& cell : column) {
     gtk_tree_view_column_set_widget(GTK_TREE_VIEW_COLUMN(cell.column), cell.label);
     gtk_tree_view_append_column(GTK_TREE_VIEW(subWidget), cell.column);
     gtk_widget_show(cell.label);
@@ -197,7 +197,7 @@
 
   setHeaderVisible(listView.state.headerVisible);
   setCheckable(listView.state.checkable);
-  for(auto &text : listView.state.text) append(text);
+  for(auto& text : listView.state.text) append(text);
   for(unsigned n = 0; n < listView.state.checked.size(); n++) setChecked(n, listView.state.checked[n]);
   if(listView.state.selected) setSelection(listView.state.selection);
   autoSizeColumns();
@@ -217,9 +217,9 @@
   gtk_widget_grab_focus(subWidget);
 }
 
-void pListView::setFont(const string &font) {
+void pListView::setFont(const string& font) {
   pFont::setFont(gtkWidget, font);
-  for(auto &cell : column) pFont::setFont(cell.label, font);
+  for(auto& cell : column) pFont::setFont(cell.label, font);
 }
 
 }
diff -ru higan_v092r07\phoenix\gtk\widget\radio-button.cpp higan_v092r08\phoenix\gtk\widget\radio-button.cpp
--- higan_v092r07\phoenix\gtk\widget\radio-button.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\radio-button.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void RadioButton_activate(RadioButton *self) {
+static void RadioButton_activate(RadioButton* self) {
   self->p.onActivate();
 }
 
@@ -15,19 +15,19 @@
 
 void pRadioButton::setChecked() {
   parent().locked = true;
-  for(auto &item : radioButton.state.group) item.state.checked = false;
+  for(auto& item : radioButton.state.group) item.state.checked = false;
   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gtkWidget), radioButton.state.checked = true);
   parent().locked = false;
 }
 
-void pRadioButton::setGroup(const group<RadioButton&> &group) {
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+  if(&parent() == this) return;
   parent().locked = true;
-  if(radioButton.state.group.size() == 0 || &radioButton.state.group[0].p == this) return;
   gtk_radio_button_set_group(
     GTK_RADIO_BUTTON(gtkWidget),
-    gtk_radio_button_get_group(GTK_RADIO_BUTTON(radioButton.state.group[0].p.gtkWidget))
+    gtk_radio_button_get_group(GTK_RADIO_BUTTON(parent().gtkWidget))
   );
-  for(auto &item : radioButton.state.group) {
+  for(auto& item : radioButton.state.group) {
     if(item.state.checked) {
       gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(item.p.gtkWidget), true);
       break;
@@ -36,7 +36,7 @@
   parent().locked = false;
 }
 
-void pRadioButton::setText(const string &text) {
+void pRadioButton::setText(const string& text) {
   gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
 }
 
@@ -51,7 +51,7 @@
 }
 
 pRadioButton& pRadioButton::parent() {
-  if(radioButton.state.group.size()) return radioButton.state.group[0].p;
+  if(radioButton.state.group.size()) return radioButton.state.group.first().p;
   return *this;
 }
 
diff -ru higan_v092r07\phoenix\gtk\widget\text-edit.cpp higan_v092r08\phoenix\gtk\widget\text-edit.cpp
--- higan_v092r07\phoenix\gtk\widget\text-edit.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\text-edit.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void TextEdit_change(TextEdit *self) {
+static void TextEdit_change(TextEdit* self) {
   self->state.text = self->text();
   if(self->p.locked == false && self->onChange) self->onChange();
 }
@@ -10,7 +10,7 @@
 }
 
 void pTextEdit::setCursorPosition(unsigned position) {
-  GtkTextMark *mark = gtk_text_buffer_get_mark(textBuffer, "insert");
+  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
   GtkTextIter iter;
   gtk_text_buffer_get_end_iter(textBuffer, &iter);
   gtk_text_iter_set_offset(&iter, min(position, gtk_text_iter_get_offset(&iter)));
@@ -22,7 +22,7 @@
   gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), editable);
 }
 
-void pTextEdit::setText(const string &text) {
+void pTextEdit::setText(const string& text) {
   locked = true;
   gtk_text_buffer_set_text(textBuffer, text, -1);
   locked = false;
@@ -39,7 +39,7 @@
   GtkTextIter start, end;
   gtk_text_buffer_get_start_iter(textBuffer, &start);
   gtk_text_buffer_get_end_iter(textBuffer, &end);
-  char *temp = gtk_text_buffer_get_text(textBuffer, &start, &end, true);
+  char* temp = gtk_text_buffer_get_text(textBuffer, &start, &end, true);
   string text = temp;
   g_free(temp);
   return text;
diff -ru higan_v092r07\phoenix\gtk\widget\vertical-scroller.cpp higan_v092r08\phoenix\gtk\widget\vertical-scroller.cpp
--- higan_v092r07\phoenix\gtk\widget\vertical-scroller.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\vertical-scroller.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void VerticalScroller_change(VerticalScroller *self) {
+static void VerticalScroller_change(VerticalScroller* self) {
   if(self->state.position == self->position()) return;
   self->state.position = self->position();
   if(self->p.locked == false && self->onChange) self->onChange();
diff -ru higan_v092r07\phoenix\gtk\widget\vertical-slider.cpp higan_v092r08\phoenix\gtk\widget\vertical-slider.cpp
--- higan_v092r07\phoenix\gtk\widget\vertical-slider.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\vertical-slider.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static void VerticalSlider_change(VerticalSlider *self) {
+static void VerticalSlider_change(VerticalSlider* self) {
   if(self->state.position == self->position()) return;
   self->state.position = self->position();
   if(self->onChange) self->onChange();
diff -ru higan_v092r07\phoenix\gtk\widget\viewport.cpp higan_v092r08\phoenix\gtk\widget\viewport.cpp
--- higan_v092r07\phoenix\gtk\widget\viewport.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\viewport.cpp	Thu May 02 05:48:04 2013
@@ -1,16 +1,16 @@
 namespace phoenix {
 
-static gboolean Viewport_mouseLeave(GtkWidget *widget, GdkEventButton *event, pViewport *self) {
+static gboolean Viewport_mouseLeave(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
   if(self->viewport.onMouseLeave) self->viewport.onMouseLeave();
   return true;
 }
 
-static gboolean Viewport_mouseMove(GtkWidget *widget, GdkEventButton *event, pViewport *self) {
-  if(self->viewport.onMouseMove) self->viewport.onMouseMove({ (signed)event->x, (signed)event->y });
+static gboolean Viewport_mouseMove(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
+  if(self->viewport.onMouseMove) self->viewport.onMouseMove({(signed)event->x, (signed)event->y});
   return true;
 }
 
-static gboolean Viewport_mousePress(GtkWidget *widget, GdkEventButton *event, pViewport *self) {
+static gboolean Viewport_mousePress(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
   if(self->viewport.onMousePress) switch(event->button) {
   case 1: self->viewport.onMousePress(Mouse::Button::Left); break;
   case 2: self->viewport.onMousePress(Mouse::Button::Middle); break;
@@ -19,7 +19,7 @@
   return true;
 }
 
-static gboolean Viewport_mouseRelease(GtkWidget *widget, GdkEventButton *event, pViewport *self) {
+static gboolean Viewport_mouseRelease(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
   if(self->viewport.onMouseRelease) switch(event->button) {
   case 1: self->viewport.onMouseRelease(Mouse::Button::Left); break;
   case 2: self->viewport.onMouseRelease(Mouse::Button::Middle); break;
diff -ru higan_v092r07\phoenix\gtk\widget\widget.cpp higan_v092r08\phoenix\gtk\widget\widget.cpp
--- higan_v092r07\phoenix\gtk\widget\widget.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\widget\widget.cpp	Thu May 02 05:48:04 2013
@@ -22,11 +22,11 @@
   gtk_widget_grab_focus(gtkWidget);
 }
 
-void pWidget::setFont(const string &font) {
+void pWidget::setFont(const string& font) {
   pFont::setFont(gtkWidget, font);
 }
 
-void pWidget::setGeometry(const Geometry &geometry) {
+void pWidget::setGeometry(const Geometry& geometry) {
   if(sizable.window() && sizable.window()->visible()) gtk_fixed_move(GTK_FIXED(sizable.window()->p.formContainer), gtkWidget, geometry.x, geometry.y);
   unsigned width = (signed)geometry.width <= 0 ? 1U : geometry.width;
   unsigned height = (signed)geometry.height <= 0 ? 1U : geometry.height;
diff -ru higan_v092r07\phoenix\gtk\window.cpp higan_v092r08\phoenix\gtk\window.cpp
--- higan_v092r07\phoenix\gtk\window.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\gtk\window.cpp	Thu May 02 05:48:04 2013
@@ -1,15 +1,15 @@
 namespace phoenix {
 
-static gint Window_close(GtkWidget *widget, GdkEvent *event, Window *window) {
+static gint Window_close(GtkWidget* widget, GdkEvent* event, Window* window) {
   if(window->onClose) window->onClose();
   else window->setVisible(false);
   if(window->state.modal && !window->visible()) window->setModal(false);
   return true;
 }
 
-static gboolean Window_expose(GtkWidget *widget, GdkEvent *event, Window *window) {
+static gboolean Window_expose(GtkWidget* widget, GdkEvent* event, Window* window) {
   if(window->state.backgroundColorOverride == false) return false;
-  cairo_t *context = gdk_cairo_create(widget->window);
+  cairo_t* context = gdk_cairo_create(widget->window);
 
   Color color = window->backgroundColor();
   double red   = (double)color.red   / 255.0;
@@ -30,7 +30,7 @@
   return false;
 }
 
-static gboolean Window_configure(GtkWidget *widget, GdkEvent *event, Window *window) {
+static gboolean Window_configure(GtkWidget* widget, GdkEvent* event, Window* window) {
   if(gtk_widget_get_realized(window->p.widget) == false) return false;
   if(window->visible() == false) return false;
   GdkWindow *gdkWindow = gtk_widget_get_window(widget);
@@ -80,19 +80,19 @@
   return false;
 }
 
-static gboolean Window_keyPressEvent(GtkWidget *widget, GdkEventKey *event, Window *window) {
+static gboolean Window_keyPressEvent(GtkWidget* widget, GdkEventKey* event, Window* window) {
   Keyboard::Keycode key = Keysym(event->keyval);
   if(key != Keyboard::Keycode::None && window->onKeyPress) window->onKeyPress(key);
   return false;
 }
 
-static gboolean Window_keyReleaseEvent(GtkWidget *widget, GdkEventKey *event, Window *window) {
+static gboolean Window_keyReleaseEvent(GtkWidget* widget, GdkEventKey* event, Window* window) {
   Keyboard::Keycode key = Keysym(event->keyval);
   if(key != Keyboard::Keycode::None && window->onKeyRelease) window->onKeyRelease(key);
   return false;
 }
 
-static void Window_sizeAllocate(GtkWidget *widget, GtkAllocation *allocation, Window *window) {
+static void Window_sizeAllocate(GtkWidget* widget, GtkAllocation* allocation, Window* window) {
   //size-allocate sent from gtk_fixed_move(); detect if layout unchanged and return
   if(allocation->width  == window->p.lastAllocation.width
   && allocation->height == window->p.lastAllocation.height) return;
@@ -100,7 +100,7 @@
   window->state.geometry.width  = allocation->width;
   window->state.geometry.height = allocation->height;
 
-  for(auto &layout : window->state.layout) {
+  for(auto& layout : window->state.layout) {
     Geometry geometry = window->geometry();
     geometry.x = geometry.y = 0;
     layout.setGeometry(geometry);
@@ -114,31 +114,31 @@
   window->p.lastAllocation = *allocation;
 }
 
-static void Window_sizeRequest(GtkWidget *widget, GtkRequisition *requisition, Window *window) {
+static void Window_sizeRequest(GtkWidget* widget, GtkRequisition* requisition, Window* window) {
   requisition->width  = window->state.geometry.width;
   requisition->height = window->state.geometry.height;
 }
 
 Window& pWindow::none() {
-  static Window *window = nullptr;
+  static Window* window = nullptr;
   if(window == nullptr) window = new Window;
   return *window;
 }
 
-void pWindow::append(Layout &layout) {
+void pWindow::append(Layout& layout) {
   Geometry geometry = this->geometry();
   geometry.x = geometry.y = 0;
   layout.setGeometry(geometry);
 }
 
-void pWindow::append(Menu &menu) {
+void pWindow::append(Menu& menu) {
   if(window.state.menuFont != "") menu.p.setFont(window.state.menuFont);
   else menu.p.setFont("Sans, 8");
   gtk_menu_shell_append(GTK_MENU_SHELL(this->menu), menu.p.widget);
   gtk_widget_show(menu.p.widget);
 }
 
-void pWindow::append(Widget &widget) {
+void pWindow::append(Widget& widget) {
   if(widget.font().empty() && !window.state.widgetFont.empty()) {
     widget.setFont(window.state.widgetFont);
   }
@@ -192,18 +192,18 @@
   return window.state.geometry;
 }
 
-void pWindow::remove(Layout &layout) {
+void pWindow::remove(Layout& layout) {
 }
 
-void pWindow::remove(Menu &menu) {
+void pWindow::remove(Menu& menu) {
   menu.p.orphan();
 }
 
-void pWindow::remove(Widget &widget) {
+void pWindow::remove(Widget& widget) {
   widget.p.orphan();
 }
 
-void pWindow::setBackgroundColor(const Color &color) {
+void pWindow::setBackgroundColor(const Color& color) {
   GdkColor gdkColor;
   gdkColor.pixel = (color.red   << 16) | (color.green << 8) | (color.blue << 0);
   gdkColor.red   = (color.red   <<  8) | (color.red   << 0);
@@ -224,7 +224,7 @@
   }
 }
 
-void pWindow::setGeometry(const Geometry &geometry) {
+void pWindow::setGeometry(const Geometry& geometry) {
   Geometry margin = frameMargin();
   gtk_window_move(GTK_WINDOW(widget), geometry.x - margin.x, geometry.y - margin.y);
 
@@ -237,15 +237,15 @@
   gtk_widget_set_size_request(formContainer, geometry.width, geometry.height);
   gtk_window_resize(GTK_WINDOW(widget), geometry.width, geometry.height + menuHeight() + statusHeight());
 
-  for(auto &layout : window.state.layout) {
+  for(auto& layout : window.state.layout) {
     Geometry layoutGeometry = geometry;
     layoutGeometry.x = layoutGeometry.y = 0;
     layout.setGeometry(layoutGeometry);
   }
 }
 
-void pWindow::setMenuFont(const string &font) {
-  for(auto &item : window.state.menu) item.p.setFont(font);
+void pWindow::setMenuFont(const string& font) {
+  for(auto& item : window.state.menu) item.p.setFont(font);
 }
 
 void pWindow::setMenuVisible(bool visible) {
@@ -268,11 +268,11 @@
   gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(status), resizable);
 }
 
-void pWindow::setStatusFont(const string &font) {
+void pWindow::setStatusFont(const string& font) {
   pFont::setFont(status, font);
 }
 
-void pWindow::setStatusText(const string &text) {
+void pWindow::setStatusText(const string& text) {
   gtk_statusbar_pop(GTK_STATUSBAR(status), 1);
   gtk_statusbar_push(GTK_STATUSBAR(status), 1, text);
 }
@@ -281,7 +281,7 @@
   gtk_widget_set_visible(status, visible);
 }
 
-void pWindow::setTitle(const string &text) {
+void pWindow::setTitle(const string& text) {
   gtk_window_set_title(GTK_WINDOW(widget), text);
 }
 
@@ -302,7 +302,7 @@
   }
 }
 
-void pWindow::setWidgetFont(const string &font) {
+void pWindow::setWidgetFont(const string& font) {
 }
 
 void pWindow::constructor() {
diff -ru higan_v092r07\phoenix\qt\action\action.cpp higan_v092r08\phoenix\qt\action\action.cpp
--- higan_v092r07\phoenix\qt\action\action.cpp	Fri Apr 12 16:38:15 2013
+++ higan_v092r08\phoenix\qt\action\action.cpp	Thu May 02 05:48:04 2013
@@ -14,7 +14,7 @@
   }
 }
 
-void pAction::setFont(const string &font) {
+void pAction::setFont(const string& font) {
   QFont qtFont = pFont::create(font);
 
   if(dynamic_cast<Menu*>(&action)) {
diff -ru higan_v092r07\phoenix\qt\action\check-item.cpp higan_v092r08\phoenix\qt\action\check-item.cpp
--- higan_v092r07\phoenix\qt\action\check-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\action\check-item.cpp	Thu May 02 05:48:04 2013
@@ -8,7 +8,7 @@
   qtAction->setChecked(checked);
 }
 
-void pCheckItem::setText(const string &text) {
+void pCheckItem::setText(const string& text) {
   qtAction->setText(QString::fromUtf8(text));
 }
 
@@ -21,6 +21,7 @@
 void pCheckItem::destructor() {
   if(action.state.menu) action.state.menu->remove(checkItem);
   delete qtAction;
+  qtAction = nullptr;
 }
 
 void pCheckItem::onToggle() {
diff -ru higan_v092r07\phoenix\qt\action\item.cpp higan_v092r08\phoenix\qt\action\item.cpp
--- higan_v092r07\phoenix\qt\action\item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\action\item.cpp	Thu May 02 05:48:04 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
-void pItem::setImage(const image &image) {
+void pItem::setImage(const image& image) {
   qtAction->setIcon(CreateIcon(image));
 }
 
-void pItem::setText(const string &text) {
+void pItem::setText(const string& text) {
   qtAction->setText(QString::fromUtf8(text));
 }
 
@@ -16,6 +16,7 @@
 void pItem::destructor() {
   if(action.state.menu) action.state.menu->remove(item);
   delete qtAction;
+  qtAction = nullptr;
 }
 
 void pItem::onActivate() {
diff -ru higan_v092r07\phoenix\qt\action\menu.cpp higan_v092r08\phoenix\qt\action\menu.cpp
--- higan_v092r07\phoenix\qt\action\menu.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\action\menu.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pMenu::append(Action &action) {
+void pMenu::append(Action& action) {
   if(dynamic_cast<Menu*>(&action)) {
     qtMenu->addMenu(((Menu&)action).p.qtMenu);
   } else if(dynamic_cast<Separator*>(&action)) {
@@ -14,7 +14,7 @@
   }
 }
 
-void pMenu::remove(Action &action) {
+void pMenu::remove(Action& action) {
   if(dynamic_cast<Menu*>(&action)) {
     //QMenu::removeMenu() does not exist
     qtMenu->clear();
@@ -30,16 +30,16 @@
   }
 }
 
-void pMenu::setFont(const string &font) {
+void pMenu::setFont(const string& font) {
   qtMenu->setFont(pFont::create(font));
   for(auto &item : menu.state.action) item.p.setFont(font);
 }
 
-void pMenu::setImage(const image &image) {
+void pMenu::setImage(const image& image) {
   qtMenu->setIcon(CreateIcon(image));
 }
 
-void pMenu::setText(const string &text) {
+void pMenu::setText(const string& text) {
   qtMenu->setTitle(QString::fromUtf8(text));
 }
 
@@ -50,6 +50,7 @@
 void pMenu::destructor() {
   if(action.state.menu) action.state.menu->remove(menu);
   delete qtMenu;
+  qtMenu = nullptr;
 }
 
 }
diff -ru higan_v092r07\phoenix\qt\action\radio-item.cpp higan_v092r08\phoenix\qt\action\radio-item.cpp
--- higan_v092r07\phoenix\qt\action\radio-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\action\radio-item.cpp	Thu May 02 05:48:04 2013
@@ -6,7 +6,7 @@
 
 void pRadioItem::setChecked() {
   locked = true;
-  for(auto &item : radioItem.state.group) {
+  for(auto& item : radioItem.state.group) {
     bool checkState = item.p.qtAction == qtAction;
     item.state.checked = checkState;
     item.p.qtAction->setChecked(checkState);
@@ -14,10 +14,10 @@
   locked = false;
 }
 
-void pRadioItem::setGroup(const group<RadioItem&> &group) {
+void pRadioItem::setGroup(const group<RadioItem>& group) {
 }
 
-void pRadioItem::setText(const string &text) {
+void pRadioItem::setText(const string& text) {
   qtAction->setText(QString::fromUtf8(text));
 }
 
@@ -33,6 +33,7 @@
 void pRadioItem::destructor() {
   if(action.state.menu) action.state.menu->remove(radioItem);
   delete qtAction;
+  qtAction = nullptr;
 }
 
 void pRadioItem::onActivate() {
diff -ru higan_v092r07\phoenix\qt\action\separator.cpp higan_v092r08\phoenix\qt\action\separator.cpp
--- higan_v092r07\phoenix\qt\action\separator.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\action\separator.cpp	Thu May 02 05:48:04 2013
@@ -8,6 +8,7 @@
 void pSeparator::destructor() {
   if(action.state.menu) action.state.menu->remove(separator);
   delete qtAction;
+  qtAction = nullptr;
 }
 
 }
diff -ru higan_v092r07\phoenix\qt\application.cpp higan_v092r08\phoenix\qt\application.cpp
--- higan_v092r07\phoenix\qt\application.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\application.cpp	Thu May 02 05:48:04 2013
@@ -42,11 +42,9 @@
   settings->load();
 
   static int argc = 1;
-  static char *argv[2];
-  argv[0] = new char[8];
-  argv[1] = 0;
+  static char* argv[] = {new char[8], nullptr};
   strcpy(argv[0], "phoenix");
-  char **argvp = argv;
+  char** argvp = argv;
 
   qtApplication = new QApplication(argc, argvp);
 
diff -ru higan_v092r07\phoenix\qt\browser-window.cpp higan_v092r08\phoenix\qt\browser-window.cpp
--- higan_v092r07\phoenix\qt\browser-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\browser-window.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-string pBrowserWindow::directory(BrowserWindow::State &state) {
+string pBrowserWindow::directory(BrowserWindow::State& state) {
   QString directory = QFileDialog::getExistingDirectory(
     state.parent ? state.parent->p.qtWindow : nullptr,
     state.title ? state.title : "Select Directory",
@@ -11,13 +11,13 @@
   return name;
 }
 
-string pBrowserWindow::open(BrowserWindow::State &state) {
+string pBrowserWindow::open(BrowserWindow::State& state) {
   string filters = state.filters.concatenate(";;");
 
   //convert filter list from phoenix to Qt format, example:
   //"Text, XML files (*.txt,*.xml)" -> "Text, XML files (*.txt *.xml)"
   signed parentheses = 0;
-  for(auto &n : filters) {
+  for(auto& n : filters) {
     if(n == '(') parentheses++;
     if(n == ')') parentheses--;
     if(n == ',' && parentheses) n = ' ';
@@ -31,13 +31,13 @@
   return filename.toUtf8().constData();
 }
 
-string pBrowserWindow::save(BrowserWindow::State &state) {
+string pBrowserWindow::save(BrowserWindow::State& state) {
   string filters = state.filters.concatenate(";;");
 
   //convert filter list from phoenix to Qt format, example:
   //"Text, XML files (*.txt,*.xml)" -> "Text, XML files (*.txt *.xml)"
   signed parentheses = 0;
-  for(auto &n : filters) {
+  for(auto& n : filters) {
     if(n == '(') parentheses++;
     if(n == ')') parentheses--;
     if(n == ',' && parentheses) n = ' ';
diff -ru higan_v092r07\phoenix\qt\desktop.cpp higan_v092r08\phoenix\qt\desktop.cpp
--- higan_v092r07\phoenix\qt\desktop.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\desktop.cpp	Thu May 02 05:48:04 2013
@@ -2,12 +2,12 @@
 
 Size pDesktop::size() {
   QRect rect = QApplication::desktop()->screenGeometry();
-  return { rect.width(), rect.height() };
+  return {rect.width(), rect.height()};
 }
 
 Geometry pDesktop::workspace() {
   QRect rect = QApplication::desktop()->availableGeometry();
-  return { rect.x(), rect.y(), rect.width(), rect.height() };
+  return {rect.x(), rect.y(), rect.width(), rect.height()};
 }
 
 }
diff -ru higan_v092r07\phoenix\qt\font.cpp higan_v092r08\phoenix\qt\font.cpp
--- higan_v092r07\phoenix\qt\font.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\font.cpp	Thu May 02 05:48:04 2013
@@ -18,14 +18,14 @@
   return {"Liberation Mono, ", size, ", ", style};
 }
 
-Size pFont::size(const string &font, const string &text) {
+Size pFont::size(const string& font, const string& text) {
   return pFont::size(pFont::create(font), text);
 }
 
-QFont pFont::create(const string &description) {
+QFont pFont::create(const string& description) {
   lstring part;
   part.split<2>(",", description);
-  for(auto &item : part) item.trim(" ");
+  for(auto& item : part) item.trim(" ");
 
   string family = "Sans";
   unsigned size = 8u;
@@ -45,14 +45,14 @@
   return qtFont;
 }
 
-Size pFont::size(const QFont &qtFont, const string &text) {
+Size pFont::size(const QFont& qtFont, const string& text) {
   QFontMetrics metrics(qtFont);
 
   lstring lines;
   lines.split("\n", text);
 
   unsigned maxWidth = 0;
-  for(auto &line : lines) {
+  for(auto& line : lines) {
     maxWidth = max(maxWidth, metrics.width(line));
   }
 
diff -ru higan_v092r07\phoenix\qt\keyboard.cpp higan_v092r08\phoenix\qt\keyboard.cpp
--- higan_v092r07\phoenix\qt\keyboard.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\keyboard.cpp	Thu May 02 05:48:04 2013
@@ -123,20 +123,23 @@
 bool pKeyboard::pressed(Keyboard::Scancode scancode) {
   char state[256];
   XQueryKeymap(pApplication::display, state);
-  unsigned id = settings->keymap.lhs[scancode];
-  return state[id >> 3] & (1 << (id & 7));
+  if(auto result = settings->keymap.find(scancode)) {
+    unsigned id = result();
+    return state[id >> 3] & (1 << (id & 7));
+  }
+  return false;
 }
 
 vector<bool> pKeyboard::state() {
   vector<bool> output;
   output.resize((unsigned)Keyboard::Scancode::Limit);
-  for(auto &n : output) n = false;
+  for(auto& n : output) n = false;
 
   char state[256];
   XQueryKeymap(pApplication::display, state);
-  for(auto &n : settings->keymap.rhs) {
-    if(state[n.name >> 3] & (1 << (n.name & 7))) {
-      output[(unsigned)n.data] = true;
+  for(auto node : settings->keymap) {
+    if(state[node.value >> 3] & (1 << (node.value & 7))) {
+      output[(unsigned)node.key] = true;
     }
   }
 
diff -ru higan_v092r07\phoenix\qt\message-window.cpp higan_v092r08\phoenix\qt\message-window.cpp
--- higan_v092r07\phoenix\qt\message-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\message-window.cpp	Thu May 02 05:48:04 2013
@@ -24,28 +24,28 @@
   throw;
 }
 
-MessageWindow::Response pMessageWindow::error(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
   return MessageWindow_response(
     state.buttons, QMessageBox::critical(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
     QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
   );
 }
 
-MessageWindow::Response pMessageWindow::information(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
   return MessageWindow_response(
     state.buttons, QMessageBox::information(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
     QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
   );
 }
 
-MessageWindow::Response pMessageWindow::question(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
   return MessageWindow_response(
     state.buttons, QMessageBox::question(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
     QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
   );
 }
 
-MessageWindow::Response pMessageWindow::warning(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
   return MessageWindow_response(
     state.buttons, QMessageBox::warning(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
     QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
diff -ru higan_v092r07\phoenix\qt\platform.moc higan_v092r08\phoenix\qt\platform.moc
--- higan_v092r07\phoenix\qt\platform.moc	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\platform.moc	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 /****************************************************************************
 ** Meta object code from reading C++ file 'platform.moc.hpp'
 **
-** Created: Wed Apr 10 03:33:04 2013
+** Created: Mon Apr 29 08:08:05 2013
 **      by: The Qt Meta Object Compiler version 62 (Qt 4.6.3)
 **
 ** WARNING! All changes made in this file will be lost!
diff -ru higan_v092r07\phoenix\qt\platform.moc.hpp higan_v092r08\phoenix\qt\platform.moc.hpp
--- higan_v092r07\phoenix\qt\platform.moc.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\platform.moc.hpp	Thu May 02 05:48:04 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
 struct pApplication {
-  static XlibDisplay *display;
+  static XlibDisplay* display;
 
   static void run();
   static bool pendingEvents();
@@ -12,10 +12,10 @@
   static void syncX();
 };
 
-static QApplication *qtApplication = nullptr;
+static QApplication* qtApplication = nullptr;
 
 struct Settings : Configuration::Document {
-  bidirectional_map<Keyboard::Scancode, unsigned> keymap;
+  bimap<Keyboard::Scancode, unsigned> keymap;
 
   struct Geometry : Configuration::Node {
     unsigned frameX;
@@ -40,10 +40,10 @@
   static string serif(unsigned size, string style);
   static string sans(unsigned size, string style);
   static string monospace(unsigned size, string style);
-  static Size size(const string &font, const string &text);
+  static Size size(const string& font, const string& text);
 
-  static QFont create(const string &description);
-  static Size size(const QFont &qtFont, const string &text);
+  static QFont create(const string& description);
+  static Size size(const QFont& qtFont, const string& text);
 };
 
 struct pDesktop {
@@ -64,23 +64,23 @@
 };
 
 struct pBrowserWindow {
-  static string directory(BrowserWindow::State &state);
-  static string open(BrowserWindow::State &state);
-  static string save(BrowserWindow::State &state);
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
 };
 
 struct pMessageWindow {
-  static MessageWindow::Response error(MessageWindow::State &state);
-  static MessageWindow::Response information(MessageWindow::State &state);
-  static MessageWindow::Response question(MessageWindow::State &state);
-  static MessageWindow::Response warning(MessageWindow::State &state);
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
 };
 
 struct pObject {
-  Object &object;
+  Object& object;
   bool locked;
 
-  pObject(Object &object) : object(object), locked(false) {}
+  pObject(Object& object) : object(object), locked(false) {}
   virtual ~pObject() {}
   void constructor() {}
   void destructor() {}
@@ -90,13 +90,13 @@
   Q_OBJECT
 
 public:
-  Timer &timer;
-  QTimer *qtTimer;
+  Timer& timer;
+  QTimer* qtTimer;
 
   void setEnabled(bool enabled);
   void setInterval(unsigned milliseconds);
 
-  pTimer(Timer &timer) : pObject(timer), timer(timer) {}
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
   void constructor();
   void destructor();
 
@@ -108,87 +108,88 @@
   Q_OBJECT
 
 public:
-  Window &window;
+  Window& window;
   struct QtWindow : public QWidget {
-    pWindow &self;
+    pWindow& self;
     void closeEvent(QCloseEvent*);
     void keyPressEvent(QKeyEvent*);
     void keyReleaseEvent(QKeyEvent*);
     void moveEvent(QMoveEvent*);
     void resizeEvent(QResizeEvent*);
     QSize sizeHint() const;
-    QtWindow(pWindow &self) : self(self) {}
-  } *qtWindow;
-  QVBoxLayout *qtLayout;
-  QMenuBar *qtMenu;
-  QStatusBar *qtStatus;
-  QWidget *qtContainer;
+    QtWindow(pWindow& self) : self(self) {}
+  };
+  QtWindow* qtWindow;
+  QVBoxLayout* qtLayout;
+  QMenuBar* qtMenu;
+  QStatusBar* qtStatus;
+  QWidget* qtContainer;
 
   static Window& none();
 
-  void append(Layout &layout);
-  void append(Menu &menu);
-  void append(Widget &widget);
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
   Color backgroundColor();
   Geometry frameMargin();
   bool focused();
   Geometry geometry();
-  void remove(Layout &layout);
-  void remove(Menu &menu);
-  void remove(Widget &widget);
-  void setBackgroundColor(const Color &color);
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(const Color& color);
   void setFocused();
   void setFullScreen(bool fullScreen);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const string& font);
   void setMenuVisible(bool visible);
   void setModal(bool modal);
   void setResizable(bool resizable);
-  void setStatusFont(const string &font);
-  void setStatusText(const string &text);
+  void setStatusFont(const string& font);
+  void setStatusText(const string& text);
   void setStatusVisible(bool visible);
-  void setTitle(const string &text);
+  void setTitle(const string& text);
   void setVisible(bool visible);
-  void setWidgetFont(const string &font);
+  void setWidgetFont(const string& font);
 
-  pWindow(Window &window) : pObject(window), window(window) {}
+  pWindow(Window& window) : pObject(window), window(window) {}
   void constructor();
   void destructor();
   void updateFrameGeometry();
 };
 
 struct pAction : public pObject {
-  Action &action;
+  Action& action;
 
   void setEnabled(bool enabled);
-  void setFont(const string &font);
+  void setFont(const string& font);
   void setVisible(bool visible);
 
-  pAction(Action &action) : pObject(action), action(action) {}
+  pAction(Action& action) : pObject(action), action(action) {}
   void constructor();
   void destructor();
 };
 
 struct pMenu : public pAction {
-  Menu &menu;
-  QMenu *qtMenu;
+  Menu& menu;
+  QMenu* qtMenu;
 
-  void append(Action &action);
-  void remove(Action &action);
-  void setFont(const string &font);
-  void setImage(const image &image);
-  void setText(const string &text);
+  void append(Action& action);
+  void remove(Action& action);
+  void setFont(const string& font);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pMenu(Menu &menu) : pAction(menu), menu(menu) {}
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
   void constructor();
   void destructor();
 };
 
 struct pSeparator : public pAction {
-  Separator &separator;
-  QAction *qtAction;
+  Separator& separator;
+  QAction* qtAction;
 
-  pSeparator(Separator &separator) : pAction(separator), separator(separator) {}
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
   void constructor();
   void destructor();
 };
@@ -197,13 +198,13 @@
   Q_OBJECT
 
 public:
-  Item &item;
-  QAction *qtAction;
+  Item& item;
+  QAction* qtAction;
 
-  void setImage(const image &image);
-  void setText(const string &text);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pItem(Item &item) : pAction(item), item(item) {}
+  pItem(Item& item) : pAction(item), item(item) {}
   void constructor();
   void destructor();
 
@@ -215,14 +216,14 @@
   Q_OBJECT
 
 public:
-  CheckItem &checkItem;
-  QAction *qtAction;
+  CheckItem& checkItem;
+  QAction* qtAction;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckItem(CheckItem &checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
   void constructor();
   void destructor();
 
@@ -234,16 +235,16 @@
   Q_OBJECT
 
 public:
-  RadioItem &radioItem;
-  QAction *qtAction;
-  QActionGroup *qtGroup;
+  RadioItem& radioItem;
+  QAction* qtAction;
+  QActionGroup* qtGroup;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioItem&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioItem>& group);
+  void setText(const string& text);
 
-  pRadioItem(RadioItem &radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
   void constructor();
   void destructor();
 
@@ -252,36 +253,36 @@
 };
 
 struct pSizable : public pObject {
-  Sizable &sizable;
+  Sizable& sizable;
 
-  pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
 
   void constructor() {}
   void destructor() {}
 };
 
 struct pLayout : public pSizable {
-  Layout &layout;
+  Layout& layout;
 
-  pLayout(Layout &layout) : pSizable(layout), layout(layout) {}
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
 
   void constructor() {}
   void destructor() {}
 };
 
 struct pWidget : public pSizable {
-  Widget &widget;
-  QWidget *qtWidget;
+  Widget& widget;
+  QWidget* qtWidget;
 
   bool focused();
   virtual Size minimumSize();
   void setEnabled(bool enabled);
   void setFocused();
-  void setFont(const string &font);
-  virtual void setGeometry(const Geometry &geometry);
+  void setFont(const string& font);
+  virtual void setGeometry(const Geometry& geometry);
   void setVisible(bool visible);
 
-  pWidget(Widget &widget) : pSizable(widget), widget(widget) {}
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
   void constructor();
   void synchronizeState();
   void destructor();
@@ -292,14 +293,14 @@
   Q_OBJECT
 
 public:
-  Button &button;
-  QToolButton *qtButton;
+  Button& button;
+  QToolButton* qtButton;
 
   Size minimumSize();
-  void setImage(const image &image, Orientation orientation);
-  void setText(const string &text);
+  void setImage(const image& image, Orientation orientation);
+  void setText(const string& text);
 
-  pButton(Button &button) : pWidget(button), button(button) {}
+  pButton(Button& button) : pWidget(button), button(button) {}
   void constructor();
   void destructor();
   void orphan();
@@ -312,22 +313,23 @@
   Q_OBJECT
 
 public:
-  Canvas &canvas;
-  QImage *qtImage;
+  Canvas& canvas;
+  QImage* qtImage;
   struct QtCanvas : public QWidget {
-    pCanvas &self;
+    pCanvas& self;
     void leaveEvent(QEvent*);
     void mouseMoveEvent(QMouseEvent*);
     void mousePressEvent(QMouseEvent*);
     void mouseReleaseEvent(QMouseEvent*);
     void paintEvent(QPaintEvent*);
-    QtCanvas(pCanvas &self);
-  } *qtCanvas;
+    QtCanvas(pCanvas& self);
+  };
+  QtCanvas* qtCanvas;
 
-  void setSize(const Size &size);
+  void setSize(const Size& size);
   void update();
 
-  pCanvas(Canvas &canvas) : pWidget(canvas), canvas(canvas) {}
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
   void constructor();
   void destructor();
   void orphan();
@@ -339,15 +341,15 @@
   Q_OBJECT
 
 public:
-  CheckButton &checkButton;
-  QCheckBox *qtCheckButton;
+  CheckButton& checkButton;
+  QCheckBox* qtCheckButton;
 
   bool checked();
   Size minimumSize();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckButton(CheckButton &checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
   void constructor();
   void destructor();
   void orphan();
@@ -360,18 +362,18 @@
   Q_OBJECT
 
 public:
-  ComboButton &comboButton;
-  QComboBox *qtComboButton;
+  ComboButton& comboButton;
+  QComboBox* qtComboButton;
 
-  void append(const string &text);
-  void modify(unsigned row, const string &text);
+  void append(const string& text);
+  void modify(unsigned row, const string& text);
   void remove(unsigned row);
   Size minimumSize();
   void reset();
   unsigned selection();
   void setSelection(unsigned row);
 
-  pComboButton(ComboButton &comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
   void constructor();
   void destructor();
   void orphan();
@@ -384,15 +386,16 @@
   Q_OBJECT
 
 public:
-  HexEdit &hexEdit;
+  HexEdit& hexEdit;
   struct QtHexEdit : public QTextEdit {
-    pHexEdit &self;
+    pHexEdit& self;
     void keyPressEvent(QKeyEvent*);
     void keyPressEventAcknowledge(QKeyEvent*);
-    QtHexEdit(pHexEdit &self) : self(self) {}
-  } *qtHexEdit;
-  QHBoxLayout *qtLayout;
-  QScrollBar *qtScroll;
+    QtHexEdit(pHexEdit& self) : self(self) {}
+  };
+  QtHexEdit* qtHexEdit;
+  QHBoxLayout* qtLayout;
+  QScrollBar* qtScroll;
 
   void setColumns(unsigned columns);
   void setLength(unsigned length);
@@ -400,7 +403,7 @@
   void setRows(unsigned rows);
   void update();
 
-  pHexEdit(HexEdit &hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
   void constructor();
   void destructor();
   void orphan();
@@ -414,15 +417,15 @@
   Q_OBJECT
 
 public:
-  HorizontalScroller &horizontalScroller;
-  QScrollBar *qtScroller;
+  HorizontalScroller& horizontalScroller;
+  QScrollBar* qtScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalScroller(HorizontalScroller &horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
   void constructor();
   void destructor();
   void orphan();
@@ -435,15 +438,15 @@
   Q_OBJECT
 
 public:
-  HorizontalSlider &horizontalSlider;
-  QSlider *qtSlider;
+  HorizontalSlider& horizontalSlider;
+  QSlider* qtSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalSlider(HorizontalSlider &horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
   void constructor();
   void destructor();
   void orphan();
@@ -453,13 +456,13 @@
 };
 
 struct pLabel : public pWidget {
-  Label &label;
-  QLabel *qtLabel;
+  Label& label;
+  QLabel* qtLabel;
 
   Size minimumSize();
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pLabel(Label &label) : pWidget(label), label(label) {}
+  pLabel(Label& label) : pWidget(label), label(label) {}
   void constructor();
   void destructor();
   void orphan();
@@ -469,15 +472,15 @@
   Q_OBJECT
 
 public:
-  LineEdit &lineEdit;
-  QLineEdit *qtLineEdit;
+  LineEdit& lineEdit;
+  QLineEdit* qtLineEdit;
 
   Size minimumSize();
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   string text();
 
-  pLineEdit(LineEdit &lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
   void constructor();
   void destructor();
   void orphan();
@@ -491,44 +494,44 @@
   Q_OBJECT
 
 public:
-  ListView &listView;
-  QTreeWidget *qtListView;
+  ListView& listView;
+  QTreeWidget* qtListView;
 
-  void append(const lstring &text);
+  void append(const lstring& text);
   void autoSizeColumns();
   bool checked(unsigned row);
-  void modify(unsigned row, const lstring &text);
+  void modify(unsigned row, const lstring& text);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable);
   void setChecked(unsigned row, bool checked);
-  void setHeaderText(const lstring &text);
+  void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
-  void setImage(unsigned row, unsigned column, const nall::image &image);
+  void setImage(unsigned row, unsigned column, const nall::image& image);
   void setSelected(bool selected);
   void setSelection(unsigned row);
 
-  pListView(ListView &listView) : pWidget(listView), listView(listView) {}
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
   void constructor();
   void destructor();
   void orphan();
 
 public slots:
   void onActivate();
-  void onChange(QTreeWidgetItem *item);
-  void onToggle(QTreeWidgetItem *item);
+  void onChange(QTreeWidgetItem* item);
+  void onToggle(QTreeWidgetItem* item);
 };
 
 struct pProgressBar : public pWidget {
-  ProgressBar &progressBar;
-  QProgressBar *qtProgressBar;
+  ProgressBar& progressBar;
+  QProgressBar* qtProgressBar;
 
   Size minimumSize();
   void setPosition(unsigned position);
 
-  pProgressBar(ProgressBar &progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
   void constructor();
   void destructor();
   void orphan();
@@ -538,16 +541,16 @@
   Q_OBJECT
 
 public:
-  RadioButton &radioButton;
-  QRadioButton *qtRadioButton;
+  RadioButton& radioButton;
+  QRadioButton* qtRadioButton;
 
   bool checked();
   Size minimumSize();
   void setChecked();
-  void setGroup(const group<RadioButton&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioButton>& group);
+  void setText(const string& text);
 
-  pRadioButton(RadioButton &radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
   pRadioButton& parent();
   void constructor();
   void destructor();
@@ -561,16 +564,16 @@
   Q_OBJECT
 
 public:
-  TextEdit &textEdit;
-  QTextEdit *qtTextEdit;
+  TextEdit& textEdit;
+  QTextEdit* qtTextEdit;
 
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   void setWordWrap(bool wordWrap);
   string text();
 
-  pTextEdit(TextEdit &textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
   void constructor();
   void destructor();
   void orphan();
@@ -583,15 +586,15 @@
   Q_OBJECT
 
 public:
-  VerticalScroller &verticalScroller;
-  QScrollBar *qtScroller;
+  VerticalScroller& verticalScroller;
+  QScrollBar* qtScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalScroller(VerticalScroller &verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
   void constructor();
   void destructor();
   void orphan();
@@ -604,15 +607,15 @@
   Q_OBJECT
 
 public:
-  VerticalSlider &verticalSlider;
-  QSlider *qtSlider;
+  VerticalSlider& verticalSlider;
+  QSlider* qtSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalSlider(VerticalSlider &verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
   void constructor();
   void destructor();
   void orphan();
@@ -622,19 +625,20 @@
 };
 
 struct pViewport : public pWidget {
-  Viewport &viewport;
+  Viewport& viewport;
   struct QtViewport : public QWidget {
-    pViewport &self;
+    pViewport& self;
     void leaveEvent(QEvent*);
     void mouseMoveEvent(QMouseEvent*);
     void mousePressEvent(QMouseEvent*);
     void mouseReleaseEvent(QMouseEvent*);
-    QtViewport(pViewport &self);
-  } *qtViewport;
+    QtViewport(pViewport& self);
+  };
+  QtViewport* qtViewport;
 
   uintptr_t handle();
 
-  pViewport(Viewport &viewport) : pWidget(viewport), viewport(viewport) {}
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
   void constructor();
   void destructor();
   void orphan();
diff -ru higan_v092r07\phoenix\qt\settings.cpp higan_v092r08\phoenix\qt\settings.cpp
--- higan_v092r07\phoenix\qt\settings.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\settings.cpp	Thu May 02 05:48:04 2013
@@ -3,15 +3,14 @@
 static Settings *settings = nullptr;
 
 void Settings::load() {
-  string path = {userpath(), ".config/phoenix/qt.bml"};
-  Configuration::Document::load(path);
+  string path = {userpath(), ".config/phoenix/"};
+  Configuration::Document::load({path, "qt.bml"});
 }
 
 void Settings::save() {
   string path = {userpath(), ".config/phoenix/"};
   directory::create(path, 0755);
-  path.append("qt.bml");
-  Configuration::Document::save(path);
+  Configuration::Document::save({path, "qt.bml"});
 }
 
 Settings::Settings() {
diff -ru higan_v092r07\phoenix\qt\utility.cpp higan_v092r08\phoenix\qt\utility.cpp
--- higan_v092r07\phoenix\qt\utility.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\utility.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-static QIcon CreateIcon(const nall::image &image, bool scale = false) {
+static QIcon CreateIcon(const nall::image& image, bool scale = false) {
   nall::image qtBuffer = image;
   qtBuffer.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
   if(scale) qtBuffer.scale(16, 16, Interpolation::Linear);
diff -ru higan_v092r07\phoenix\qt\widget\button.cpp higan_v092r08\phoenix\qt\widget\button.cpp
--- higan_v092r07\phoenix\qt\widget\button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\button.cpp	Thu May 02 05:48:04 2013
@@ -16,7 +16,7 @@
   return {size.width + 20, size.height + 12};
 }
 
-void pButton::setImage(const image &image, Orientation orientation) {
+void pButton::setImage(const image& image, Orientation orientation) {
   qtButton->setIconSize(QSize(image.width, image.height));
   qtButton->setIcon(CreateIcon(image));
   qtButton->setStyleSheet("text-align: top;");
@@ -26,7 +26,7 @@
   }
 }
 
-void pButton::setText(const string &text) {
+void pButton::setText(const string& text) {
   qtButton->setText(QString::fromUtf8(text));
 }
 
@@ -41,7 +41,7 @@
 
 void pButton::destructor() {
   delete qtButton;
-  qtWidget = qtButton = 0;
+  qtWidget = qtButton = nullptr;
 }
 
 void pButton::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\canvas.cpp higan_v092r08\phoenix\qt\widget\canvas.cpp
--- higan_v092r07\phoenix\qt\widget\canvas.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\canvas.cpp	Thu May 02 05:48:04 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
-void pCanvas::setSize(const Size &size) {
+void pCanvas::setSize(const Size& size) {
   delete qtImage;
   qtImage = new QImage(size.width, size.height, QImage::Format_ARGB32);
 }
 
 void pCanvas::update() {
-  uint32_t *dp = (uint32_t*)qtImage->bits(), *sp = (uint32_t*)canvas.state.data;
+  uint32_t* dp = (uint32_t*)qtImage->bits(), *sp = (uint32_t*)canvas.state.data;
   for(unsigned n = 0; n < canvas.state.width * canvas.state.height; n++) *dp++ = 0xff000000 | *sp++;
   qtCanvas->update();
 }
@@ -33,15 +33,15 @@
   constructor();
 }
 
-void pCanvas::QtCanvas::leaveEvent(QEvent *event) {
+void pCanvas::QtCanvas::leaveEvent(QEvent* event) {
   if(self.canvas.onMouseLeave) self.canvas.onMouseLeave();
 }
 
-void pCanvas::QtCanvas::mouseMoveEvent(QMouseEvent *event) {
+void pCanvas::QtCanvas::mouseMoveEvent(QMouseEvent* event) {
   if(self.canvas.onMouseMove) self.canvas.onMouseMove({event->pos().x(), event->pos().y()});
 }
 
-void pCanvas::QtCanvas::mousePressEvent(QMouseEvent *event) {
+void pCanvas::QtCanvas::mousePressEvent(QMouseEvent* event) {
   if(!self.canvas.onMousePress) return;
   switch(event->button()) {
   case Qt::LeftButton: self.canvas.onMousePress(Mouse::Button::Left); break;
@@ -50,7 +50,7 @@
   }
 }
 
-void pCanvas::QtCanvas::mouseReleaseEvent(QMouseEvent *event) {
+void pCanvas::QtCanvas::mouseReleaseEvent(QMouseEvent* event) {
   if(!self.canvas.onMouseRelease) return;
   switch(event->button()) {
   case Qt::LeftButton: self.canvas.onMouseRelease(Mouse::Button::Left); break;
@@ -59,7 +59,7 @@
   }
 }
 
-void pCanvas::QtCanvas::paintEvent(QPaintEvent *event) {
+void pCanvas::QtCanvas::paintEvent(QPaintEvent* event) {
   QPainter painter(self.qtCanvas);
   painter.drawImage(0, 0, *self.qtImage);
 
@@ -71,7 +71,7 @@
 //);
 }
 
-pCanvas::QtCanvas::QtCanvas(pCanvas &self) : self(self) {
+pCanvas::QtCanvas::QtCanvas(pCanvas& self) : self(self) {
 }
 
 }
diff -ru higan_v092r07\phoenix\qt\widget\check-button.cpp higan_v092r08\phoenix\qt\widget\check-button.cpp
--- higan_v092r07\phoenix\qt\widget\check-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\check-button.cpp	Thu May 02 05:48:04 2013
@@ -15,7 +15,7 @@
   locked = false;
 }
 
-void pCheckButton::setText(const string &text) {
+void pCheckButton::setText(const string& text) {
   qtCheckButton->setText(QString::fromUtf8(text));
 }
 
diff -ru higan_v092r07\phoenix\qt\widget\combo-button.cpp higan_v092r08\phoenix\qt\widget\combo-button.cpp
--- higan_v092r07\phoenix\qt\widget\combo-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\combo-button.cpp	Thu May 02 05:48:04 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pComboButton::append(const string &text) {
+void pComboButton::append(const string& text) {
   locked = true;
   qtComboButton->addItem(QString::fromUtf8(text));
   locked = false;
@@ -8,12 +8,12 @@
 
 Size pComboButton::minimumSize() {
   unsigned maximumWidth = 0;
-  for(auto &text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(qtWidget->font(), text).width);
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(qtWidget->font(), text).width);
   Size size = pFont::size(qtWidget->font(), " ");
   return {maximumWidth + 32, size.height + 12};
 }
 
-void pComboButton::modify(unsigned row, const string &text) {
+void pComboButton::modify(unsigned row, const string& text) {
   qtComboButton->setItemText(row, text);
 }
 
@@ -49,7 +49,7 @@
   pWidget::synchronizeState();
   unsigned selection = comboButton.state.selection;
   locked = true;
-  for(auto &text : comboButton.state.text) append(text);
+  for(auto& text : comboButton.state.text) append(text);
   locked = false;
   setSelection(selection);
 }
diff -ru higan_v092r07\phoenix\qt\widget\hex-edit.cpp higan_v092r08\phoenix\qt\widget\hex-edit.cpp
--- higan_v092r07\phoenix\qt\widget\hex-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\hex-edit.cpp	Thu May 02 05:48:04 2013
@@ -95,9 +95,9 @@
   delete qtScroll;
   delete qtLayout;
   delete qtHexEdit;
-  qtWidget = qtHexEdit = 0;
-  qtLayout = 0;
-  qtScroll = 0;
+  qtWidget = qtHexEdit = nullptr;
+  qtLayout = nullptr;
+  qtScroll = nullptr;
 }
 
 void pHexEdit::orphan() {
@@ -105,7 +105,7 @@
   constructor();
 }
 
-void pHexEdit::keyPressEvent(QKeyEvent *event) {
+void pHexEdit::keyPressEvent(QKeyEvent* event) {
   if(!hexEdit.onRead) return;
 
   QTextCursor cursor = qtHexEdit->textCursor();
@@ -184,11 +184,11 @@
   update();
 }
 
-void pHexEdit::QtHexEdit::keyPressEvent(QKeyEvent *event) {
+void pHexEdit::QtHexEdit::keyPressEvent(QKeyEvent* event) {
   self.keyPressEvent(event);
 }
 
-void pHexEdit::QtHexEdit::keyPressEventAcknowledge(QKeyEvent *event) {
+void pHexEdit::QtHexEdit::keyPressEventAcknowledge(QKeyEvent* event) {
   QTextEdit::keyPressEvent(event);
 }
 
diff -ru higan_v092r07\phoenix\qt\widget\horizontal-slider.cpp higan_v092r08\phoenix\qt\widget\horizontal-slider.cpp
--- higan_v092r07\phoenix\qt\widget\horizontal-slider.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\horizontal-slider.cpp	Thu May 02 05:48:04 2013
@@ -31,7 +31,7 @@
 
 void pHorizontalSlider::destructor() {
   delete qtSlider;
-  qtWidget = qtSlider = 0;
+  qtWidget = qtSlider = nullptr;
 }
 
 void pHorizontalSlider::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\label.cpp higan_v092r08\phoenix\qt\widget\label.cpp
--- higan_v092r07\phoenix\qt\widget\label.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\label.cpp	Thu May 02 05:48:04 2013
@@ -5,7 +5,7 @@
   return {size.width, size.height};
 }
 
-void pLabel::setText(const string &text) {
+void pLabel::setText(const string& text) {
   qtLabel->setText(QString::fromUtf8(text));
 }
 
@@ -18,7 +18,7 @@
 
 void pLabel::destructor() {
   delete qtLabel;
-  qtWidget = qtLabel = 0;
+  qtWidget = qtLabel = nullptr;
 }
 
 void pLabel::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\line-edit.cpp higan_v092r08\phoenix\qt\widget\line-edit.cpp
--- higan_v092r07\phoenix\qt\widget\line-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\line-edit.cpp	Thu May 02 05:48:04 2013
@@ -9,7 +9,7 @@
   qtLineEdit->setReadOnly(!editable);
 }
 
-void pLineEdit::setText(const string &text) {
+void pLineEdit::setText(const string& text) {
   qtLineEdit->setText(QString::fromUtf8(text));
 }
 
@@ -29,7 +29,7 @@
 
 void pLineEdit::destructor() {
   delete qtLineEdit;
-  qtWidget = qtLineEdit = 0;
+  qtWidget = qtLineEdit = nullptr;
 }
 
 void pLineEdit::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\list-view.cpp higan_v092r08\phoenix\qt\widget\list-view.cpp
--- higan_v092r07\phoenix\qt\widget\list-view.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\list-view.cpp	Thu May 02 05:48:04 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
-void pListView::append(const lstring &text) {
+void pListView::append(const lstring& text) {
   locked = true;
   auto items = qtListView->findItems("", Qt::MatchContains);
-  QTreeWidgetItem *item = new QTreeWidgetItem(qtListView);
+  QTreeWidgetItem* item = new QTreeWidgetItem(qtListView);
 
   item->setData(0, Qt::UserRole, (unsigned)items.size());
   if(listView.state.checkable) item->setCheckState(0, Qt::Unchecked);
@@ -18,13 +18,13 @@
 }
 
 bool pListView::checked(unsigned row) {
-  QTreeWidgetItem *item = qtListView->topLevelItem(row);
+  QTreeWidgetItem* item = qtListView->topLevelItem(row);
   return item ? item->checkState(0) == Qt::Checked : false;
 }
 
-void pListView::modify(unsigned row, const lstring &text) {
+void pListView::modify(unsigned row, const lstring& text) {
   locked = true;
-  QTreeWidgetItem *item = qtListView->topLevelItem(row);
+  QTreeWidgetItem* item = qtListView->topLevelItem(row);
   if(item == nullptr) return;
   for(unsigned n = 0; n < text.size(); n++) {
     item->setText(n, QString::fromUtf8(text[n]));
@@ -34,7 +34,7 @@
 
 void pListView::remove(unsigned row) {
   locked = true;
-  QTreeWidgetItem *item = qtListView->topLevelItem(row);
+  QTreeWidgetItem* item = qtListView->topLevelItem(row);
   if(item == nullptr) return;
   delete item;
   locked = false;
@@ -45,12 +45,12 @@
 }
 
 bool pListView::selected() {
-  QTreeWidgetItem *item = qtListView->currentItem();
+  QTreeWidgetItem* item = qtListView->currentItem();
   return (item && item->isSelected() == true);
 }
 
 unsigned pListView::selection() {
-  QTreeWidgetItem *item = qtListView->currentItem();
+  QTreeWidgetItem* item = qtListView->currentItem();
   if(item == 0) return 0;
   return item->data(0, Qt::UserRole).toUInt();
 }
@@ -64,14 +64,14 @@
 
 void pListView::setChecked(unsigned row, bool checked) {
   locked = true;
-  QTreeWidgetItem *item = qtListView->topLevelItem(row);
+  QTreeWidgetItem* item = qtListView->topLevelItem(row);
   if(item) item->setCheckState(0, checked ? Qt::Checked : Qt::Unchecked);
   locked = false;
 }
 
-void pListView::setHeaderText(const lstring &text) {
+void pListView::setHeaderText(const lstring& text) {
   QStringList labels;
-  for(auto &column : text) labels << QString::fromUtf8(column);
+  for(auto& column : text) labels << QString::fromUtf8(column);
 
   qtListView->setColumnCount(text.size());
   qtListView->setAlternatingRowColors(text.size() >= 2);
@@ -84,8 +84,8 @@
   autoSizeColumns();
 }
 
-void pListView::setImage(unsigned row, unsigned column, const nall::image &image) {
-  QTreeWidgetItem *item = qtListView->topLevelItem(row);
+void pListView::setImage(unsigned row, unsigned column, const nall::image& image) {
+  QTreeWidgetItem* item = qtListView->topLevelItem(row);
   if(item) {
     if(image.empty() == 0) item->setIcon(column, CreateIcon(image));
     if(image.empty() == 1) item->setIcon(column, QIcon());
@@ -93,13 +93,13 @@
 }
 
 void pListView::setSelected(bool selected) {
-  QTreeWidgetItem *item = qtListView->currentItem();
+  QTreeWidgetItem* item = qtListView->currentItem();
   if(item) item->setSelected(selected);
 }
 
 void pListView::setSelection(unsigned row) {
   locked = true;
-  QTreeWidgetItem *item = qtListView->currentItem();
+  QTreeWidgetItem* item = qtListView->currentItem();
   if(item) item->setSelected(false);
   qtListView->setCurrentItem(0);
   auto items = qtListView->findItems("", Qt::MatchContains);
@@ -125,7 +125,7 @@
   setCheckable(listView.state.checkable);
   setHeaderText(listView.state.headerText.size() ? listView.state.headerText : lstring{ " " });
   setHeaderVisible(listView.state.headerVisible);
-  for(auto &row : listView.state.text) append(row);
+  for(auto& row : listView.state.text) append(row);
   if(listView.state.checkable) {
     for(unsigned n = 0; n < listView.state.checked.size(); n++) {
       setChecked(n, listView.state.checked[n]);
@@ -138,7 +138,7 @@
 
 void pListView::destructor() {
   delete qtListView;
-  qtWidget = qtListView = 0;
+  qtWidget = qtListView = nullptr;
 }
 
 void pListView::orphan() {
@@ -150,7 +150,7 @@
   if(locked == false && listView.onActivate) listView.onActivate();
 }
 
-void pListView::onChange(QTreeWidgetItem *item) {
+void pListView::onChange(QTreeWidgetItem* item) {
   //Qt bug workaround: clicking items with mouse does not mark items as selected
   if(item) item->setSelected(true);
   listView.state.selected = selected();
@@ -158,7 +158,7 @@
   if(locked == false && listView.onChange) listView.onChange();
 }
 
-void pListView::onToggle(QTreeWidgetItem *item) {
+void pListView::onToggle(QTreeWidgetItem* item) {
   unsigned row = item->data(0, Qt::UserRole).toUInt();
   bool checkState = checked(row);
   listView.state.checked[row] = checkState;
diff -ru higan_v092r07\phoenix\qt\widget\progress-bar.cpp higan_v092r08\phoenix\qt\widget\progress-bar.cpp
--- higan_v092r07\phoenix\qt\widget\progress-bar.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\progress-bar.cpp	Thu May 02 05:48:04 2013
@@ -19,7 +19,7 @@
 
 void pProgressBar::destructor() {
   delete qtProgressBar;
-  qtWidget = qtProgressBar = 0;
+  qtWidget = qtProgressBar = nullptr;
 }
 
 void pProgressBar::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\radio-button.cpp higan_v092r08\phoenix\qt\widget\radio-button.cpp
--- higan_v092r07\phoenix\qt\widget\radio-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\radio-button.cpp	Thu May 02 05:48:04 2013
@@ -18,20 +18,20 @@
   parent().locked = false;
 }
 
-void pRadioButton::setGroup(const group<RadioButton&> &group) {
+void pRadioButton::setGroup(const group<RadioButton>& group) {
   parent().locked = true;
-  for(auto &item : radioButton.state.group) {
+  for(auto& item : radioButton.state.group) {
     item.p.qtRadioButton->setChecked(item.state.checked);
   }
   parent().locked = false;
 }
 
-void pRadioButton::setText(const string &text) {
+void pRadioButton::setText(const string& text) {
   qtRadioButton->setText(QString::fromUtf8(text));
 }
 
 pRadioButton& pRadioButton::parent() {
-  if(radioButton.state.group.size()) return radioButton.state.group[0].p;
+  if(radioButton.state.group.size()) return radioButton.state.group.first().p;
   return *this;
 }
 
diff -ru higan_v092r07\phoenix\qt\widget\text-edit.cpp higan_v092r08\phoenix\qt\widget\text-edit.cpp
--- higan_v092r07\phoenix\qt\widget\text-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\text-edit.cpp	Thu May 02 05:48:04 2013
@@ -11,7 +11,7 @@
   qtTextEdit->setReadOnly(!editable);
 }
 
-void pTextEdit::setText(const string &text) {
+void pTextEdit::setText(const string& text) {
   qtTextEdit->setPlainText(QString::fromUtf8(text));
 }
 
@@ -38,7 +38,7 @@
 void pTextEdit::destructor() {
   if(sizable.state.layout) sizable.state.layout->remove(textEdit);
   delete qtTextEdit;
-  qtWidget = qtTextEdit = 0;
+  qtWidget = qtTextEdit = nullptr;
 }
 
 void pTextEdit::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\vertical-slider.cpp higan_v092r08\phoenix\qt\widget\vertical-slider.cpp
--- higan_v092r07\phoenix\qt\widget\vertical-slider.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\vertical-slider.cpp	Thu May 02 05:48:04 2013
@@ -31,7 +31,7 @@
 
 void pVerticalSlider::destructor() {
   delete qtSlider;
-  qtWidget = qtSlider = 0;
+  qtWidget = qtSlider = nullptr;
 }
 
 void pVerticalSlider::orphan() {
diff -ru higan_v092r07\phoenix\qt\widget\viewport.cpp higan_v092r08\phoenix\qt\widget\viewport.cpp
--- higan_v092r07\phoenix\qt\widget\viewport.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\viewport.cpp	Thu May 02 05:48:04 2013
@@ -23,15 +23,15 @@
   constructor();
 }
 
-void pViewport::QtViewport::leaveEvent(QEvent *event) {
+void pViewport::QtViewport::leaveEvent(QEvent* event) {
   if(self.viewport.onMouseLeave) self.viewport.onMouseLeave();
 }
 
-void pViewport::QtViewport::mouseMoveEvent(QMouseEvent *event) {
-  if(self.viewport.onMouseMove) self.viewport.onMouseMove({ event->pos().x(), event->pos().y() });
+void pViewport::QtViewport::mouseMoveEvent(QMouseEvent* event) {
+  if(self.viewport.onMouseMove) self.viewport.onMouseMove({event->pos().x(), event->pos().y()});
 }
 
-void pViewport::QtViewport::mousePressEvent(QMouseEvent *event) {
+void pViewport::QtViewport::mousePressEvent(QMouseEvent* event) {
   if(!self.viewport.onMousePress) return;
   switch(event->button()) {
   case Qt::LeftButton: self.viewport.onMousePress(Mouse::Button::Left); break;
@@ -40,7 +40,7 @@
   }
 }
 
-void pViewport::QtViewport::mouseReleaseEvent(QMouseEvent *event) {
+void pViewport::QtViewport::mouseReleaseEvent(QMouseEvent* event) {
   if(!self.viewport.onMouseRelease) return;
   switch(event->button()) {
   case Qt::LeftButton: self.viewport.onMouseRelease(Mouse::Button::Left); break;
@@ -49,7 +49,7 @@
   }
 }
 
-pViewport::QtViewport::QtViewport(pViewport &self) : self(self) {
+pViewport::QtViewport::QtViewport(pViewport& self) : self(self) {
 }
 
 }
diff -ru higan_v092r07\phoenix\qt\widget\widget.cpp higan_v092r08\phoenix\qt\widget\widget.cpp
--- higan_v092r07\phoenix\qt\widget\widget.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\widget\widget.cpp	Thu May 02 05:48:04 2013
@@ -18,11 +18,11 @@
   qtWidget->setFocus(Qt::OtherFocusReason);
 }
 
-void pWidget::setFont(const string &font) {
+void pWidget::setFont(const string& font) {
   qtWidget->setFont(pFont::create(font));
 }
 
-void pWidget::setGeometry(const Geometry &geometry) {
+void pWidget::setGeometry(const Geometry& geometry) {
   qtWidget->setGeometry(geometry.x, geometry.y, geometry.width, geometry.height);
 }
 
@@ -48,7 +48,7 @@
 void pWidget::destructor() {
   if(widget.state.abstract) {
     delete qtWidget;
-    qtWidget = 0;
+    qtWidget = nullptr;
   }
 }
 
diff -ru higan_v092r07\phoenix\qt\window.cpp higan_v092r08\phoenix\qt\window.cpp
--- higan_v092r07\phoenix\qt\window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\qt\window.cpp	Thu May 02 05:48:04 2013
@@ -1,24 +1,24 @@
 namespace phoenix {
 
 Window& pWindow::none() {
-  static Window *window = nullptr;
+  static Window* window = nullptr;
   if(window == nullptr) window = new Window;
   return *window;
 }
 
-void pWindow::append(Layout &layout) {
+void pWindow::append(Layout& layout) {
   Geometry geometry = window.state.geometry;
   geometry.x = geometry.y = 0;
   layout.setGeometry(geometry);
 }
 
-void pWindow::append(Menu &menu) {
+void pWindow::append(Menu& menu) {
   if(window.state.menuFont != "") menu.p.setFont(window.state.menuFont);
   else menu.p.setFont("Sans, 8");
   qtMenu->addMenu(menu.p.qtMenu);
 }
 
-void pWindow::append(Widget &widget) {
+void pWindow::append(Widget& widget) {
   if(widget.font().empty() && !window.state.widgetFont.empty()) {
     widget.setFont(window.state.widgetFont);
   }
@@ -53,27 +53,27 @@
   if(window.state.fullScreen) {
     unsigned menuHeight = window.state.menuVisible ? qtMenu->height() : 0;
     unsigned statusHeight = window.state.statusVisible ? qtStatus->height() : 0;
-    return { 0, menuHeight, Desktop::size().width, Desktop::size().height - menuHeight - statusHeight };
+    return {0, menuHeight, Desktop::size().width, Desktop::size().height - menuHeight - statusHeight};
   }
   return window.state.geometry;
 }
 
-void pWindow::remove(Layout &layout) {
+void pWindow::remove(Layout& layout) {
 }
 
-void pWindow::remove(Menu &menu) {
+void pWindow::remove(Menu& menu) {
   //QMenuBar::removeMenu() does not exist
   qtMenu->clear();
-  for(auto &menu : window.state.menu) append(menu);
+  for(auto& menu : window.state.menu) append(menu);
 }
 
-void pWindow::remove(Widget &widget) {
+void pWindow::remove(Widget& widget) {
   //orphan() destroys and recreates widgets (to disassociate them from their parent);
   //attempting to create widget again after QApplication::quit() crashes libQtGui
   if(qtApplication) widget.p.orphan();
 }
 
-void pWindow::setBackgroundColor(const Color &color) {
+void pWindow::setBackgroundColor(const Color& color) {
   QPalette palette;
   palette.setColor(QPalette::Window, QColor(color.red, color.green, color.blue, color.alpha));
   qtContainer->setPalette(palette);
@@ -98,7 +98,7 @@
   }
 }
 
-void pWindow::setGeometry(const Geometry &geometry_) {
+void pWindow::setGeometry(const Geometry& geometry_) {
   locked = true;
   Application::processEvents();
   QApplication::syncX();
@@ -114,7 +114,7 @@
     qtContainer->setMinimumSize(1, 1);
   }
 
-  for(auto &layout : window.state.layout) {
+  for(auto& layout : window.state.layout) {
     geometry = geometry_;
     geometry.x = geometry.y = 0;
     layout.setGeometry(geometry);
@@ -122,9 +122,9 @@
   locked = false;
 }
 
-void pWindow::setMenuFont(const string &font) {
+void pWindow::setMenuFont(const string& font) {
   qtMenu->setFont(pFont::create(font));
-  for(auto &item : window.state.menu) item.p.setFont(font);
+  for(auto& item : window.state.menu) item.p.setFont(font);
 }
 
 void pWindow::setMenuVisible(bool visible) {
@@ -157,11 +157,11 @@
   qtStatus->setSizeGripEnabled(resizable);
 }
 
-void pWindow::setStatusFont(const string &font) {
+void pWindow::setStatusFont(const string& font) {
   qtStatus->setFont(pFont::create(font));
 }
 
-void pWindow::setStatusText(const string &text) {
+void pWindow::setStatusText(const string& text) {
   qtStatus->showMessage(QString::fromUtf8(text), 0);
 }
 
@@ -170,7 +170,7 @@
   setGeometry(window.state.geometry);
 }
 
-void pWindow::setTitle(const string &text) {
+void pWindow::setTitle(const string& text) {
   qtWindow->setWindowTitle(QString::fromUtf8(text));
 }
 
@@ -184,7 +184,7 @@
   locked = false;
 }
 
-void pWindow::setWidgetFont(const string &font) {
+void pWindow::setWidgetFont(const string& font) {
 }
 
 void pWindow::constructor() {
@@ -255,14 +255,14 @@
   settings->save();
 }
 
-void pWindow::QtWindow::closeEvent(QCloseEvent *event) {
+void pWindow::QtWindow::closeEvent(QCloseEvent* event) {
   event->ignore();
   if(self.window.onClose) self.window.onClose();
   else self.window.setVisible(false);
   if(self.window.state.modal && !self.window.visible()) self.window.setModal(false);
 }
 
-void pWindow::QtWindow::moveEvent(QMoveEvent *event) {
+void pWindow::QtWindow::moveEvent(QMoveEvent* event) {
   if(self.locked == false && self.window.state.fullScreen == false && self.qtWindow->isVisible() == true) {
     self.window.state.geometry.x += event->pos().x() - event->oldPos().x();
     self.window.state.geometry.y += event->pos().y() - event->oldPos().y();
@@ -273,12 +273,12 @@
   }
 }
 
-void pWindow::QtWindow::keyPressEvent(QKeyEvent *event) {
+void pWindow::QtWindow::keyPressEvent(QKeyEvent* event) {
   Keyboard::Keycode sym = Keysym(event->nativeVirtualKey());
   if(sym != Keyboard::Keycode::None && self.window.onKeyPress) self.window.onKeyPress(sym);
 }
 
-void pWindow::QtWindow::keyReleaseEvent(QKeyEvent *event) {
+void pWindow::QtWindow::keyReleaseEvent(QKeyEvent* event) {
   Keyboard::Keycode sym = Keysym(event->nativeVirtualKey());
   if(sym != Keyboard::Keycode::None && self.window.onKeyRelease) self.window.onKeyRelease(sym);
 }
@@ -289,7 +289,7 @@
     self.window.state.geometry.height = self.qtContainer->geometry().height();
   }
 
-  for(auto &layout : self.window.state.layout) {
+  for(auto& layout : self.window.state.layout) {
     Geometry geometry = self.geometry();
     geometry.x = geometry.y = 0;
     layout.setGeometry(geometry);
diff -ru higan_v092r07\phoenix\reference\action\action.hpp higan_v092r08\phoenix\reference\action\action.hpp
--- higan_v092r07\phoenix\reference\action\action.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\action.hpp	Thu May 02 05:48:05 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
 struct pAction : public pObject {
-  Action &action;
+  Action& action;
 
   void setEnabled(bool enabled);
   void setVisible(bool visible);
 
-  pAction(Action &action) : pObject(action), action(action) {}
+  pAction(Action& action) : pObject(action), action(action) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\action\check-item.cpp higan_v092r08\phoenix\reference\action\check-item.cpp
--- higan_v092r07\phoenix\reference\action\check-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\check-item.cpp	Thu May 02 05:48:05 2013
@@ -7,7 +7,7 @@
 void pCheckItem::setChecked(bool checked) {
 }
 
-void pCheckItem::setText(const string &text) {
+void pCheckItem::setText(const string& text) {
 }
 
 void pCheckItem::constructor() {
diff -ru higan_v092r07\phoenix\reference\action\check-item.hpp higan_v092r08\phoenix\reference\action\check-item.hpp
--- higan_v092r07\phoenix\reference\action\check-item.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\check-item.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pCheckItem : public pAction {
-  CheckItem &checkItem;
+  CheckItem& checkItem;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckItem(CheckItem &checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\action\item.cpp higan_v092r08\phoenix\reference\action\item.cpp
--- higan_v092r07\phoenix\reference\action\item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\item.cpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
-void pItem::setImage(const image &image) {
+void pItem::setImage(const image& image) {
 }
 
-void pItem::setText(const string &text) {
+void pItem::setText(const string& text) {
 }
 
 void pItem::constructor() {
diff -ru higan_v092r07\phoenix\reference\action\item.hpp higan_v092r08\phoenix\reference\action\item.hpp
--- higan_v092r07\phoenix\reference\action\item.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\item.hpp	Thu May 02 05:48:05 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
 struct pItem : public pAction {
-  Item &item;
+  Item& item;
 
-  void setImage(const image &image);
-  void setText(const string &text);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pItem(Item &item) : pAction(item), item(item) {}
+  pItem(Item& item) : pAction(item), item(item) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\action\menu.cpp higan_v092r08\phoenix\reference\action\menu.cpp
--- higan_v092r07\phoenix\reference\action\menu.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\menu.cpp	Thu May 02 05:48:05 2013
@@ -1,15 +1,15 @@
 namespace phoenix {
 
-void pMenu::append(Action &action) {
+void pMenu::append(Action& action) {
 }
 
-void pMenu::remove(Action &action) {
+void pMenu::remove(Action& action) {
 }
 
-void pMenu::setImage(const image &image) {
+void pMenu::setImage(const image& image) {
 }
 
-void pMenu::setText(const string &text) {
+void pMenu::setText(const string& text) {
 }
 
 void pMenu::constructor() {
diff -ru higan_v092r07\phoenix\reference\action\menu.hpp higan_v092r08\phoenix\reference\action\menu.hpp
--- higan_v092r07\phoenix\reference\action\menu.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\menu.hpp	Thu May 02 05:48:05 2013
@@ -1,14 +1,14 @@
 namespace phoenix {
 
 struct pMenu : public pAction {
-  Menu &menu;
+  Menu& menu;
 
-  void append(Action &action);
-  void remove(Action &action);
-  void setImage(const image &image);
-  void setText(const string &text);
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pMenu(Menu &menu) : pAction(menu), menu(menu) {}
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\action\radio-item.cpp higan_v092r08\phoenix\reference\action\radio-item.cpp
--- higan_v092r07\phoenix\reference\action\radio-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\radio-item.cpp	Thu May 02 05:48:05 2013
@@ -7,10 +7,10 @@
 void pRadioItem::setChecked() {
 }
 
-void pRadioItem::setGroup(const group<RadioItem&> &group) {
+void pRadioItem::setGroup(const group<RadioItem>& group) {
 }
 
-void pRadioItem::setText(const string &text) {
+void pRadioItem::setText(const string& text) {
 }
 
 void pRadioItem::constructor() {
diff -ru higan_v092r07\phoenix\reference\action\radio-item.hpp higan_v092r08\phoenix\reference\action\radio-item.hpp
--- higan_v092r07\phoenix\reference\action\radio-item.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\radio-item.hpp	Thu May 02 05:48:05 2013
@@ -1,14 +1,14 @@
 namespace phoenix {
 
 struct pRadioItem : public pAction {
-  RadioItem &radioItem;
+  RadioItem& radioItem;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioItem&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioItem>& group);
+  void setText(const string& text);
 
-  pRadioItem(RadioItem &radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\action\separator.hpp higan_v092r08\phoenix\reference\action\separator.hpp
--- higan_v092r07\phoenix\reference\action\separator.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\action\separator.hpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pSeparator : public pAction {
-  Separator &separator;
+  Separator& separator;
 
-  pSeparator(Separator &separator) : pAction(separator), separator(separator) {}
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\browser-window.cpp higan_v092r08\phoenix\reference\browser-window.cpp
--- higan_v092r07\phoenix\reference\browser-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\browser-window.cpp	Thu May 02 05:48:05 2013
@@ -1,14 +1,14 @@
 namespace phoenix {
 
-string pBrowserWindow::directory(BrowserWindow::State &state) {
+string pBrowserWindow::directory(BrowserWindow::State& state) {
   return "";
 }
 
-string pBrowserWindow::open(BrowserWindow::State &state) {
+string pBrowserWindow::open(BrowserWindow::State& state) {
   return "";
 }
 
-string pBrowserWindow::save(BrowserWindow::State &state) {
+string pBrowserWindow::save(BrowserWindow::State& state) {
   return "";
 }
 
diff -ru higan_v092r07\phoenix\reference\browser-window.hpp higan_v092r08\phoenix\reference\browser-window.hpp
--- higan_v092r07\phoenix\reference\browser-window.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\browser-window.hpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pBrowserWindow {
-  static string directory(BrowserWindow::State &state);
-  static string open(BrowserWindow::State &state);
-  static string save(BrowserWindow::State &state);
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
 };
 
 }
diff -ru higan_v092r07\phoenix\reference\font.cpp higan_v092r08\phoenix\reference\font.cpp
--- higan_v092r07\phoenix\reference\font.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\font.cpp	Thu May 02 05:48:05 2013
@@ -12,7 +12,7 @@
   return "";
 }
 
-Size pFont::size(const string &font, const string &text) {
+Size pFont::size(const string& font, const string& text) {
   return {0, 0};
 }
 
diff -ru higan_v092r07\phoenix\reference\font.hpp higan_v092r08\phoenix\reference\font.hpp
--- higan_v092r07\phoenix\reference\font.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\font.hpp	Thu May 02 05:48:05 2013
@@ -4,7 +4,7 @@
   static string serif(unsigned size, string style);
   static string sans(unsigned size, string style);
   static string monospace(unsigned size, string style);
-  static Size size(const string &font, const string &text);
+  static Size size(const string& font, const string& text);
 };
 
 }
diff -ru higan_v092r07\phoenix\reference\keyboard.cpp higan_v092r08\phoenix\reference\keyboard.cpp
--- higan_v092r07\phoenix\reference\keyboard.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\keyboard.cpp	Thu May 02 05:48:05 2013
@@ -7,7 +7,7 @@
 vector<bool> pKeyboard::state() {
   vector<bool> output;
   output.resize((unsigned)Keyboard::Scancode::Limit);
-  for(auto &n : output) n = false;
+  for(auto& n : output) n = false;
   return output;
 }
 
diff -ru higan_v092r07\phoenix\reference\message-window.cpp higan_v092r08\phoenix\reference\message-window.cpp
--- higan_v092r07\phoenix\reference\message-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\message-window.cpp	Thu May 02 05:48:05 2013
@@ -1,18 +1,18 @@
 namespace phoenix {
 
-MessageWindow::Response pMessageWindow::error(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
   return MessageWindow::Response::Ok;
 }
 
-MessageWindow::Response pMessageWindow::information(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
   return MessageWindow::Response::Ok;
 }
 
-MessageWindow::Response pMessageWindow::question(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
   return MessageWindow::Response::Ok;
 }
 
-MessageWindow::Response pMessageWindow::warning(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
   return MessageWindow::Response::Ok;
 }
 
diff -ru higan_v092r07\phoenix\reference\message-window.hpp higan_v092r08\phoenix\reference\message-window.hpp
--- higan_v092r07\phoenix\reference\message-window.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\message-window.hpp	Thu May 02 05:48:05 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 struct pMessageWindow {
-  static MessageWindow::Response error(MessageWindow::State &state);
-  static MessageWindow::Response information(MessageWindow::State &state);
-  static MessageWindow::Response question(MessageWindow::State &state);
-  static MessageWindow::Response warning(MessageWindow::State &state);
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
 };
 
 }
diff -ru higan_v092r07\phoenix\reference\object.hpp higan_v092r08\phoenix\reference\object.hpp
--- higan_v092r07\phoenix\reference\object.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\object.hpp	Thu May 02 05:48:05 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 struct pObject {
-  Object &object;
+  Object& object;
   bool locked;
 
-  pObject(Object &object) : object(object), locked(locked) {}
+  pObject(Object& object) : object(object), locked(locked) {}
   virtual ~pObject() {}
 
   void constructor();
diff -ru higan_v092r07\phoenix\reference\timer.hpp higan_v092r08\phoenix\reference\timer.hpp
--- higan_v092r07\phoenix\reference\timer.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\timer.hpp	Thu May 02 05:48:05 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
 struct pTimer : public pObject {
-  Timer &timer;
+  Timer& timer;
 
   void setEnabled(bool enabled);
   void setInterval(unsigned milliseconds);
 
-  pTimer(Timer &timer) : pObject(timer), timer(timer) {}
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\button.cpp higan_v092r08\phoenix\reference\widget\button.cpp
--- higan_v092r07\phoenix\reference\widget\button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\button.cpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
-void pButton::setImage(const image &image, Orientation orientation) {
+void pButton::setImage(const image& image, Orientation orientation) {
 }
 
-void pButton::setText(const string &text) {
+void pButton::setText(const string& text) {
 }
 
 void pButton::constructor() {
diff -ru higan_v092r07\phoenix\reference\widget\button.hpp higan_v092r08\phoenix\reference\widget\button.hpp
--- higan_v092r07\phoenix\reference\widget\button.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\button.hpp	Thu May 02 05:48:05 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
 struct pButton : public pWidget {
-  Button &button;
+  Button& button;
 
-  void setImage(const image &image, Orientation orientation);
-  void setText(const string &text);
+  void setImage(const image& image, Orientation orientation);
+  void setText(const string& text);
 
-  pButton(Button &button) : pWidget(button), button(button) {}
+  pButton(Button& button) : pWidget(button), button(button) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\canvas.cpp higan_v092r08\phoenix\reference\widget\canvas.cpp
--- higan_v092r07\phoenix\reference\widget\canvas.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\canvas.cpp	Thu May 02 05:48:05 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pCanvas::setSize(const Size &size) {
+void pCanvas::setSize(const Size& size) {
 }
 
 void pCanvas::update() {
diff -ru higan_v092r07\phoenix\reference\widget\canvas.hpp higan_v092r08\phoenix\reference\widget\canvas.hpp
--- higan_v092r07\phoenix\reference\widget\canvas.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\canvas.hpp	Thu May 02 05:48:05 2013
@@ -1,12 +1,12 @@
 namespace phoenix {
 
 struct pCanvas : public pWidget {
-  Canvas &canvas;
+  Canvas& canvas;
 
-  void setSize(const Size &size);
+  void setSize(const Size& size);
   void update();
 
-  pCanvas(Canvas &canvas) : pWidget(canvas), canvas(canvas) {}
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\check-button.cpp higan_v092r08\phoenix\reference\widget\check-button.cpp
--- higan_v092r07\phoenix\reference\widget\check-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\check-button.cpp	Thu May 02 05:48:05 2013
@@ -7,7 +7,7 @@
 void pCheckButton::setChecked(bool checked) {
 }
 
-void pCheckButton::setText(const string &text) {
+void pCheckButton::setText(const string& text) {
 }
 
 void pCheckButton::constructor() {
diff -ru higan_v092r07\phoenix\reference\widget\check-button.hpp higan_v092r08\phoenix\reference\widget\check-button.hpp
--- higan_v092r07\phoenix\reference\widget\check-button.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\check-button.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pCheckButton : public pWidget {
-  CheckButton &checkButton;
+  CheckButton& checkButton;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckButton(CheckButton &checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\combo-button.cpp higan_v092r08\phoenix\reference\widget\combo-button.cpp
--- higan_v092r07\phoenix\reference\widget\combo-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\combo-button.cpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
-void pComboButton::append(const string &text) {
+void pComboButton::append(const string& text) {
 }
 
-void pComboButton::modify(unsigned row, const string &text) {
+void pComboButton::modify(unsigned row, const string& text) {
 }
 
 void pComboButton::remove(unsigned row) {
diff -ru higan_v092r07\phoenix\reference\widget\combo-button.hpp higan_v092r08\phoenix\reference\widget\combo-button.hpp
--- higan_v092r07\phoenix\reference\widget\combo-button.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\combo-button.hpp	Thu May 02 05:48:05 2013
@@ -1,16 +1,16 @@
 namespace phoenix {
 
 struct pComboButton : public pWidget {
-  ComboButton &comboButton;
+  ComboButton& comboButton;
 
-  void append(const string &text);
-  void modify(unsigned row, const string &text);
+  void append(const string& text);
+  void modify(unsigned row, const string& text);
   void remove(unsigned row);
   void reset();
   unsigned selection();
   void setSelection(unsigned row);
 
-  pComboButton(ComboButton &comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\hex-edit.hpp higan_v092r08\phoenix\reference\widget\hex-edit.hpp
--- higan_v092r07\phoenix\reference\widget\hex-edit.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\hex-edit.hpp	Thu May 02 05:48:05 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
 struct pHexEdit : public pWidget {
-  HexEdit &hexEdit;
+  HexEdit& hexEdit;
 
   void setColumns(unsigned columns);
   void setLength(unsigned length);
@@ -9,7 +9,7 @@
   void setRows(unsigned rows);
   void update();
 
-  pHexEdit(HexEdit &hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\horizontal-scroller.hpp higan_v092r08\phoenix\reference\widget\horizontal-scroller.hpp
--- higan_v092r07\phoenix\reference\widget\horizontal-scroller.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\horizontal-scroller.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pHorizontalScroller : public pWidget {
-  HorizontalScroller &horizontalScroller;
+  HorizontalScroller& horizontalScroller;
 
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalScroller(HorizontalScroller &horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\horizontal-slider.hpp higan_v092r08\phoenix\reference\widget\horizontal-slider.hpp
--- higan_v092r07\phoenix\reference\widget\horizontal-slider.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\horizontal-slider.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pHorizontalSlider : public pWidget {
-  HorizontalSlider &horizontalSlider;
+  HorizontalSlider& horizontalSlider;
 
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalSlider(HorizontalSlider &horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\label.cpp higan_v092r08\phoenix\reference\widget\label.cpp
--- higan_v092r07\phoenix\reference\widget\label.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\label.cpp	Thu May 02 05:48:05 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pLabel::setText(const string &text) {
+void pLabel::setText(const string& text) {
 }
 
 void pLabel::constructor() {
diff -ru higan_v092r07\phoenix\reference\widget\label.hpp higan_v092r08\phoenix\reference\widget\label.hpp
--- higan_v092r07\phoenix\reference\widget\label.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\label.hpp	Thu May 02 05:48:05 2013
@@ -1,11 +1,11 @@
 namespace phoenix {
 
 struct pLabel : public pWidget {
-  Label &label;
+  Label& label;
 
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pLabel(Label &label) : pWidget(label), label(label) {}
+  pLabel(Label& label) : pWidget(label), label(label) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\layout.hpp higan_v092r08\phoenix\reference\widget\layout.hpp
--- higan_v092r07\phoenix\reference\widget\layout.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\layout.hpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pLayout : public pSizable {
-  Layout &layout;
+  Layout& layout;
 
-  pLayout(Layout &layout) : pSizable(layout), layout(layout) {}
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
 };
 
 }
diff -ru higan_v092r07\phoenix\reference\widget\line-edit.cpp higan_v092r08\phoenix\reference\widget\line-edit.cpp
--- higan_v092r07\phoenix\reference\widget\line-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\line-edit.cpp	Thu May 02 05:48:05 2013
@@ -3,7 +3,7 @@
 void pLineEdit::setEditable(bool editable) {
 }
 
-void pLineEdit::setText(const string &text) {
+void pLineEdit::setText(const string& text) {
 }
 
 string pLineEdit::text() {
diff -ru higan_v092r07\phoenix\reference\widget\line-edit.hpp higan_v092r08\phoenix\reference\widget\line-edit.hpp
--- higan_v092r07\phoenix\reference\widget\line-edit.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\line-edit.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pLineEdit : public pWidget {
-  LineEdit &lineEdit;
+  LineEdit& lineEdit;
 
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   string text();
 
-  pLineEdit(LineEdit &lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\list-view.cpp higan_v092r08\phoenix\reference\widget\list-view.cpp
--- higan_v092r07\phoenix\reference\widget\list-view.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\list-view.cpp	Thu May 02 05:48:05 2013
@@ -1,6 +1,6 @@
 namespace phoenix {
 
-void pListView::append(const lstring &text) {
+void pListView::append(const lstring& text) {
 }
 
 void pListView::autoSizeColumns() {
@@ -9,7 +9,7 @@
 bool pListView::checked(unsigned row) {
 }
 
-void pListView::modify(unsigned row, const lstring &text) {
+void pListView::modify(unsigned row, const lstring& text) {
 }
 
 void pListView::remove(unsigned row) {
@@ -32,13 +32,13 @@
 void pListView::setChecked(unsigned row, bool checked) {
 }
 
-void pListView::setHeaderText(const lstring &text) {
+void pListView::setHeaderText(const lstring& text) {
 }
 
 void pListView::setHeaderVisible(bool visible) {
 }
 
-void pListView::setImage(unsigned row, unsigned column, const image &image) {
+void pListView::setImage(unsigned row, unsigned column, const image& image) {
 }
 
 void pListView::setSelected(bool selected) {
diff -ru higan_v092r07\phoenix\reference\widget\list-view.hpp higan_v092r08\phoenix\reference\widget\list-view.hpp
--- higan_v092r07\phoenix\reference\widget\list-view.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\list-view.hpp	Thu May 02 05:48:05 2013
@@ -1,25 +1,25 @@
 namespace phoenix {
 
 struct pListView : public pWidget {
-  ListView &listView;
+  ListView& listView;
 
-  void append(const lstring &text);
+  void append(const lstring& text);
   void autoSizeColumns();
   bool checked(unsigned row);
-  void modify(unsigned row, const lstring &text);
+  void modify(unsigned row, const lstring& text);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable);
   void setChecked(unsigned row, bool checked);
-  void setHeaderText(const lstring &text);
+  void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
-  void setImage(unsigned row, unsigned column, const image &image);
+  void setImage(unsigned row, unsigned column, const image& image);
   void setSelected(bool selected);
   void setSelection(unsigned row);
 
-  pListView(ListView &listView) : pWidget(listView), listView(listView) {}
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\progress-bar.hpp higan_v092r08\phoenix\reference\widget\progress-bar.hpp
--- higan_v092r07\phoenix\reference\widget\progress-bar.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\progress-bar.hpp	Thu May 02 05:48:05 2013
@@ -1,11 +1,11 @@
 namespace phoenix {
 
 struct pProgressBar : public pWidget {
-  ProgressBar &progressBar;
+  ProgressBar& progressBar;
 
   void setPosition(unsigned position);
 
-  pProgressBar(ProgressBar &progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\radio-button.cpp higan_v092r08\phoenix\reference\widget\radio-button.cpp
--- higan_v092r07\phoenix\reference\widget\radio-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\radio-button.cpp	Thu May 02 05:48:05 2013
@@ -7,10 +7,10 @@
 void pRadioButton::setChecked() {
 }
 
-void pRadioButton::setGroup(const group<RadioButton&> &group) {
+void pRadioButton::setGroup(const group<RadioButton>& group) {
 }
 
-void pRadioButton::setText(const string &text) {
+void pRadioButton::setText(const string& text) {
 }
 
 void pRadioButton::constructor() {
diff -ru higan_v092r07\phoenix\reference\widget\radio-button.hpp higan_v092r08\phoenix\reference\widget\radio-button.hpp
--- higan_v092r07\phoenix\reference\widget\radio-button.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\radio-button.hpp	Thu May 02 05:48:05 2013
@@ -1,14 +1,14 @@
 namespace phoenix {
 
 struct pRadioButton : public pWidget {
-  RadioButton &radioButton;
+  RadioButton& radioButton;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioButton&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioButton>& group);
+  void setText(const string& text);
 
-  pRadioButton(RadioButton &radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\sizable.hpp higan_v092r08\phoenix\reference\widget\sizable.hpp
--- higan_v092r07\phoenix\reference\widget\sizable.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\sizable.hpp	Thu May 02 05:48:05 2013
@@ -1,9 +1,9 @@
 namespace phoenix {
 
 struct pSizable : public pObject {
-  Sizable &sizable;
+  Sizable& sizable;
 
-  pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
 };
 
 }
diff -ru higan_v092r07\phoenix\reference\widget\text-edit.cpp higan_v092r08\phoenix\reference\widget\text-edit.cpp
--- higan_v092r07\phoenix\reference\widget\text-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\text-edit.cpp	Thu May 02 05:48:05 2013
@@ -6,7 +6,7 @@
 void pTextEdit::setEditable(bool editable) {
 }
 
-void pTextEdit::setText(const string &text) {
+void pTextEdit::setText(const string& text) {
 }
 
 void pTextEdit::setWordWrap(bool wordWrap) {
diff -ru higan_v092r07\phoenix\reference\widget\text-edit.hpp higan_v092r08\phoenix\reference\widget\text-edit.hpp
--- higan_v092r07\phoenix\reference\widget\text-edit.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\text-edit.hpp	Thu May 02 05:48:05 2013
@@ -1,15 +1,15 @@
 namespace phoenix {
 
 struct pTextEdit : public pWidget {
-  TextEdit &textEdit;
+  TextEdit& textEdit;
 
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   void setWordWrap(bool wordWrap);
   string text();
 
-  pTextEdit(TextEdit &textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\vertical-scroller.hpp higan_v092r08\phoenix\reference\widget\vertical-scroller.hpp
--- higan_v092r07\phoenix\reference\widget\vertical-scroller.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\vertical-scroller.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pVerticalScroller : public pWidget {
-  VerticalScroller &verticalScroller;
+  VerticalScroller& verticalScroller;
 
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalScroller(VerticalScroller &verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\vertical-slider.hpp higan_v092r08\phoenix\reference\widget\vertical-slider.hpp
--- higan_v092r07\phoenix\reference\widget\vertical-slider.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\vertical-slider.hpp	Thu May 02 05:48:05 2013
@@ -1,13 +1,13 @@
 namespace phoenix {
 
 struct pVerticalSlider : public pWidget {
-  VerticalSlider &verticalSlider;
+  VerticalSlider& verticalSlider;
 
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalSlider(VerticalSlider &verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\viewport.hpp higan_v092r08\phoenix\reference\widget\viewport.hpp
--- higan_v092r07\phoenix\reference\widget\viewport.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\viewport.hpp	Thu May 02 05:48:05 2013
@@ -1,11 +1,11 @@
 namespace phoenix {
 
 struct pViewport : public pWidget {
-  Viewport &viewport;
+  Viewport& viewport;
 
   uintptr_t handle();
 
-  pViewport(Viewport &viewport) : pWidget(viewport), viewport(viewport) {}
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\widget\widget.cpp higan_v092r08\phoenix\reference\widget\widget.cpp
--- higan_v092r07\phoenix\reference\widget\widget.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\widget.cpp	Thu May 02 05:48:05 2013
@@ -18,10 +18,10 @@
 void pWidget::setFocused() {
 }
 
-void pWidget::setFont(const string &font) {
+void pWidget::setFont(const string& font) {
 }
 
-void pWidget::setGeometry(const Geometry &geometry) {
+void pWidget::setGeometry(const Geometry& geometry) {
 }
 
 void pWidget::setVisible(bool visible) {
diff -ru higan_v092r07\phoenix\reference\widget\widget.hpp higan_v092r08\phoenix\reference\widget\widget.hpp
--- higan_v092r07\phoenix\reference\widget\widget.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\widget\widget.hpp	Thu May 02 05:48:05 2013
@@ -1,18 +1,18 @@
 namespace phoenix {
 
 struct pWidget : public pSizable {
-  Widget &widget;
+  Widget& widget;
 
   bool enabled();
   bool focused();
   Size minimumSize();
   void setEnabled(bool enabled);
   void setFocused();
-  void setFont(const string &font);
-  void setGeometry(const Geometry &geometry);
+  void setFont(const string& font);
+  void setGeometry(const Geometry& geometry);
   void setVisible(bool visible);
 
-  pWidget(Widget &widget) : pSizable(widget), widget(widget) {}
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\reference\window.cpp higan_v092r08\phoenix\reference\window.cpp
--- higan_v092r07\phoenix\reference\window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\window.cpp	Thu May 02 05:48:05 2013
@@ -6,13 +6,13 @@
   return *window;
 }
 
-void pWindow::append(Layout &layout) {
+void pWindow::append(Layout& layout) {
 }
 
-void pWindow::append(Menu &menu) {
+void pWindow::append(Menu& menu) {
 }
 
-void pWindow::append(Widget &widget) {
+void pWindow::append(Widget& widget) {
 }
 
 Color pWindow::backgroundColor() {
@@ -31,16 +31,16 @@
   return {0, 0, 0, 0};
 }
 
-void pWindow::remove(Layout &layout) {
+void pWindow::remove(Layout& layout) {
 }
 
-void pWindow::remove(Menu &menu) {
+void pWindow::remove(Menu& menu) {
 }
 
-void pWindow::remove(Widget &widget) {
+void pWindow::remove(Widget& widget) {
 }
 
-void pWindow::setBackgroundColor(const Color &color) {
+void pWindow::setBackgroundColor(const Color& color) {
 }
 
 void pWindow::setFocused() {
@@ -49,10 +49,10 @@
 void pWindow::setFullScreen(bool fullScreen) {
 }
 
-void pWindow::setGeometry(const Geometry &geometry) {
+void pWindow::setGeometry(const Geometry& geometry) {
 }
 
-void pWindow::setMenuFont(const string &font) {
+void pWindow::setMenuFont(const string& font) {
 }
 
 void pWindow::setMenuVisible(bool visible) {
@@ -64,22 +64,22 @@
 void pWindow::setResizable(bool resizable) {
 }
 
-void pWindow::setStatusFont(const string &font) {
+void pWindow::setStatusFont(const string& font) {
 }
 
-void pWindow::setStatusText(const string &text) {
+void pWindow::setStatusText(const string& text) {
 }
 
 void pWindow::setStatusVisible(bool visible) {
 }
 
-void pWindow::setTitle(const string &text) {
+void pWindow::setTitle(const string& text) {
 }
 
 void pWindow::setVisible(bool visible) {
 }
 
-void pWindow::setWidgetFont(const string &font) {
+void pWindow::setWidgetFont(const string& font) {
 }
 
 void pWindow::constructor() {
diff -ru higan_v092r07\phoenix\reference\window.hpp higan_v092r08\phoenix\reference\window.hpp
--- higan_v092r07\phoenix\reference\window.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\reference\window.hpp	Thu May 02 05:48:05 2013
@@ -1,36 +1,36 @@
 namespace phoenix {
 
 struct pWindow : public pObject {
-  Window &window;
+  Window& window;
 
   static Window& none();
 
-  void append(Layout &layout);
-  void append(Menu &menu);
-  void append(Widget &widget);
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
   Color backgroundColor();
   bool focused();
   Geometry frameMargin();
   Geometry geometry();
-  void remove(Layout &layout);
-  void remove(Menu &menu);
-  void remove(Widget &widget);
-  void setBackgroundColor(const Color &color);
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(const Color& color);
   void setFocused();
   void setFullScreen(bool fullScreen);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const string& font);
   void setMenuVisible(bool visible);
   void setModal(bool modal);
   void setResizable(bool resizable);
-  void setStatusFont(const string &font);
-  void setStatusText(const string &text);
+  void setStatusFont(const string& font);
+  void setStatusText(const string& text);
   void setStatusVisible(bool visible);
-  void setTitle(const string &text);
+  void setTitle(const string& text);
   void setVisible(bool visible);
-  void setWidgetFont(const string &font);
+  void setWidgetFont(const string& font);
 
-  pWindow(Window &window) : pObject(window), window(window) {}
+  pWindow(Window& window) : pObject(window), window(window) {}
   void constructor();
   void destructor();
 };
diff -ru higan_v092r07\phoenix\windows\action\check-item.cpp higan_v092r08\phoenix\windows\action\check-item.cpp
--- higan_v092r07\phoenix\windows\action\check-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\action\check-item.cpp	Thu May 02 05:48:05 2013
@@ -8,7 +8,7 @@
   if(parentMenu) CheckMenuItem(parentMenu->p.hmenu, id, checked ? MF_CHECKED : MF_UNCHECKED);
 }
 
-void pCheckItem::setText(const string &text) {
+void pCheckItem::setText(const string& text) {
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
diff -ru higan_v092r07\phoenix\windows\action\item.cpp higan_v092r08\phoenix\windows\action\item.cpp
--- higan_v092r07\phoenix\windows\action\item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\action\item.cpp	Thu May 02 05:48:05 2013
@@ -1,11 +1,11 @@
 namespace phoenix {
 
-void pItem::setImage(const image &image) {
+void pItem::setImage(const image& image) {
   createBitmap();
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
-void pItem::setText(const string &text) {
+void pItem::setText(const string& text) {
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
diff -ru higan_v092r07\phoenix\windows\action\menu.cpp higan_v092r08\phoenix\windows\action\menu.cpp
--- higan_v092r07\phoenix\windows\action\menu.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\action\menu.cpp	Thu May 02 05:48:05 2013
@@ -1,21 +1,21 @@
 namespace phoenix {
 
-void pMenu::append(Action &action) {
+void pMenu::append(Action& action) {
   action.p.parentMenu = &menu;
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
-void pMenu::remove(Action &action) {
+void pMenu::remove(Action& action) {
   if(parentWindow) parentWindow->p.updateMenu();
   action.p.parentMenu = 0;
 }
 
-void pMenu::setImage(const image &image) {
+void pMenu::setImage(const image& image) {
   createBitmap();
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
-void pMenu::setText(const string &text) {
+void pMenu::setText(const string& text) {
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
@@ -48,26 +48,26 @@
 
 //Windows actions lack the ability to toggle visibility.
 //To support this, menus must be destroyed and recreated when toggling any action's visibility.
-void pMenu::update(Window &parentWindow, Menu *parentMenu) {
+void pMenu::update(Window& parentWindow, Menu* parentMenu) {
   this->parentMenu = parentMenu;
   this->parentWindow = &parentWindow;
 
   if(hmenu) DestroyMenu(hmenu);
   hmenu = CreatePopupMenu();
 
-  for(auto &action : menu.state.action) {
+  for(auto& action : menu.state.action) {
     action.p.parentMenu = &menu;
     action.p.parentWindow = &parentWindow;
 
     unsigned enabled = action.state.enabled ? 0 : MF_GRAYED;
     if(dynamic_cast<Menu*>(&action)) {
-      Menu &item = (Menu&)action;
+      Menu& item = (Menu&)action;
       if(action.state.visible) {
         item.p.update(parentWindow, &menu);
         AppendMenu(hmenu, MF_STRING | MF_POPUP | enabled, (UINT_PTR)item.p.hmenu, utf16_t(item.state.text));
 
         if(item.state.image.width && item.state.image.height) {
-          MENUITEMINFO mii = { sizeof(MENUITEMINFO) };
+          MENUITEMINFO mii = {sizeof(MENUITEMINFO)};
           //Windows XP and below displays MIIM_BITMAP + hbmpItem in its own column (separate from check/radio marks)
           //this causes too much spacing, so use a custom checkmark image instead
           mii.fMask = MIIM_CHECKMARKS;
@@ -76,12 +76,12 @@
         }
       }
     } else if(dynamic_cast<Separator*>(&action)) {
-      Separator &item = (Separator&)action;
+      Separator& item = (Separator&)action;
       if(action.state.visible) {
         AppendMenu(hmenu, MF_SEPARATOR | enabled, item.p.id, L"");
       }
     } else if(dynamic_cast<Item*>(&action)) {
-      Item &item = (Item&)action;
+      Item& item = (Item&)action;
       if(action.state.visible) {
         AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
 
@@ -95,13 +95,13 @@
         }
       }
     } else if(dynamic_cast<CheckItem*>(&action)) {
-      CheckItem &item = (CheckItem&)action;
+      CheckItem& item = (CheckItem&)action;
       if(action.state.visible) {
         AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
       }
       if(item.state.checked) item.setChecked();
     } else if(dynamic_cast<RadioItem*>(&action)) {
-      RadioItem &item = (RadioItem&)action;
+      RadioItem& item = (RadioItem&)action;
       if(action.state.visible) {
         AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
       }
diff -ru higan_v092r07\phoenix\windows\action\radio-item.cpp higan_v092r08\phoenix\windows\action\radio-item.cpp
--- higan_v092r07\phoenix\windows\action\radio-item.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\action\radio-item.cpp	Thu May 02 05:48:05 2013
@@ -13,10 +13,10 @@
   }
 }
 
-void pRadioItem::setGroup(const group<RadioItem&> &group) {
+void pRadioItem::setGroup(const group<RadioItem>& group) {
 }
 
-void pRadioItem::setText(const string &text) {
+void pRadioItem::setText(const string& text) {
   if(parentWindow) parentWindow->p.updateMenu();
 }
 
diff -ru higan_v092r07\phoenix\windows\application.cpp higan_v092r08\phoenix\windows\application.cpp
--- higan_v092r07\phoenix\windows\application.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\application.cpp	Thu May 02 05:48:05 2013
@@ -33,7 +33,7 @@
   }
 }
 
-void Application_processDialogMessage(MSG &msg) {
+void Application_processDialogMessage(MSG& msg) {
   if(msg.message == WM_KEYDOWN || msg.message == WM_KEYUP
   || msg.message == WM_SYSKEYDOWN || msg.message == WM_SYSKEYUP) {
     if(Application_keyboardProc(msg.hwnd, msg.message, msg.wParam, msg.lParam)) {
@@ -116,11 +116,11 @@
   memset(&info, 0, sizeof(GUITHREADINFO));
   info.cbSize = sizeof(GUITHREADINFO);
   GetGUIThreadInfo(GetCurrentThreadId(), &info);
-  Object *object = (Object*)GetWindowLongPtr(info.hwndFocus, GWLP_USERDATA);
+  Object* object = (Object*)GetWindowLongPtr(info.hwndFocus, GWLP_USERDATA);
   if(object == nullptr) return false;
 
   if(dynamic_cast<Window*>(object)) {
-    Window &window = (Window&)*object;
+    Window& window = (Window&)*object;
     if(pWindow::modal.size() > 0 && !pWindow::modal.find(&window.p)) return false;
     Keyboard::Keycode keysym = Keysym(wparam, lparam);
     if(keysym != Keyboard::Keycode::None) {
@@ -132,17 +132,17 @@
 
   if(msg == WM_KEYDOWN) {
     if(dynamic_cast<ListView*>(object)) {
-      ListView &listView = (ListView&)*object;
+      ListView& listView = (ListView&)*object;
       if(wparam == VK_RETURN) {
         if(listView.onActivate) listView.onActivate();
       }
     } else if(dynamic_cast<LineEdit*>(object)) {
-      LineEdit &lineEdit = (LineEdit&)*object;
+      LineEdit& lineEdit = (LineEdit&)*object;
       if(wparam == VK_RETURN) {
         if(lineEdit.onActivate) lineEdit.onActivate();
       }
     } else if(dynamic_cast<TextEdit*>(object)) {
-      TextEdit &textEdit = (TextEdit&)*object;
+      TextEdit& textEdit = (TextEdit&)*object;
       if(wparam == 'A' && GetKeyState(VK_CONTROL) < 0) {
         //Ctrl+A = select all text
         //note: this is not a standard accelerator on Windows
@@ -155,7 +155,7 @@
         OpenClipboard(hwnd);
         HANDLE handle = GetClipboardData(CF_UNICODETEXT);
         if(handle) {
-          wchar_t *text = (wchar_t*)GlobalLock(handle);
+          wchar_t* text = (wchar_t*)GlobalLock(handle);
           if(text) {
             string data = (const char*)utf8_t(text);
             data.replace("\r\n", "\n");
@@ -165,7 +165,7 @@
             utf16_t output(data);
             HGLOBAL resource = GlobalAlloc(GMEM_MOVEABLE, (wcslen(output) + 1) * sizeof(wchar_t));
             if(resource) {
-              wchar_t *write = (wchar_t*)GlobalLock(resource);
+              wchar_t* write = (wchar_t*)GlobalLock(resource);
               if(write) {
                 wcscpy(write, output);
                 GlobalUnlock(write);
@@ -186,9 +186,9 @@
 }
 
 static LRESULT CALLBACK Application_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
-  Object *object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
   if(!object || !dynamic_cast<Window*>(object)) return DefWindowProc(hwnd, msg, wparam, lparam);
-  Window &window = (Window&)*object;
+  Window& window = (Window&)*object;
 
   bool process = true;
   if(pWindow::modal.size() > 0 && !pWindow::modal.find(&window.p)) process = false;
@@ -221,7 +221,7 @@
       window.state.geometry.width = geometry.width;
       window.state.geometry.height = geometry.height;
 
-      for(auto &layout : window.state.layout) {
+      for(auto& layout : window.state.layout) {
         Geometry geom = window.geometry();
         geom.x = geom.y = 0;
         layout.setGeometry(geom);
@@ -232,7 +232,7 @@
     }
 
     case WM_GETMINMAXINFO: {
-      MINMAXINFO *mmi = (MINMAXINFO*)lparam;
+      MINMAXINFO* mmi = (MINMAXINFO*)lparam;
     //mmi->ptMinTrackSize.x = 256 + window.p.frameMargin().width;
     //mmi->ptMinTrackSize.y = 256 + window.p.frameMargin().height;
     //return TRUE;
@@ -252,7 +252,7 @@
 
     case WM_CTLCOLORBTN:
     case WM_CTLCOLORSTATIC: {
-      Object *object = (Object*)GetWindowLongPtr((HWND)lparam, GWLP_USERDATA);
+      Object* object = (Object*)GetWindowLongPtr((HWND)lparam, GWLP_USERDATA);
       if(object && window.p.brush) {
         HDC hdc = (HDC)wparam;
         SetBkColor((HDC)wparam, window.p.brushColor);
@@ -265,34 +265,34 @@
       unsigned id = LOWORD(wparam);
       HWND control = GetDlgItem(window.p.hwnd, id);
       if(control == 0) {
-        pObject *object = (pObject*)pObject::find(id);
+        pObject* object = (pObject*)pObject::find(id);
         if(!object) break;
         if(dynamic_cast<pItem*>(object)) {
-          Item &item = ((pItem*)object)->item;
+          Item& item = ((pItem*)object)->item;
           if(item.onActivate) item.onActivate();
         } else if(dynamic_cast<pCheckItem*>(object)) {
-          CheckItem &checkItem = ((pCheckItem*)object)->checkItem;
+          CheckItem& checkItem = ((pCheckItem*)object)->checkItem;
           checkItem.setChecked(!checkItem.state.checked);
           if(checkItem.onToggle) checkItem.onToggle();
         } else if(dynamic_cast<pRadioItem*>(object)) {
-          RadioItem &radioItem = ((pRadioItem*)object)->radioItem;
+          RadioItem& radioItem = ((pRadioItem*)object)->radioItem;
           if(radioItem.state.checked == false) {
             radioItem.setChecked();
             if(radioItem.onActivate) radioItem.onActivate();
           }
         }
       } else {
-        Object *object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
+        Object* object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
         if(!object) break;
         if(dynamic_cast<Button*>(object)) {
-          Button &button = (Button&)*object;
+          Button& button = (Button&)*object;
           if(button.onActivate) button.onActivate();
         } else if(dynamic_cast<CheckButton*>(object)) {
-          CheckButton &checkButton = (CheckButton&)*object;
+          CheckButton& checkButton = (CheckButton&)*object;
           checkButton.setChecked(!checkButton.state.checked);
           if(checkButton.onToggle) checkButton.onToggle();
         } else if(dynamic_cast<ComboButton*>(object)) {
-          ComboButton &comboButton = (ComboButton&)*object;
+          ComboButton& comboButton = (ComboButton&)*object;
           if(HIWORD(wparam) == CBN_SELCHANGE) {
             if(comboButton.state.selection != comboButton.selection()) {
               comboButton.state.selection = comboButton.selection();
@@ -300,18 +300,18 @@
             }
           }
         } else if(dynamic_cast<LineEdit*>(object)) {
-          LineEdit &lineEdit = (LineEdit&)*object;
+          LineEdit& lineEdit = (LineEdit&)*object;
           if(HIWORD(wparam) == EN_CHANGE) {
             if(lineEdit.p.locked == false && lineEdit.onChange) lineEdit.onChange();
           }
         } else if(dynamic_cast<RadioButton*>(object)) {
-          RadioButton &radioButton = (RadioButton&)*object;
+          RadioButton& radioButton = (RadioButton&)*object;
           if(radioButton.state.checked == false) {
             radioButton.setChecked();
             if(radioButton.onActivate) radioButton.onActivate();
           }
         } else if(dynamic_cast<TextEdit*>(object)) {
-          TextEdit &textEdit = (TextEdit&)*object;
+          TextEdit& textEdit = (TextEdit&)*object;
           if(HIWORD(wparam) == EN_CHANGE) {
             if(textEdit.p.locked == false && textEdit.onChange) textEdit.onChange();
           }
@@ -324,10 +324,10 @@
       unsigned id = LOWORD(wparam);
       HWND control = GetDlgItem(window.p.hwnd, id);
       if(control == 0) break;
-      Object *object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
-      if(object == 0) break;
+      Object* object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
+      if(object == nullptr) break;
       if(dynamic_cast<ListView*>(object)) {
-        ListView &listView = (ListView&)*object;
+        ListView& listView = (ListView&)*object;
         LPNMHDR nmhdr = (LPNMHDR)lparam;
         LPNMLISTVIEW nmlistview = (LPNMLISTVIEW)lparam;
 
@@ -371,7 +371,7 @@
 
     case WM_HSCROLL:
     case WM_VSCROLL: {
-      Object *object = 0;
+      Object* object = nullptr;
       if(lparam) {
         object = (Object*)GetWindowLongPtr((HWND)lparam, GWLP_USERDATA);
       } else {
@@ -380,7 +380,7 @@
         if(control == 0) break;
         object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
       }
-      if(object == 0) break;
+      if(object == nullptr) break;
 
       if(dynamic_cast<HorizontalScroller*>(object)
       || dynamic_cast<VerticalScroller*>(object)) {
@@ -407,13 +407,13 @@
         GetScrollInfo((HWND)lparam, SB_CTL, &info);
 
         if(dynamic_cast<HorizontalScroller*>(object)) {
-          HorizontalScroller &horizontalScroller = (HorizontalScroller&)*object;
+          HorizontalScroller& horizontalScroller = (HorizontalScroller&)*object;
           if(horizontalScroller.state.position != info.nPos) {
             horizontalScroller.state.position = info.nPos;
             if(horizontalScroller.onChange) horizontalScroller.onChange();
           }
         } else {
-          VerticalScroller &verticalScroller = (VerticalScroller&)*object;
+          VerticalScroller& verticalScroller = (VerticalScroller&)*object;
           if(verticalScroller.state.position != info.nPos) {
             verticalScroller.state.position = info.nPos;
             if(verticalScroller.onChange) verticalScroller.onChange();
@@ -424,13 +424,13 @@
       }
 
       if(dynamic_cast<HorizontalSlider*>(object)) {
-        HorizontalSlider &horizontalSlider = (HorizontalSlider&)*object;
+        HorizontalSlider& horizontalSlider = (HorizontalSlider&)*object;
         if(horizontalSlider.state.position != horizontalSlider.position()) {
           horizontalSlider.state.position = horizontalSlider.position();
           if(horizontalSlider.onChange) horizontalSlider.onChange();
         }
       } else if(dynamic_cast<VerticalSlider*>(object)) {
-        VerticalSlider &verticalSlider = (VerticalSlider&)*object;
+        VerticalSlider& verticalSlider = (VerticalSlider&)*object;
         if(verticalSlider.state.position != verticalSlider.position()) {
           verticalSlider.state.position = verticalSlider.position();
           if(verticalSlider.onChange) verticalSlider.onChange();
diff -ru higan_v092r07\phoenix\windows\browser-window.cpp higan_v092r08\phoenix\windows\browser-window.cpp
--- higan_v092r07\phoenix\windows\browser-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\browser-window.cpp	Thu May 02 05:48:05 2013
@@ -12,11 +12,11 @@
   return 0;
 }
 
-static string BrowserWindow_fileDialog(bool save, BrowserWindow::State &state) {
+static string BrowserWindow_fileDialog(bool save, BrowserWindow::State& state) {
   string path = string{path}.replace("/", "\\");
 
   string filters;
-  for(auto &filter : state.filters) {
+  for(auto& filter : state.filters) {
     lstring part = filter.split("(");
     if(part.size() != 2) continue;
     part[1].rtrim<1>(")");
@@ -30,7 +30,7 @@
   utf16_t wpath(path);
   utf16_t wtitle(state.title);
 
-  wchar_t *p = wfilters;
+  wchar_t* p = wfilters;
   while(*p != L'\0') {
     if(*p == L'\t') *p = L'\0';
     p++;
@@ -62,7 +62,7 @@
   return name;
 }
 
-string pBrowserWindow::directory(BrowserWindow::State &state) {
+string pBrowserWindow::directory(BrowserWindow::State& state) {
   wchar_t wname[PATH_MAX + 1] = L"";
 
   BROWSEINFO bi;
@@ -94,11 +94,11 @@
   return name;
 }
 
-string pBrowserWindow::open(BrowserWindow::State &state) {
+string pBrowserWindow::open(BrowserWindow::State& state) {
   return BrowserWindow_fileDialog(0, state);
 }
 
-string pBrowserWindow::save(BrowserWindow::State &state) {
+string pBrowserWindow::save(BrowserWindow::State& state) {
   return BrowserWindow_fileDialog(1, state);
 }
 
diff -ru higan_v092r07\phoenix\windows\font.cpp higan_v092r08\phoenix\windows\font.cpp
--- higan_v092r07\phoenix\windows\font.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\font.cpp	Thu May 02 05:48:05 2013
@@ -18,17 +18,17 @@
   return {"Lucida Console, ", size, ", ", style};
 }
 
-Size pFont::size(const string &font, const string &text) {
+Size pFont::size(const string& font, const string& text) {
   HFONT hfont = pFont::create(font);
   Size size = pFont::size(hfont, text);
   pFont::free(hfont);
   return size;
 }
 
-HFONT pFont::create(const string &description) {
+HFONT pFont::create(const string& description) {
   lstring part;
   part.split(",", description);
-  for(auto &item : part) item.trim(" ");
+  for(auto& item : part) item.trim(" ");
 
   string family = "Sans";
   unsigned size = 8u;
@@ -51,7 +51,7 @@
   DeleteObject(hfont);
 }
 
-Size pFont::size(HFONT hfont, const string &text_) {
+Size pFont::size(HFONT hfont, const string& text_) {
   //temporary fix: empty text string returns height of zero; bad for eg Button height
   string text = (text_ == "" ? " " : text_);
 
diff -ru higan_v092r07\phoenix\windows\keyboard.cpp higan_v092r08\phoenix\windows\keyboard.cpp
--- higan_v092r07\phoenix\windows\keyboard.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\keyboard.cpp	Thu May 02 05:48:05 2013
@@ -121,17 +121,20 @@
 }
 
 bool pKeyboard::pressed(Keyboard::Scancode scancode) {
-  return GetAsyncKeyState(settings->keymap.lhs[scancode]) & 0x8000;
+  if(auto result = settings->keymap.find(scancode)) {
+    return GetAsyncKeyState(result()) & 0x8000;
+  }
+  return false;
 }
 
 vector<bool> pKeyboard::state() {
   vector<bool> output;
   output.resize((unsigned)Keyboard::Scancode::Limit);
-  for(auto &n : output) n = false;
+  for(auto& n : output) n = false;
 
-  for(auto &n : settings->keymap.rhs) {
-    if(GetAsyncKeyState(n.name) & 0x8000) {
-      output[(unsigned)n.data] = true;
+  for(auto node : settings->keymap) {
+    if(GetAsyncKeyState(node.value) & 0x8000) {
+      output[(unsigned)node.key] = true;
     }
   }
 
diff -ru higan_v092r07\phoenix\windows\message-window.cpp higan_v092r08\phoenix\windows\message-window.cpp
--- higan_v092r07\phoenix\windows\message-window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\message-window.cpp	Thu May 02 05:48:05 2013
@@ -23,28 +23,28 @@
   throw;
 }
 
-MessageWindow::Response pMessageWindow::error(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
   UINT flags = MB_ICONERROR | MessageWindow_buttons(state.buttons);
   return MessageWindow_response(state.buttons, MessageBox(
     state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
   ));
 }
 
-MessageWindow::Response pMessageWindow::information(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
   UINT flags = MB_ICONINFORMATION | MessageWindow_buttons(state.buttons);
   return MessageWindow_response(state.buttons, MessageBox(
     state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
   ));
 }
 
-MessageWindow::Response pMessageWindow::question(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
   UINT flags = MB_ICONQUESTION | MessageWindow_buttons(state.buttons);
   return MessageWindow_response(state.buttons, MessageBox(
     state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
   ));
 }
 
-MessageWindow::Response pMessageWindow::warning(MessageWindow::State &state) {
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
   UINT flags = MB_ICONWARNING | MessageWindow_buttons(state.buttons);
   return MessageWindow_response(state.buttons, MessageBox(
     state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
diff -ru higan_v092r07\phoenix\windows\object.cpp higan_v092r08\phoenix\windows\object.cpp
--- higan_v092r07\phoenix\windows\object.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\object.cpp	Thu May 02 05:48:05 2013
@@ -2,7 +2,7 @@
 
 vector<pObject*> pObject::objects;
 
-pObject::pObject(Object &object) : object(object) {
+pObject::pObject(Object& object) : object(object) {
   static unsigned uniqueId = 100;
   objects.append(this);
   id = uniqueId++;
@@ -10,7 +10,7 @@
 }
 
 pObject* pObject::find(unsigned id) {
-  for(auto &item : objects) if(item->id == id) return item;
+  for(auto& item : objects) if(item->id == id) return item;
   return 0;
 }
 
diff -ru higan_v092r07\phoenix\windows\platform.hpp higan_v092r08\phoenix\windows\platform.hpp
--- higan_v092r07\phoenix\windows\platform.hpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\platform.hpp	Thu May 02 05:48:05 2013
@@ -10,7 +10,7 @@
 };
 
 struct Settings {
-  bidirectional_map<Keyboard::Scancode, unsigned> keymap;
+  bimap<Keyboard::Scancode, unsigned> keymap;
 };
 
 struct pFont;
@@ -24,11 +24,11 @@
   static string serif(unsigned size, string style);
   static string sans(unsigned size, string style);
   static string monospace(unsigned size, string style);
-  static Size size(const string &font, const string &text);
+  static Size size(const string& font, const string& text);
 
-  static HFONT create(const string &description);
+  static HFONT create(const string& description);
   static void free(HFONT hfont);
-  static Size size(HFONT hfont, const string &text);
+  static Size size(HFONT hfont, const string& text);
 };
 
 struct pDesktop {
@@ -49,26 +49,26 @@
 };
 
 struct pBrowserWindow {
-  static string directory(BrowserWindow::State &state);
-  static string open(BrowserWindow::State &state);
-  static string save(BrowserWindow::State &state);
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
 };
 
 struct pMessageWindow {
-  static MessageWindow::Response error(MessageWindow::State &state);
-  static MessageWindow::Response information(MessageWindow::State &state);
-  static MessageWindow::Response question(MessageWindow::State &state);
-  static MessageWindow::Response warning(MessageWindow::State &state);
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
 };
 
 struct pObject {
   static vector<pObject*> objects;
 
-  Object &object;
+  Object& object;
   uintptr_t id;
   bool locked;
 
-  pObject(Object &object);
+  pObject(Object& object);
   static pObject* find(unsigned id);
   virtual ~pObject() {}
 
@@ -77,13 +77,13 @@
 };
 
 struct pTimer : public pObject {
-  Timer &timer;
+  Timer& timer;
   UINT_PTR htimer;
 
   void setEnabled(bool enabled);
   void setInterval(unsigned milliseconds);
 
-  pTimer(Timer &timer) : pObject(timer), timer(timer) {}
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
   void constructor();
 };
 
@@ -91,7 +91,7 @@
   static vector<pWindow*> modal;
   static void updateModality();
 
-  Window &window;
+  Window& window;
   HWND hwnd;
   HMENU hmenu;
   HWND hstatus;
@@ -101,127 +101,127 @@
 
   static Window& none();
 
-  void append(Layout &layout);
-  void append(Menu &menu);
-  void append(Widget &widget);
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
   Color backgroundColor();
   bool focused();
   Geometry frameMargin();
   Geometry geometry();
-  void remove(Layout &layout);
-  void remove(Menu &menu);
-  void remove(Widget &widget);
-  void setBackgroundColor(const Color &color);
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(const Color& color);
   void setFocused();
   void setFullScreen(bool fullScreen);
-  void setGeometry(const Geometry &geometry);
-  void setMenuFont(const string &font);
+  void setGeometry(const Geometry& geometry);
+  void setMenuFont(const string& font);
   void setMenuVisible(bool visible);
   void setModal(bool modal);
   void setResizable(bool resizable);
-  void setStatusFont(const string &font);
-  void setStatusText(const string &text);
+  void setStatusFont(const string& font);
+  void setStatusText(const string& text);
   void setStatusVisible(bool visible);
-  void setTitle(const string &text);
+  void setTitle(const string& text);
   void setVisible(bool visible);
-  void setWidgetFont(const string &font);
+  void setWidgetFont(const string& font);
 
-  pWindow(Window &window) : pObject(window), window(window) {}
+  pWindow(Window& window) : pObject(window), window(window) {}
   void constructor();
   void destructor();
   void updateMenu();
 };
 
 struct pAction : public pObject {
-  Action &action;
-  Menu *parentMenu;
-  Window *parentWindow;
+  Action& action;
+  Menu* parentMenu;
+  Window* parentWindow;
 
   void setEnabled(bool enabled);
   void setVisible(bool visible);
 
-  pAction(Action &action) : pObject(action), action(action) {}
+  pAction(Action& action) : pObject(action), action(action) {}
   void constructor();
 };
 
 struct pMenu : public pAction {
-  Menu &menu;
+  Menu& menu;
   HMENU hmenu;
   HBITMAP hbitmap;
 
-  void append(Action &action);
-  void remove(Action &action);
-  void setImage(const image &image);
-  void setText(const string &text);
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pMenu(Menu &menu) : pAction(menu), menu(menu), hbitmap(0) {}
+  pMenu(Menu& menu) : pAction(menu), menu(menu), hbitmap(0) {}
   void constructor();
   void destructor();
   void createBitmap();
-  void update(Window &parentWindow, Menu *parentMenu = 0);
+  void update(Window& parentWindow, Menu* parentMenu = nullptr);
 };
 
 struct pSeparator : public pAction {
-  Separator &separator;
+  Separator& separator;
 
-  pSeparator(Separator &separator) : pAction(separator), separator(separator) {}
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
   void constructor();
   void destructor();
 };
 
 struct pItem : public pAction {
-  Item &item;
+  Item& item;
   HBITMAP hbitmap;
 
-  void setImage(const image &image);
-  void setText(const string &text);
+  void setImage(const image& image);
+  void setText(const string& text);
 
-  pItem(Item &item) : pAction(item), item(item), hbitmap(0) {}
+  pItem(Item& item) : pAction(item), item(item), hbitmap(0) {}
   void constructor();
   void destructor();
   void createBitmap();
 };
 
 struct pCheckItem : public pAction {
-  CheckItem &checkItem;
+  CheckItem& checkItem;
 
   bool checked();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckItem(CheckItem &checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
   void constructor();
   void destructor();
 };
 
 struct pRadioItem : public pAction {
-  RadioItem &radioItem;
+  RadioItem& radioItem;
 
   bool checked();
   void setChecked();
-  void setGroup(const group<RadioItem&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioItem>& group);
+  void setText(const string& text);
 
-  pRadioItem(RadioItem &radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
   void constructor();
   void destructor();
 };
 
 struct pSizable : public pObject {
-  Sizable &sizable;
+  Sizable& sizable;
 
-  pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
 };
 
 struct pLayout : public pSizable {
-  Layout &layout;
+  Layout& layout;
 
-  pLayout(Layout &layout) : pSizable(layout), layout(layout) {}
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
 };
 
 struct pWidget : public pSizable {
-  Widget &widget;
-  Window *parentWindow;
+  Widget& widget;
+  Window* parentWindow;
   HWND hwnd;
   HFONT hfont;
 
@@ -231,10 +231,10 @@
   void setEnabled(bool enabled);
   void setFocused();
   void setFont(const string &font);
-  virtual void setGeometry(const Geometry &geometry);
+  virtual void setGeometry(const Geometry& geometry);
   void setVisible(bool visible);
 
-  pWidget(Widget &widget) : pSizable(widget), widget(widget) { parentWindow = &Window::none(); }
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) { parentWindow = &Window::none(); }
   void constructor();
   void destructor();
   virtual void orphan();
@@ -243,28 +243,28 @@
 };
 
 struct pButton : public pWidget {
-  Button &button;
+  Button& button;
   HBITMAP hbitmap;
   HIMAGELIST himagelist;
 
   Size minimumSize();
-  void setImage(const image &image, Orientation orientation);
-  void setText(const string &text);
+  void setImage(const image& image, Orientation orientation);
+  void setText(const string& text);
 
-  pButton(Button &button) : pWidget(button), button(button), hbitmap(0), himagelist(0) {}
+  pButton(Button& button) : pWidget(button), button(button), hbitmap(0), himagelist(0) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pCanvas : public pWidget {
-  Canvas &canvas;
-  uint32_t *data;
+  Canvas& canvas;
+  uint32_t* data;
 
-  void setSize(const Size &size);
+  void setSize(const Size& size);
   void update();
 
-  pCanvas(Canvas &canvas) : pWidget(canvas), canvas(canvas) {}
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
   void constructor();
   void destructor();
   void orphan();
@@ -272,39 +272,39 @@
 };
 
 struct pCheckButton : public pWidget {
-  CheckButton &checkButton;
+  CheckButton& checkButton;
 
   bool checked();
   Size minimumSize();
   void setChecked(bool checked);
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pCheckButton(CheckButton &checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pComboButton : public pWidget {
-  ComboButton &comboButton;
+  ComboButton& comboButton;
 
-  void append(const string &text);
-  void modify(unsigned row, const string &text);
+  void append(const string& text);
+  void modify(unsigned row, const string& text);
   void remove(unsigned row);
   Size minimumSize();
   void reset();
   unsigned selection();
   void setSelection(unsigned row);
 
-  pComboButton(ComboButton &comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
   void constructor();
   void destructor();
   void orphan();
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
 };
 
 struct pHexEdit : public pWidget {
-  HexEdit &hexEdit;
+  HexEdit& hexEdit;
   LRESULT CALLBACK (*windowProc)(HWND, UINT, LPARAM, WPARAM);
 
   void setColumns(unsigned columns);
@@ -313,7 +313,7 @@
   void setRows(unsigned rows);
   void update();
 
-  pHexEdit(HexEdit &hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
   void constructor();
   void destructor();
   void orphan();
@@ -321,166 +321,166 @@
 };
 
 struct pHorizontalScroller : public pWidget {
-  HorizontalScroller &horizontalScroller;
+  HorizontalScroller& horizontalScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalScroller(HorizontalScroller &horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pHorizontalSlider : public pWidget {
-  HorizontalSlider &horizontalSlider;
+  HorizontalSlider& horizontalSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pHorizontalSlider(HorizontalSlider &horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pLabel : public pWidget {
-  Label &label;
+  Label& label;
 
   Size minimumSize();
-  void setText(const string &text);
+  void setText(const string& text);
 
-  pLabel(Label &label) : pWidget(label), label(label) {}
+  pLabel(Label& label) : pWidget(label), label(label) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pLineEdit : public pWidget {
-  LineEdit &lineEdit;
+  LineEdit& lineEdit;
 
   Size minimumSize();
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   string text();
 
-  pLineEdit(LineEdit &lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pListView : public pWidget {
-  ListView &listView;
+  ListView& listView;
   HIMAGELIST imageList;
   vector<vector<unsigned>> imageMap;
   vector<image> images;
   bool lostFocus;
 
-  void append(const lstring &text);
+  void append(const lstring& text);
   void autoSizeColumns();
   bool checked(unsigned row);
-  void modify(unsigned row, const lstring &text);
+  void modify(unsigned row, const lstring& text);
   void remove(unsigned row);
   void reset();
   bool selected();
   unsigned selection();
   void setCheckable(bool checkable);
   void setChecked(unsigned row, bool checked);
-  void setHeaderText(const lstring &text);
+  void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
-  void setImage(unsigned row, unsigned column, const image &image);
+  void setImage(unsigned row, unsigned column, const image& image);
   void setSelected(bool selected);
   void setSelection(unsigned row);
 
-  pListView(ListView &listView) : pWidget(listView), listView(listView), imageList(nullptr) {}
+  pListView(ListView& listView) : pWidget(listView), listView(listView), imageList(nullptr) {}
   void constructor();
   void destructor();
   void orphan();
-  void setGeometry(const Geometry &geometry);
+  void setGeometry(const Geometry& geometry);
   void buildImageList();
 };
 
 struct pProgressBar : public pWidget {
-  ProgressBar &progressBar;
+  ProgressBar& progressBar;
 
   Size minimumSize();
   void setPosition(unsigned position);
 
-  pProgressBar(ProgressBar &progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pRadioButton : public pWidget {
-  RadioButton &radioButton;
+  RadioButton& radioButton;
 
   bool checked();
   Size minimumSize();
   void setChecked();
-  void setGroup(const group<RadioButton&> &group);
-  void setText(const string &text);
+  void setGroup(const group<RadioButton>& group);
+  void setText(const string& text);
 
-  pRadioButton(RadioButton &radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pTextEdit : public pWidget {
-  TextEdit &textEdit;
+  TextEdit& textEdit;
 
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setText(const string &text);
+  void setText(const string& text);
   void setWordWrap(bool wordWrap);
   string text();
 
-  pTextEdit(TextEdit &textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pVerticalScroller : public pWidget {
-  VerticalScroller &verticalScroller;
+  VerticalScroller& verticalScroller;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalScroller(VerticalScroller &verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pVerticalSlider : public pWidget {
-  VerticalSlider &verticalSlider;
+  VerticalSlider& verticalSlider;
 
   Size minimumSize();
   unsigned position();
   void setLength(unsigned length);
   void setPosition(unsigned position);
 
-  pVerticalSlider(VerticalSlider &verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
   void constructor();
   void destructor();
   void orphan();
 };
 
 struct pViewport : public pWidget {
-  Viewport &viewport;
+  Viewport& viewport;
 
   uintptr_t handle();
 
-  pViewport(Viewport &viewport) : pWidget(viewport), viewport(viewport) {}
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
   void constructor();
   void destructor();
   void orphan();
diff -ru higan_v092r07\phoenix\windows\settings.cpp higan_v092r08\phoenix\windows\settings.cpp
--- higan_v092r07\phoenix\windows\settings.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\settings.cpp	Thu May 02 05:48:05 2013
@@ -1,5 +1,5 @@
 namespace phoenix {
 
-static Settings *settings = nullptr;
+static Settings* settings = nullptr;
 
 }
diff -ru higan_v092r07\phoenix\windows\timer.cpp higan_v092r08\phoenix\windows\timer.cpp
--- higan_v092r07\phoenix\windows\timer.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\timer.cpp	Thu May 02 05:48:05 2013
@@ -3,7 +3,7 @@
 static vector<pTimer*> timers;
 
 static void CALLBACK Timer_timeoutProc(HWND hwnd, UINT msg, UINT_PTR timerID, DWORD time) {
-  for(auto &timer : timers) {
+  for(auto& timer : timers) {
     if(timer->htimer == timerID) {
       if(timer->timer.onActivate) timer->timer.onActivate();
       return;
diff -ru higan_v092r07\phoenix\windows\utility.cpp higan_v092r08\phoenix\windows\utility.cpp
--- higan_v092r07\phoenix\windows\utility.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\utility.cpp	Thu May 02 05:48:05 2013
@@ -6,13 +6,13 @@
 static const unsigned Windows7     = 0x0601;
 
 static unsigned OsVersion() {
-  OSVERSIONINFO versionInfo = { 0 };
+  OSVERSIONINFO versionInfo = {0};
   versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
   GetVersionEx(&versionInfo);
   return (versionInfo.dwMajorVersion << 8) + (versionInfo.dwMajorVersion << 0);
 }
 
-static HBITMAP CreateBitmap(const image &image) {
+static HBITMAP CreateBitmap(const image& image) {
   HDC hdc = GetDC(0);
   BITMAPINFO bitmapInfo;
   memset(&bitmapInfo, 0, sizeof(BITMAPINFO));
@@ -23,7 +23,7 @@
   bitmapInfo.bmiHeader.biBitCount = 32;
   bitmapInfo.bmiHeader.biCompression = BI_RGB;
   bitmapInfo.bmiHeader.biSizeImage = image.width * image.height * 4;
-  void *bits = nullptr;
+  void* bits = nullptr;
   HBITMAP hbitmap = CreateDIBSection(hdc, &bitmapInfo, DIB_RGB_COLORS, &bits, NULL, 0);
   if(bits) memcpy(bits, image.data, image.width * image.height * 4);
   ReleaseDC(0, hdc);
diff -ru higan_v092r07\phoenix\windows\widget\button.cpp higan_v092r08\phoenix\windows\widget\button.cpp
--- higan_v092r07\phoenix\windows\widget\button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\button.cpp	Thu May 02 05:48:05 2013
@@ -35,7 +35,7 @@
   return {size.width + 20, size.height + 10};
 }
 
-void pButton::setImage(const image &image, Orientation orientation) {
+void pButton::setImage(const image& image, Orientation orientation) {
   nall::image nallImage = image;
   nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
 
@@ -69,7 +69,7 @@
   setText(button.state.text);  //update text to display nicely with image (or lack thereof)
 }
 
-void pButton::setText(const string &text) {
+void pButton::setText(const string& text) {
   if(text.empty()) {
     //bitmaps will not show up if text is empty
     SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
diff -ru higan_v092r07\phoenix\windows\widget\canvas.cpp higan_v092r08\phoenix\windows\widget\canvas.cpp
--- higan_v092r07\phoenix\windows\widget\canvas.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\canvas.cpp	Thu May 02 05:48:05 2013
@@ -1,10 +1,10 @@
 namespace phoenix {
 
 static LRESULT CALLBACK Canvas_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
-  Object *object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
   if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
   if(!dynamic_cast<Canvas*>(object)) return DefWindowProc(hwnd, msg, wparam, lparam);
-  Canvas &canvas = (Canvas&)*object;
+  Canvas& canvas = (Canvas&)*object;
 
   if(msg == WM_GETDLGCODE) {
     return DLGC_STATIC | DLGC_WANTCHARS;
@@ -16,9 +16,9 @@
   }
 
   if(msg == WM_MOUSEMOVE) {
-    TRACKMOUSEEVENT tracker = { sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd };
+    TRACKMOUSEEVENT tracker = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd};
     TrackMouseEvent(&tracker);
-    if(canvas.onMouseMove) canvas.onMouseMove({ (int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam) });
+    if(canvas.onMouseMove) canvas.onMouseMove({(int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam)});
   }
 
   if(msg == WM_MOUSELEAVE) {
@@ -44,7 +44,7 @@
   return DefWindowProc(hwnd, msg, wparam, lparam);
 }
 
-void pCanvas::setSize(const Size &size) {
+void pCanvas::setSize(const Size& size) {
   delete[] data;
   data = new uint32_t[size.width * size.height];
 }
diff -ru higan_v092r07\phoenix\windows\widget\check-button.cpp higan_v092r08\phoenix\windows\widget\check-button.cpp
--- higan_v092r07\phoenix\windows\widget\check-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\check-button.cpp	Thu May 02 05:48:05 2013
@@ -13,7 +13,7 @@
   SendMessage(hwnd, BM_SETCHECK, (WPARAM)checked, 0);
 }
 
-void pCheckButton::setText(const string &text) {
+void pCheckButton::setText(const string& text) {
   SetWindowText(hwnd, utf16_t(text));
 }
 
diff -ru higan_v092r07\phoenix\windows\widget\combo-button.cpp higan_v092r08\phoenix\windows\widget\combo-button.cpp
--- higan_v092r07\phoenix\windows\widget\combo-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\combo-button.cpp	Thu May 02 05:48:05 2013
@@ -1,17 +1,17 @@
 namespace phoenix {
 
-void pComboButton::append(const string &text) {
+void pComboButton::append(const string& text) {
   SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(wchar_t*)utf16_t(text));
   if(SendMessage(hwnd, CB_GETCOUNT, 0, 0) == 1) setSelection(0);
 }
 
 Size pComboButton::minimumSize() {
   unsigned maximumWidth = 0;
-  for(auto &text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(hfont, text).width);
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(hfont, text).width);
   return {maximumWidth + 24, pFont::size(hfont, " ").height + 10};
 }
 
-void pComboButton::modify(unsigned row, const string &text) {
+void pComboButton::modify(unsigned row, const string& text) {
   locked = true;
   unsigned position = selection();
   SendMessage(hwnd, CB_DELETESTRING, row, 0);
@@ -49,7 +49,7 @@
   );
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&comboButton);
   setDefaultFont();
-  for(auto &text : comboButton.state.text) append(text);
+  for(auto& text : comboButton.state.text) append(text);
   setSelection(comboButton.state.selection);
   synchronize();
 }
@@ -63,7 +63,7 @@
   constructor();
 }
 
-void pComboButton::setGeometry(const Geometry &geometry) {
+void pComboButton::setGeometry(const Geometry& geometry) {
   SetWindowPos(hwnd, NULL, geometry.x, geometry.y, geometry.width, 1, SWP_NOZORDER);
   RECT rc;
   GetWindowRect(hwnd, &rc);
diff -ru higan_v092r07\phoenix\windows\widget\hex-edit.cpp higan_v092r08\phoenix\windows\widget\hex-edit.cpp
--- higan_v092r07\phoenix\windows\widget\hex-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\hex-edit.cpp	Thu May 02 05:48:05 2013
@@ -1,7 +1,7 @@
 namespace phoenix {
 
 static LRESULT CALLBACK HexEdit_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
-  HexEdit &hexEdit = *(HexEdit*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  HexEdit& hexEdit = *(HexEdit*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
   if(msg == WM_CHAR) {
     if(hexEdit.p.keyPress(wparam)) return 0;
   }
@@ -45,7 +45,7 @@
         uint8_t data = hexEdit.onRead(offset++);
         hexdata.append(hex<2>(data));
         hexdata.append(" ");
-        char buffer[2] = { data >= 0x20 && data <= 0x7e ? (char)data : '.', 0 };
+        char buffer[2] = {data >= 0x20 && data <= 0x7e ? (char)data : '.', 0};
         ansidata.append(buffer);
       } else {
         hexdata.append("   ");
diff -ru higan_v092r07\phoenix\windows\widget\label.cpp higan_v092r08\phoenix\windows\widget\label.cpp
--- higan_v092r07\phoenix\windows\widget\label.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\label.cpp	Thu May 02 05:48:05 2013
@@ -5,7 +5,7 @@
   return {size.width, size.height};
 }
 
-void pLabel::setText(const string &text) {
+void pLabel::setText(const string& text) {
   SetWindowText(hwnd, utf16_t(text));
   InvalidateRect(hwnd, 0, false);
 }
diff -ru higan_v092r07\phoenix\windows\widget\line-edit.cpp higan_v092r08\phoenix\windows\widget\line-edit.cpp
--- higan_v092r07\phoenix\windows\widget\line-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\line-edit.cpp	Thu May 02 05:48:05 2013
@@ -9,7 +9,7 @@
   SendMessage(hwnd, EM_SETREADONLY, editable == false, 0);
 }
 
-void pLineEdit::setText(const string &text) {
+void pLineEdit::setText(const string& text) {
   locked = true;
   SetWindowText(hwnd, utf16_t(text));
   locked = false;
diff -ru higan_v092r07\phoenix\windows\widget\list-view.cpp higan_v092r08\phoenix\windows\widget\list-view.cpp
--- higan_v092r07\phoenix\windows\widget\list-view.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\list-view.cpp	Thu May 02 05:48:05 2013
@@ -23,7 +23,7 @@
   ListView_SetItem(hwnd, &item);
 }
 
-void ImageList_Append(HIMAGELIST imageList, const nall::image &source) {
+void ImageList_Append(HIMAGELIST imageList, const nall::image& source) {
   auto image = source;
   if(image.empty()) {
     image.allocate(15, 15);
@@ -36,7 +36,7 @@
   DeleteObject(bitmap);
 }
 
-void pListView::append(const lstring &list) {
+void pListView::append(const lstring& list) {
   wchar_t empty[] = L"";
   unsigned row = ListView_GetItemCount(hwnd);
   LVITEM item;
@@ -64,7 +64,7 @@
   return ListView_GetCheckState(hwnd, row);
 }
 
-void pListView::modify(unsigned row, const lstring &list) {
+void pListView::modify(unsigned row, const lstring& list) {
   for(unsigned n = 0; n < list.size(); n++) {
     utf16_t wtext(list(n, ""));
     ListView_SetItemText(hwnd, row, n, wtext);
@@ -106,7 +106,7 @@
   locked = false;
 }
 
-void pListView::setHeaderText(const lstring &list) {
+void pListView::setHeaderText(const lstring& list) {
   while(ListView_DeleteColumn(hwnd, 0));
 
   lstring headers = list;
@@ -132,7 +132,7 @@
   );
 }
 
-void pListView::setImage(unsigned row, unsigned column, const image &image) {
+void pListView::setImage(unsigned row, unsigned column, const image& image) {
   //assign existing image
   for(unsigned n = 0; n < images.size(); n++) {
     if(images[n] == image) {
@@ -178,7 +178,7 @@
   setHeaderText(listView.state.headerText);
   setHeaderVisible(listView.state.headerVisible);
   setCheckable(listView.state.checkable);
-  for(auto &text : listView.state.text) append(text);
+  for(auto& text : listView.state.text) append(text);
   for(unsigned n = 0; n < listView.state.checked.size(); n++) setChecked(n, listView.state.checked[n]);
   buildImageList();
   if(listView.state.selected) setSelection(listView.state.selection);
@@ -195,13 +195,13 @@
   constructor();
 }
 
-void pListView::setGeometry(const Geometry &geometry) {
+void pListView::setGeometry(const Geometry& geometry) {
   pWidget::setGeometry(geometry);
   autoSizeColumns();
 }
 
 void pListView::buildImageList() {
-  auto &list = listView.state.image;
+  auto& list = listView.state.image;
   unsigned columns = listView.state.text.size();
   unsigned rows = max(1u, listView.state.headerText.size());
 
@@ -233,7 +233,7 @@
   }
 
   //build image list
-  for(auto &imageItem : images) ImageList_Append(imageList, imageItem);
+  for(auto& imageItem : images) ImageList_Append(imageList, imageItem);
   if(images.size() <= 1) return;
 
   //set images for all cells
diff -ru higan_v092r07\phoenix\windows\widget\radio-button.cpp higan_v092r08\phoenix\windows\widget\radio-button.cpp
--- higan_v092r07\phoenix\windows\widget\radio-button.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\radio-button.cpp	Thu May 02 05:48:05 2013
@@ -10,15 +10,15 @@
 }
 
 void pRadioButton::setChecked() {
-  for(auto &item : radioButton.state.group) {
+  for(auto& item : radioButton.state.group) {
     SendMessage(item.p.hwnd, BM_SETCHECK, (WPARAM)(&item == &radioButton), 0);
   }
 }
 
-void pRadioButton::setGroup(const group<RadioButton&> &group) {
+void pRadioButton::setGroup(const group<RadioButton>& group) {
 }
 
-void pRadioButton::setText(const string &text) {
+void pRadioButton::setText(const string& text) {
   SetWindowText(hwnd, utf16_t(text));
 }
 
diff -ru higan_v092r07\phoenix\windows\widget\text-edit.cpp higan_v092r08\phoenix\windows\widget\text-edit.cpp
--- higan_v092r07\phoenix\windows\widget\text-edit.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\text-edit.cpp	Thu May 02 05:48:05 2013
@@ -10,7 +10,7 @@
   SendMessage(hwnd, EM_SETREADONLY, editable == false, (LPARAM)0);
 }
 
-void pTextEdit::setText(const string &text) {
+void pTextEdit::setText(const string& text) {
   locked = true;
   string output = text;
   output.replace("\r", "");
diff -ru higan_v092r07\phoenix\windows\widget\viewport.cpp higan_v092r08\phoenix\windows\widget\viewport.cpp
--- higan_v092r07\phoenix\windows\widget\viewport.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\viewport.cpp	Thu May 02 05:48:05 2013
@@ -1,19 +1,19 @@
 namespace phoenix {
 
 static LRESULT CALLBACK Viewport_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
-  Object *object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
   if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
   if(!dynamic_cast<Viewport*>(object)) return DefWindowProc(hwnd, msg, wparam, lparam);
-  Viewport &viewport = (Viewport&)*object;
+  Viewport& viewport = (Viewport&)*object;
 
   if(msg == WM_GETDLGCODE) {
     return DLGC_STATIC | DLGC_WANTCHARS;
   }
 
   if(msg == WM_MOUSEMOVE) {
-    TRACKMOUSEEVENT tracker = { sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd };
+    TRACKMOUSEEVENT tracker = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd};
     TrackMouseEvent(&tracker);
-    if(viewport.onMouseMove) viewport.onMouseMove({ (int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam) });
+    if(viewport.onMouseMove) viewport.onMouseMove({(int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam)});
   }
 
   if(msg == WM_MOUSELEAVE) {
diff -ru higan_v092r07\phoenix\windows\widget\widget.cpp higan_v092r08\phoenix\windows\widget\widget.cpp
--- higan_v092r07\phoenix\windows\widget\widget.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\widget\widget.cpp	Thu May 02 05:48:05 2013
@@ -22,13 +22,13 @@
   SetFocus(hwnd);
 }
 
-void pWidget::setFont(const string &font) {
+void pWidget::setFont(const string& font) {
   if(hfont) DeleteObject(hfont);
   hfont = pFont::create(font);
   SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 0);
 }
 
-void pWidget::setGeometry(const Geometry &geometry) {
+void pWidget::setGeometry(const Geometry& geometry) {
   SetWindowPos(hwnd, NULL, geometry.x, geometry.y, geometry.width, geometry.height, SWP_NOZORDER);
 }
 
diff -ru higan_v092r07\phoenix\windows\window.cpp higan_v092r08\phoenix\windows\window.cpp
--- higan_v092r07\phoenix\windows\window.cpp	Fri Apr 12 16:38:16 2013
+++ higan_v092r08\phoenix\windows\window.cpp	Thu May 02 05:48:05 2013
@@ -15,12 +15,12 @@
   auto threadId = GetWindowThreadProcessId(GetForegroundWindow(), NULL);
   AttachThreadInput(threadId, GetCurrentThreadId(), TRUE);
 
-  pWindow *topMost = nullptr;
-  for(auto &object : pObject::objects) {
+  pWindow* topMost = nullptr;
+  for(auto& object : pObject::objects) {
     if(dynamic_cast<pWindow*>(object) == nullptr) continue;
-    pWindow *p = (pWindow*)object;
+    pWindow* p = (pWindow*)object;
     bool enable = modal.size() == 0 || modal.find(p);
-    EnableWindow(p->hwnd, enable);
+    if(IsWindowEnabled(p->hwnd) != enable) EnableWindow(p->hwnd, enable);
     if(enable && p->window.visible()) {
       if(topMost == nullptr) topMost = p;
       else if(GetWindowZOrder(p->hwnd) < GetWindowZOrder(topMost->hwnd)) topMost = p;
@@ -31,7 +31,6 @@
   if(topMost) {
     SetForegroundWindow(topMost->hwnd);
     SetActiveWindow(topMost->hwnd);
-    SetFocus(topMost->hwnd);
   }
 
   //unbind thread input hook
@@ -42,23 +41,23 @@
 static const unsigned ResizableStyle = WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME;
 
 Window& pWindow::none() {
-  static Window *window = nullptr;
+  static Window* window = nullptr;
   if(window == nullptr) window = new Window;
   return *window;
 }
 
-void pWindow::append(Layout &layout) {
+void pWindow::append(Layout& layout) {
   Geometry geom = window.state.geometry;
   geom.x = geom.y = 0;
   layout.setGeometry(geom);
 }
 
-void pWindow::append(Menu &menu) {
+void pWindow::append(Menu& menu) {
   menu.p.parentWindow = &window;
   updateMenu();
 }
 
-void pWindow::append(Widget &widget) {
+void pWindow::append(Widget& widget) {
   widget.p.parentWindow = &window;
   widget.p.orphan();
 
@@ -70,7 +69,7 @@
 Color pWindow::backgroundColor() {
   if(window.state.backgroundColorOverride) return window.state.backgroundColor;
   DWORD color = GetSysColor(COLOR_3DFACE);
-  return { (uint8_t)(color >> 16), (uint8_t)(color >> 8), (uint8_t)(color >> 0), 255 };
+  return {(uint8_t)(color >> 16), (uint8_t)(color >> 8), (uint8_t)(color >> 0), 255u};
 }
 
 bool pWindow::focused() {
@@ -80,7 +79,7 @@
 Geometry pWindow::frameMargin() {
   unsigned style = window.state.resizable ? ResizableStyle : FixedStyle;
   if(window.state.fullScreen) style = 0;
-  RECT rc = { 0, 0, 640, 480 };
+  RECT rc = {0, 0, 640, 480};
   AdjustWindowRect(&rc, style, window.state.menuVisible);
   unsigned statusHeight = 0;
   if(window.state.statusVisible) {
@@ -88,7 +87,7 @@
     GetClientRect(hstatus, &src);
     statusHeight = src.bottom - src.top;
   }
-  return { abs(rc.left), abs(rc.top), (rc.right - rc.left) - 640, (rc.bottom - rc.top) + statusHeight - 480 };
+  return {abs(rc.left), abs(rc.top), (rc.right - rc.left) - 640, (rc.bottom - rc.top) + statusHeight - 480};
 }
 
 Geometry pWindow::geometry() {
@@ -109,21 +108,21 @@
   unsigned width = (rc.right - rc.left) - margin.width;
   unsigned height = (rc.bottom - rc.top) - margin.height;
 
-  return { x, y, width, height };
+  return {x, y, width, height};
 }
 
-void pWindow::remove(Layout &layout) {
+void pWindow::remove(Layout& layout) {
 }
 
-void pWindow::remove(Menu &menu) {
+void pWindow::remove(Menu& menu) {
   updateMenu();
 }
 
-void pWindow::remove(Widget &widget) {
+void pWindow::remove(Widget& widget) {
   widget.p.orphan();
 }
 
-void pWindow::setBackgroundColor(const Color &color) {
+void pWindow::setBackgroundColor(const Color& color) {
   if(brush) DeleteObject(brush);
   brushColor = RGB(color.red, color.green, color.blue);
   brush = CreateSolidBrush(brushColor);
@@ -142,12 +141,12 @@
   } else {
     SetWindowLongPtr(hwnd, GWL_STYLE, WS_VISIBLE | WS_POPUP);
     Geometry margin = frameMargin();
-    setGeometry({ margin.x, margin.y, GetSystemMetrics(SM_CXSCREEN) - margin.width, GetSystemMetrics(SM_CYSCREEN) - margin.height });
+    setGeometry({margin.x, margin.y, GetSystemMetrics(SM_CXSCREEN) - margin.width, GetSystemMetrics(SM_CYSCREEN) - margin.height});
   }
   locked = false;
 }
 
-void pWindow::setGeometry(const Geometry &geometry) {
+void pWindow::setGeometry(const Geometry& geometry) {
   locked = true;
   Geometry margin = frameMargin();
   SetWindowPos(
@@ -157,7 +156,7 @@
     SWP_NOZORDER | SWP_FRAMECHANGED
   );
   SetWindowPos(hstatus, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_FRAMECHANGED);
-  for(auto &layout : window.state.layout) {
+  for(auto& layout : window.state.layout) {
     Geometry geom = this->geometry();
     geom.x = geom.y = 0;
     layout.setGeometry(geom);
@@ -165,7 +164,7 @@
   locked = false;
 }
 
-void pWindow::setMenuFont(const string &font) {
+void pWindow::setMenuFont(const string& font) {
 }
 
 void pWindow::setMenuVisible(bool visible) {
@@ -193,13 +192,13 @@
   setGeometry(window.state.geometry);
 }
 
-void pWindow::setStatusFont(const string &font) {
+void pWindow::setStatusFont(const string& font) {
   if(hstatusfont) DeleteObject(hstatusfont);
   hstatusfont = pFont::create(font);
   SendMessage(hstatus, WM_SETFONT, (WPARAM)hstatusfont, 0);
 }
 
-void pWindow::setStatusText(const string &text) {
+void pWindow::setStatusText(const string& text) {
   SendMessage(hstatus, SB_SETTEXT, 0, (LPARAM)(wchar_t*)utf16_t(text));
 }
 
@@ -210,7 +209,7 @@
   locked = false;
 }
 
-void pWindow::setTitle(const string &text) {
+void pWindow::setTitle(const string& text) {
   SetWindowText(hwnd, utf16_t(text));
 }
 
@@ -235,7 +234,7 @@
   SetWindowLongPtr(hstatus, GWL_STYLE, GetWindowLong(hstatus, GWL_STYLE) | WS_DISABLED);
 
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&window);
-  setGeometry({ 128, 128, 256, 256 });
+  setGeometry({128, 128, 256, 256});
 }
 
 void pWindow::destructor() {
@@ -249,7 +248,7 @@
   if(hmenu) DestroyMenu(hmenu);
   hmenu = CreateMenu();
 
-  for(auto &menu : window.state.menu) {
+  for(auto& menu : window.state.menu) {
     menu.p.update(window);
     if(menu.visible()) {
       AppendMenu(hmenu, MF_STRING | MF_POPUP, (UINT_PTR)menu.p.hmenu, utf16_t(menu.state.text));
diff -ru higan_v092r07\ruby\audio\alsa.cpp higan_v092r08\ruby\audio\alsa.cpp
--- higan_v092r07\ruby\audio\alsa.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\alsa.cpp	Thu May 02 05:48:02 2013
@@ -8,16 +8,16 @@
 class pAudioALSA {
 public:
   struct {
-    snd_pcm_t *handle;
+    snd_pcm_t* handle;
     snd_pcm_format_t format;
     snd_pcm_uframes_t buffer_size;
     snd_pcm_uframes_t period_size;
     int channels;
-    const char *name;
+    const char* name;
   } device;
 
   struct {
-    uint32_t *data;
+    uint32_t* data;
     unsigned length;
   } buffer;
 
@@ -100,7 +100,7 @@
     }
     #endif
 
-    uint32_t *buffer_ptr = buffer.data;
+    uint32_t* buffer_ptr = buffer.data;
     int i = 4;
 
     while((buffer.length > 0) && i--) {
@@ -148,8 +148,8 @@
     }
     #endif
 
-    snd_pcm_hw_params_t *hwparams;
-    snd_pcm_sw_params_t *swparams;
+    snd_pcm_hw_params_t* hwparams;
+    snd_pcm_sw_params_t* swparams;
     unsigned rate = settings.frequency;
     unsigned buffer_time = settings.latency * 1000;
     unsigned period_time = settings.latency * 1000 / 4;
diff -ru higan_v092r07\ruby\audio\ao.cpp higan_v092r08\ruby\audio\ao.cpp
--- higan_v092r07\ruby\audio\ao.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\ao.cpp	Thu May 02 05:48:02 2013
@@ -11,7 +11,7 @@
 public:
   int driver_id;
   ao_sample_format driver_format;
-  ao_device *audio_device;
+  ao_device* audio_device;
 
   struct {
     unsigned frequency;
@@ -56,7 +56,7 @@
     driver_format.rate = settings.frequency;
     driver_format.byte_format = AO_FMT_LITTLE;
 
-    ao_option *options = 0;
+    ao_option* options = nullptr;
     ao_info *di = ao_driver_info(driver_id);
     if(!di) return false;
     if(!strcmp(di->short_name, "alsa")) {
diff -ru higan_v092r07\ruby\audio\directsound.cpp higan_v092r08\ruby\audio\directsound.cpp
--- higan_v092r07\ruby\audio\directsound.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\directsound.cpp	Thu May 02 05:48:02 2013
@@ -18,7 +18,7 @@
     unsigned rings;
     unsigned latency;
 
-    uint32_t *buffer;
+    uint32_t* buffer;
     unsigned bufferoffset;
 
     unsigned readring;
@@ -82,7 +82,7 @@
     device.bufferoffset = 0;
 
     DWORD pos, size;
-    void *output;
+    void* output;
 
     if(settings.synchronize == true) {
       //wait until playback buffer has an empty ring to write new audio data to
@@ -129,7 +129,7 @@
     dsb_b->SetCurrentPosition(0);
 
     DWORD size;
-    void *output;
+    void* output;
     dsb_b->Lock(0, device.latency * device.rings * 4, &output, &size, 0, 0, 0);
     memset(output, 0, size);
     dsb_b->Unlock(output, size, 0, 0);
diff -ru higan_v092r07\ruby\audio\openal.cpp higan_v092r08\ruby\audio\openal.cpp
--- higan_v092r07\ruby\audio\openal.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\openal.cpp	Thu May 02 05:48:02 2013
@@ -17,8 +17,8 @@
 class pAudioOpenAL {
 public:
   struct {
-    ALCdevice *handle;
-    ALCcontext *context;
+    ALCdevice* handle;
+    ALCcontext* context;
     ALuint source;
     ALenum format;
     unsigned latency;
@@ -26,7 +26,7 @@
   } device;
 
   struct {
-    uint32_t *data;
+    uint32_t* data;
     unsigned length;
     unsigned size;
   } buffer;
@@ -132,7 +132,7 @@
 
         alListener3f(AL_POSITION, 0.0, 0.0, 0.0);
         alListener3f(AL_VELOCITY, 0.0, 0.0, 0.0);
-        ALfloat listener_orientation[] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };
+        ALfloat listener_orientation[] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
         alListenerfv(AL_ORIENTATION, listener_orientation);
 
         success = true;
diff -ru higan_v092r07\ruby\audio\oss.cpp higan_v092r08\ruby\audio\oss.cpp
--- higan_v092r07\ruby\audio\oss.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\oss.cpp	Thu May 02 05:48:02 2013
@@ -31,7 +31,7 @@
     int fd;
     int format;
     int channels;
-    const char *name;
+    const char* name;
   } device;
 
   struct {
diff -ru higan_v092r07\ruby\audio\pulseaudio.cpp higan_v092r08\ruby\audio\pulseaudio.cpp
--- higan_v092r07\ruby\audio\pulseaudio.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\pulseaudio.cpp	Thu May 02 05:48:02 2013
@@ -8,16 +8,16 @@
 class pAudioPulseAudio {
 public:
   struct {
-    pa_mainloop *mainloop;
-    pa_context *context;
-    pa_stream *stream;
+    pa_mainloop* mainloop;
+    pa_context* context;
+    pa_stream* stream;
     pa_sample_spec spec;
     pa_buffer_attr buffer_attr;
     bool first;
   } device;
 
   struct {
-    uint32_t *data;
+    uint32_t* data;
     size_t size;
     unsigned offset;
   } buffer;
diff -ru higan_v092r07\ruby\audio\pulseaudiosimple.cpp higan_v092r08\ruby\audio\pulseaudiosimple.cpp
--- higan_v092r07\ruby\audio\pulseaudiosimple.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\pulseaudiosimple.cpp	Thu May 02 05:48:02 2013
@@ -9,12 +9,12 @@
 class pAudioPulseAudioSimple {
 public:
   struct {
-    pa_simple *handle;
+    pa_simple* handle;
     pa_sample_spec spec;
   } device;
 
   struct {
-    uint32_t *data;
+    uint32_t* data;
     unsigned offset;
   } buffer;
 
@@ -90,18 +90,18 @@
       int error;
       pa_simple_flush(device.handle, &error);
       pa_simple_free(device.handle);
-      device.handle = 0;
+      device.handle = nullptr;
     }
 
     if(buffer.data) {
       delete[] buffer.data;
-      buffer.data = 0;
+      buffer.data = nullptr;
     }
   }
 
   pAudioPulseAudioSimple() {
-    device.handle = 0;
-    buffer.data = 0;
+    device.handle = nullptr;
+    buffer.data = nullptr;
     settings.frequency = 22050;
   }
 
diff -ru higan_v092r07\ruby\audio\xaudio2.cpp higan_v092r08\ruby\audio\xaudio2.cpp
--- higan_v092r07\ruby\audio\xaudio2.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio\xaudio2.cpp	Thu May 02 05:48:02 2013
@@ -4,21 +4,21 @@
 */
 
 #include "xaudio2.hpp"
-#include <Windows.h>
+#include <windows.h>
 
 namespace ruby {
 
 class pAudioXAudio2: public IXAudio2VoiceCallback {
 public:
-  IXAudio2 *pXAudio2;
+  IXAudio2* pXAudio2;
   IXAudio2MasteringVoice* pMasterVoice;
-  IXAudio2SourceVoice *pSourceVoice;
-  
-  // inherited from IXAudio2VoiceCallback
-  STDMETHODIMP_(void) OnBufferStart(void *pBufferContext){}
-  STDMETHODIMP_(void) OnLoopEnd(void *pBufferContext){}
+  IXAudio2SourceVoice* pSourceVoice;
+
+  //inherited from IXAudio2VoiceCallback
+  STDMETHODIMP_(void) OnBufferStart(void* pBufferContext){}
+  STDMETHODIMP_(void) OnLoopEnd(void* pBufferContext){}
   STDMETHODIMP_(void) OnStreamEnd() {}
-  STDMETHODIMP_(void) OnVoiceError(void *pBufferContext, HRESULT Error) {}
+  STDMETHODIMP_(void) OnVoiceError(void* pBufferContext, HRESULT Error) {}
   STDMETHODIMP_(void) OnVoiceProcessingPassEnd() {}
   STDMETHODIMP_(void) OnVoiceProcessingPassStart(UINT32 BytesRequired) {}
 
@@ -26,7 +26,7 @@
     unsigned buffers;
     unsigned latency;
 
-    uint32_t *buffer;
+    uint32_t* buffer;
     unsigned bufferoffset;
 
     volatile long submitbuffers;
@@ -74,12 +74,12 @@
 
     return false;
   }
-  
-  void pushbuffer(unsigned bytes,uint32_t *pAudioData) {
-    XAUDIO2_BUFFER xa2buffer={0};
-    xa2buffer.AudioBytes=bytes;
-    xa2buffer.pAudioData=reinterpret_cast<BYTE *>(pAudioData);
-    xa2buffer.pContext=0;
+
+  void pushbuffer(unsigned bytes, uint32_t* pAudioData) {
+    XAUDIO2_BUFFER xa2buffer = {0};
+    xa2buffer.AudioBytes = bytes;
+    xa2buffer.pAudioData = reinterpret_cast<BYTE*>(pAudioData);
+    xa2buffer.pContext = 0;
     InterlockedIncrement(&device.submitbuffers);
     pSourceVoice->SubmitSourceBuffer(&xa2buffer);
   }
@@ -95,11 +95,11 @@
         while(device.submitbuffers == device.buffers - 1) {
           //Sleep(0);
         }
-      } else { //we need one free buffer for the next sample, so ignore the current contents
+      } else {  //we need one free buffer for the next sample, so ignore the current contents
         return;
       }
     }
-    
+
     pushbuffer(device.latency * 4,device.buffer + device.writebuffer * device.latency);
 
     device.writebuffer = (device.writebuffer + 1) % device.buffers;
@@ -108,22 +108,22 @@
   void clear() {
     if(!pSourceVoice) return;
     pSourceVoice->Stop(0);
-    pSourceVoice->FlushSourceBuffers();     //calls OnBufferEnd for all currently submitted buffers
-    
+    pSourceVoice->FlushSourceBuffers();  //calls OnBufferEnd for all currently submitted buffers
+
     device.writebuffer = 0;
 
     device.bufferoffset = 0;
     if(device.buffer) memset(device.buffer, 0, device.latency * device.buffers * 4);
 
-     pSourceVoice->Start(0);
+    pSourceVoice->Start(0);
   }
 
   bool init() {
     term();
 
-    device.buffers   = 8;
+    device.buffers = 8;
     device.latency = settings.frequency * settings.latency / device.buffers / 1000.0 + 0.5;
-    device.buffer  = new uint32_t[device.latency * device.buffers];
+    device.buffer = new uint32_t[device.latency * device.buffers];
     device.bufferoffset = 0;
     device.submitbuffers = 0;
 
@@ -131,9 +131,8 @@
     if(FAILED(hr = XAudio2Create(&pXAudio2, 0 , XAUDIO2_DEFAULT_PROCESSOR))) {
       return false;
     }
-    
-    if(FAILED(hr = pXAudio2->CreateMasteringVoice( &pMasterVoice, 2,
-        settings.frequency, 0, 0 , NULL))) {
+
+    if(FAILED(hr = pXAudio2->CreateMasteringVoice( &pMasterVoice, 2, settings.frequency, 0, 0 , NULL))) {
       return false;
     }
 
@@ -146,8 +145,7 @@
     wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
     wfx.cbSize = 0;
 
-    if(FAILED(hr = pXAudio2->CreateSourceVoice(&pSourceVoice, (WAVEFORMATEX*)&wfx,
-        XAUDIO2_VOICE_NOSRC , XAUDIO2_DEFAULT_FREQ_RATIO, this, NULL, NULL))) {
+    if(FAILED(hr = pXAudio2->CreateSourceVoice(&pSourceVoice, (WAVEFORMATEX*)&wfx, XAUDIO2_VOICE_NOSRC , XAUDIO2_DEFAULT_FREQ_RATIO, this, NULL, NULL))) {
       return false;
     }
 
@@ -159,32 +157,32 @@
     if(pSourceVoice) {
       pSourceVoice->Stop(0);
       pSourceVoice->DestroyVoice();
-      pSourceVoice = 0;
+      pSourceVoice = nullptr;
     }
     if(pMasterVoice) {
       pMasterVoice->DestroyVoice();
-      pMasterVoice = 0;
+      pMasterVoice = nullptr;
     }
     if(pXAudio2) {
       pXAudio2->Release();
-      pXAudio2 = NULL;
+      pXAudio2 = nullptr;
     }
     if(device.buffer) {
       delete[] device.buffer;
-      device.buffer = 0;
+      device.buffer = nullptr;
     }
   }
-  
-  STDMETHODIMP_(void) OnBufferEnd(void *pBufferContext) {
+
+  STDMETHODIMP_(void) OnBufferEnd(void* pBufferContext) {
     InterlockedDecrement(&device.submitbuffers);
   }
 
   pAudioXAudio2() {
-    pXAudio2 = 0;
-    pMasterVoice = 0;
-    pSourceVoice = 0;
+    pXAudio2 = nullptr;
+    pMasterVoice = nullptr;
+    pSourceVoice = nullptr;
 
-    device.buffer = 0;
+    device.buffer = nullptr;
     device.bufferoffset = 0;
     device.submitbuffers = 0;
     device.writebuffer = 0;
diff -ru higan_v092r07\ruby\audio.hpp higan_v092r08\ruby\audio.hpp
--- higan_v092r07\ruby\audio.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\audio.hpp	Thu May 02 05:48:02 2013
@@ -1,8 +1,8 @@
 struct Audio {
-  static const char *Handle;
-  static const char *Synchronize;
-  static const char *Frequency;
-  static const char *Latency;
+  static const char* Handle;
+  static const char* Synchronize;
+  static const char* Frequency;
+  static const char* Latency;
 
   virtual bool cap(const nall::string& name) { return false; }
   virtual nall::any get(const nall::string& name) { return false; }
diff -ru higan_v092r07\ruby\implementation.cpp higan_v092r08\ruby\implementation.cpp
--- higan_v092r07\ruby\implementation.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\implementation.cpp	Thu May 02 05:48:02 2013
@@ -37,7 +37,7 @@
     any get(const string& name) { return p.get(name); } \
     bool set(const string& name, const any& value) { return p.set(name, value); } \
     \
-    bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) { return p.lock(data, pitch, width, height); } \
+    bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) { return p.lock(data, pitch, width, height); } \
     void unlock() { p.unlock(); } \
     \
     void clear() { p.clear(); } \
@@ -49,7 +49,7 @@
     ~Video##Name() { delete &p; } \
   \
   private: \
-    pVideo##Name &p; \
+    pVideo##Name& p; \
   };
 
 #ifdef VIDEO_CGL
@@ -114,7 +114,7 @@
     ~Audio##Name() { delete &p; } \
   \
   private: \
-    pAudio##Name &p; \
+    pAudio##Name& p; \
   };
 
 #ifdef AUDIO_ALSA
@@ -162,7 +162,7 @@
     bool unacquire() { return p.unacquire(); } \
     bool acquired() { return p.acquired(); } \
     \
-    bool poll(int16_t *table) { return p.poll(table); } \
+    bool poll(int16_t* table) { return p.poll(table); } \
     bool init() { return p.init(); } \
     void term() { p.term(); } \
     \
@@ -170,7 +170,7 @@
     ~Input##Name() { delete &p; } \
   \
   private: \
-    pInput##Name &p; \
+    pInput##Name& p; \
   };
 
 #ifdef INPUT_DIRECTINPUT
diff -ru higan_v092r07\ruby\input\carbon.cpp higan_v092r08\ruby\input\carbon.cpp
--- higan_v092r07\ruby\input\carbon.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\carbon.cpp	Thu May 02 05:48:02 2013
@@ -1,7 +1,6 @@
 namespace ruby {
 
-class pInputCarbon {
-public:
+struct pInputCarbon {
   bool cap(const string& name) {
     return false;
   }
@@ -18,12 +17,12 @@
   bool unacquire() { return false; }
   bool acquired() { return false; }
 
-  bool poll(int16_t *table) {
+  bool poll(int16_t* table) {
     memset(table, 0, Scancode::Limit * sizeof(int16_t));
 
     KeyMap keys;
     GetKeys(keys);
-    uint8_t *keymap = (uint8_t*)keys;
+    uint8_t* keymap = (uint8_t*)keys;
 
     #define map(id, name) table[keyboard(0)[name]] = (bool)(keymap[id >> 3] & (1 << (id & 7)))
     map(0x35, Keyboard::Escape);
diff -ru higan_v092r07\ruby\input\directinput.cpp higan_v092r08\ruby\input\directinput.cpp
--- higan_v092r07\ruby\input\directinput.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\directinput.cpp	Thu May 02 05:48:02 2013
@@ -44,7 +44,7 @@
     return false;
   }
 
-  bool poll(int16_t *table) {
+  bool poll(int16_t* table) {
     memset(table, 0, Scancode::Limit * sizeof(int16_t));
 
     //========
@@ -251,7 +251,7 @@
     return true;
   }
 
-  bool init_joypad(const DIDEVICEINSTANCE *instance) {
+  bool init_joypad(const DIDEVICEINSTANCE* instance) {
     unsigned n;
     for(n = 0; n < Joypad::Count; n++) { if(!device.gamepad[n]) break; }
     if(n >= Joypad::Count) return DIENUM_STOP;
@@ -267,7 +267,7 @@
     return DIENUM_CONTINUE;
   }
 
-  bool init_axis(const DIDEVICEOBJECTINSTANCE *instance) {
+  bool init_axis(const DIDEVICEOBJECTINSTANCE* instance) {
     signed n;
     for(n = Joypad::Count - 1; n >= 0; n--) { if(device.gamepad[n]) break; }
     if(n < 0) return DIENUM_STOP;
@@ -374,11 +374,11 @@
   ~pInputDI() { term(); }
 };
 
-BOOL CALLBACK DI_EnumJoypadsCallback(const DIDEVICEINSTANCE *instance, void *p) {
+BOOL CALLBACK DI_EnumJoypadsCallback(const DIDEVICEINSTANCE* instance, void* p) {
   return ((pInputDI*)p)->init_joypad(instance);
 }
 
-BOOL CALLBACK DI_EnumJoypadAxesCallback(const DIDEVICEOBJECTINSTANCE *instance, void *p) {
+BOOL CALLBACK DI_EnumJoypadAxesCallback(const DIDEVICEOBJECTINSTANCE* instance, void* p) {
   return ((pInputDI*)p)->init_axis(instance);
 }
 
diff -ru higan_v092r07\ruby\input\rawinput.cpp higan_v092r08\ruby\input\rawinput.cpp
--- higan_v092r07\ruby\input\rawinput.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\rawinput.cpp	Thu May 02 05:48:03 2013
@@ -41,7 +41,7 @@
   struct Keyboard : Device {
     bool state[nall::Keyboard::Size];
 
-    void update(RAWINPUT *input) {
+    void update(RAWINPUT* input) {
       unsigned code  = input->data.keyboard.MakeCode;
       unsigned flags = input->data.keyboard.Flags;
 
@@ -199,7 +199,7 @@
       zDistance = 0;
     }
 
-    void update(RAWINPUT *input) {
+    void update(RAWINPUT* input) {
       if((input->data.mouse.usFlags & 1) == MOUSE_MOVE_RELATIVE) {
         xDistance += input->data.mouse.lLastX;
         yDistance += input->data.mouse.lLastY;
@@ -503,7 +503,7 @@
     int16_t axis[6];
     bool button[128];
 
-    void poll(DIJOYSTATE2 &state) {
+    void poll(DIJOYSTATE2& state) {
       //POV hats
       for(unsigned n = 0; n < 4; n++) {
         hat[n] = Joypad::HatCenter;
@@ -557,7 +557,7 @@
     }
   }
 
-  bool init_joypad(const DIDEVICEINSTANCE *instance) {
+  bool init_joypad(const DIDEVICEINSTANCE* instance) {
     //if this is an XInput device, do not acquire it via DirectInput ...
     //the XInput driver above will handle said device.
     for(unsigned i = 0; i < rawinput.lgamepad.size(); i++) {
@@ -581,7 +581,7 @@
     return DIENUM_CONTINUE;
   }
 
-  bool init_axis(const DIDEVICEOBJECTINSTANCE *instance) {
+  bool init_axis(const DIDEVICEOBJECTINSTANCE* instance) {
     DIPROPRANGE range;
     range.diph.dwSize = sizeof(DIPROPRANGE);
     range.diph.dwHeaderSize = sizeof(DIPROPHEADER);
@@ -616,11 +616,11 @@
   LPDIRECTINPUTDEVICE8 device;
 };
 
-BOOL CALLBACK DirectInput_EnumJoypadsCallback(const DIDEVICEINSTANCE *instance, void *p) {
+BOOL CALLBACK DirectInput_EnumJoypadsCallback(const DIDEVICEINSTANCE* instance, void* p) {
   return ((DirectInput*)p)->init_joypad(instance);
 }
 
-BOOL CALLBACK DirectInput_EnumJoypadAxesCallback(const DIDEVICEOBJECTINSTANCE *instance, void *p) {
+BOOL CALLBACK DirectInput_EnumJoypadAxesCallback(const DIDEVICEOBJECTINSTANCE* instance, void* p) {
   return ((DirectInput*)p)->init_axis(instance);
 }
 
@@ -687,7 +687,7 @@
     return GetCapture() == settings.handle;
   }
 
-  bool poll(int16_t *table) {
+  bool poll(int16_t* table) {
     memset(table, 0, Scancode::Limit * sizeof(int16_t));
 
     WaitForSingleObject(rawinput.mutex, INFINITE);
diff -ru higan_v092r07\ruby\input\sdl.cpp higan_v092r08\ruby\input\sdl.cpp
--- higan_v092r07\ruby\input\sdl.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\sdl.cpp	Thu May 02 05:48:03 2013
@@ -15,10 +15,10 @@
   #include "xlibkeys.hpp"
 
   struct {
-    Display *display;
+    Display* display;
     Window rootwindow;
     Cursor InvisibleCursor;
-    SDL_Joystick *gamepad[Joypad::Count];
+    SDL_Joystick* gamepad[Joypad::Count];
 
     unsigned screenwidth, screenheight;
     unsigned relativex, relativey;
@@ -90,7 +90,7 @@
     return device.mouseacquired;
   }
 
-  bool poll(int16_t *table) {
+  bool poll(int16_t* table) {
     memset(table, 0, Scancode::Limit * sizeof(int16_t));
 
     //========
diff -ru higan_v092r07\ruby\input\x.cpp higan_v092r08\ruby\input\x.cpp
--- higan_v092r07\ruby\input\x.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\x.cpp	Thu May 02 05:48:03 2013
@@ -28,7 +28,7 @@
   bool unacquire() { return false; }
   bool acquired() { return false; }
 
-  bool poll(int16_t *table) {
+  bool poll(int16_t* table) {
     memset(table, 0, Scancode::Limit * sizeof(int16_t));
     x_poll(display, table);
     return true;
diff -ru higan_v092r07\ruby\input\xlibkeys.hpp higan_v092r08\ruby\input\xlibkeys.hpp
--- higan_v092r07\ruby\input\xlibkeys.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input\xlibkeys.hpp	Thu May 02 05:48:03 2013
@@ -16,7 +16,7 @@
   LeftShift, RightShift, LeftControl, RightControl, LeftAlt, RightAlt, LeftSuper, RightSuper,
 };
 
-void x_poll(Display *display, int16_t *table) {
+void x_poll(Display* display, int16_t* table) {
   if(!display) return;
 
   char state[32];
@@ -139,7 +139,7 @@
   #undef pressed
 }
 
-void x_init(Display *display) {
+void x_init(Display* display) {
   if(!display) return;
 
   memset(&scancode, 0, sizeof scancode);
diff -ru higan_v092r07\ruby\input.hpp higan_v092r08\ruby\input.hpp
--- higan_v092r07\ruby\input.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\input.hpp	Thu May 02 05:48:03 2013
@@ -1,8 +1,8 @@
 struct Input {
-  static const char *Handle;
-  static const char *KeyboardSupport;
-  static const char *MouseSupport;
-  static const char *JoypadSupport;
+  static const char* Handle;
+  static const char* KeyboardSupport;
+  static const char* MouseSupport;
+  static const char* JoypadSupport;
 
   virtual bool cap(const nall::string& name) { return false; }
   virtual nall::any get(const nall::string& name) { return false; }
@@ -12,7 +12,7 @@
   virtual bool unacquire() { return false; }
   virtual bool acquired() { return false; }
 
-  virtual bool poll(int16_t *table) { return false; }
+  virtual bool poll(int16_t* table) { return false; }
   virtual bool init() { return true; }
   virtual void term() {}
 
diff -ru higan_v092r07\ruby\ruby.cpp higan_v092r08\ruby\ruby.cpp
--- higan_v092r07\ruby\ruby.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\ruby.cpp	Thu May 02 05:48:03 2013
@@ -12,16 +12,16 @@
 
 /* VideoInterface */
 
-const char *Video::Handle = "Handle";
-const char *Video::Synchronize = "Synchronize";
-const char *Video::Depth = "Depth";
-const char *Video::Filter = "Filter";
-const char *Video::Shader = "Shader";
+const char* Video::Handle = "Handle";
+const char* Video::Synchronize = "Synchronize";
+const char* Video::Depth = "Depth";
+const char* Video::Filter = "Filter";
+const char* Video::Shader = "Shader";
 
 const unsigned Video::FilterNearest = 0;
 const unsigned Video::FilterLinear  = 1;
 
-void VideoInterface::driver(const char *driver) {
+void VideoInterface::driver(const char* driver) {
   if(p) term();
 
   if(!driver || !*driver) driver = default_driver();
@@ -176,7 +176,7 @@
 bool VideoInterface::cap(const string& name) { return p ? p->cap(name) : false; }
 any VideoInterface::get(const string& name) { return p ? p->get(name) : false; }
 bool VideoInterface::set(const string& name, const any& value) { return p ? p->set(name, value) : false; }
-bool VideoInterface::lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) { return p ? p->lock(data, pitch, width, height) : false; }
+bool VideoInterface::lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) { return p ? p->lock(data, pitch, width, height) : false; }
 void VideoInterface::unlock() { if(p) p->unlock(); }
 void VideoInterface::clear() { if(p) p->clear(); }
 void VideoInterface::refresh() { if(p) p->refresh(); }
@@ -185,12 +185,12 @@
 
 /* AudioInterface */
 
-const char *Audio::Handle = "Handle";
-const char *Audio::Synchronize = "Synchronize";
-const char *Audio::Frequency = "Frequency";
-const char *Audio::Latency = "Latency";
+const char* Audio::Handle = "Handle";
+const char* Audio::Synchronize = "Synchronize";
+const char* Audio::Frequency = "Frequency";
+const char* Audio::Latency = "Latency";
 
-void AudioInterface::driver(const char *driver) {
+void AudioInterface::driver(const char* driver) {
   if(p) term();
 
   if(!driver || !*driver) driver = default_driver();
@@ -320,12 +320,12 @@
 
 /* InputInterface */
 
-const char *Input::Handle = "Handle";
-const char *Input::KeyboardSupport = "KeyboardSupport";
-const char *Input::MouseSupport = "MouseSupport";
-const char *Input::JoypadSupport = "JoypadSupport";
+const char* Input::Handle = "Handle";
+const char* Input::KeyboardSupport = "KeyboardSupport";
+const char* Input::MouseSupport = "MouseSupport";
+const char* Input::JoypadSupport = "JoypadSupport";
 
-void InputInterface::driver(const char *driver) {
+void InputInterface::driver(const char* driver) {
   if(p) term();
 
   if(!driver || !*driver) driver = default_driver();
@@ -422,7 +422,7 @@
 bool InputInterface::acquire() { return p ? p->acquire() : false; }
 bool InputInterface::unacquire() { return p ? p->unacquire() : false; }
 bool InputInterface::acquired() { return p ? p->acquired() : false; }
-bool InputInterface::poll(int16_t *table) { return p ? p->poll(table) : false; }
+bool InputInterface::poll(int16_t* table) { return p ? p->poll(table) : false; }
 InputInterface::InputInterface() : p(nullptr) {}
 InputInterface::~InputInterface() { term(); }
 
diff -ru higan_v092r07\ruby\ruby.hpp higan_v092r08\ruby\ruby.hpp
--- higan_v092r07\ruby\ruby.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\ruby.hpp	Thu May 02 05:48:03 2013
@@ -17,7 +17,7 @@
 #include <ruby/input.hpp>
 
 struct VideoInterface {
-  void driver(const char *driver = "");
+  void driver(const char* driver = "");
   const char* default_driver();
   const char* driver_list();
   bool init();
@@ -27,7 +27,7 @@
   nall::any get(const nall::string& name);
   bool set(const nall::string& name, const nall::any& value);
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height);
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height);
   void unlock();
   void clear();
   void refresh();
@@ -35,11 +35,11 @@
   ~VideoInterface();
 
 private:
-  Video *p;
+  Video* p = nullptr;
 };
 
 struct AudioInterface {
-  void driver(const char *driver = "");
+  void driver(const char* driver = "");
   const char* default_driver();
   const char* driver_list();
   bool init();
@@ -55,11 +55,11 @@
   ~AudioInterface();
 
 private:
-  Audio *p;
+  Audio* p = nullptr;
 };
 
 struct InputInterface {
-  void driver(const char *driver = "");
+  void driver(const char* driver = "");
   const char* default_driver();
   const char* driver_list();
   bool init();
@@ -73,12 +73,12 @@
   bool unacquire();
   bool acquired();
 
-  bool poll(int16_t *table);
+  bool poll(int16_t* table);
   InputInterface();
   ~InputInterface();
 
 private:
-  Input *p;
+  Input* p = nullptr;
 };
 
 extern VideoInterface video;
diff -ru higan_v092r07\ruby\video\cgl.cpp higan_v092r08\ruby\video\cgl.cpp
--- higan_v092r07\ruby\video\cgl.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\cgl.cpp	Thu May 02 05:48:03 2013
@@ -6,7 +6,7 @@
 
 @interface RubyVideoCGL : NSOpenGLView {
 @public
-  ruby::pVideoCGL *video;
+  ruby::pVideoCGL* video;
 }
 -(id) initWith:(ruby::pVideoCGL*)video pixelFormat:(NSOpenGLPixelFormat*)pixelFormat;
 -(void) reshape;
@@ -14,19 +14,18 @@
 
 namespace ruby {
 
-class pVideoCGL : public OpenGL {
-public:
-  RubyVideoCGL *view;
+struct pVideoCGL : OpenGL {
+  RubyVideoCGL* view;
 
   struct {
-    NSView *handle;
+    NSView* handle;
 
     bool synchronize;
     unsigned filter;
     string shader;
   } settings;
 
-  bool cap(const string &name) {
+  bool cap(const string& name) {
     if(name == Video::Handle) return true;
     if(name == Video::Synchronize) return true;
     if(name == Video::Filter) return true;
@@ -34,14 +33,14 @@
     return false;
   }
 
-  any get(const string &name) {
+  any get(const string& name) {
     if(name == Video::Handle) return (uintptr_t)settings.handle;
     if(name == Video::Synchronize) return settings.synchronize;
     if(name == Video::Filter) return settings.filter;
     return false;
   }
 
-  bool set(const string &name, const any &value) {
+  bool set(const string& name, const any& value) {
     if(name == Video::Handle) {
       settings.handle = (NSView*)any_cast<uintptr_t>(value);
       return true;
@@ -81,7 +80,7 @@
     return false;
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     OpenGL::size(width, height);
     return OpenGL::lock(data, pitch);
   }
diff -ru higan_v092r07\ruby\video\direct3d.cpp higan_v092r08\ruby\video\direct3d.cpp
--- higan_v092r07\ruby\video\direct3d.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\direct3d.cpp	Thu May 02 05:48:03 2013
@@ -6,25 +6,26 @@
 
 #define D3DVERTEX (D3DFVF_XYZRHW | D3DFVF_TEX1)
 
-typedef HRESULT (__stdcall *EffectProc)(LPDIRECT3DDEVICE9, LPCVOID, UINT, D3DXMACRO const*, LPD3DXINCLUDE, DWORD, LPD3DXEFFECTPOOL, LPD3DXEFFECT*, LPD3DXBUFFER*);
-typedef HRESULT (__stdcall *TextureProc)(LPDIRECT3DDEVICE9, LPCTSTR, LPDIRECT3DTEXTURE9*);
+typedef HRESULT (__stdcall* EffectProc)(LPDIRECT3DDEVICE9, LPCVOID, UINT, D3DXMACRO const*, LPD3DXINCLUDE, DWORD, LPD3DXEFFECTPOOL, LPD3DXEFFECT*, LPD3DXBUFFER*);
+typedef HRESULT (__stdcall* TextureProc)(LPDIRECT3DDEVICE9, LPCTSTR, LPDIRECT3DTEXTURE9*);
 
 namespace ruby {
 
 class pVideoD3D {
 public:
-  LPDIRECT3D9             lpd3d;
-  LPDIRECT3DDEVICE9       device;
-  LPDIRECT3DVERTEXBUFFER9 vertex_buffer, *vertex_ptr;
-  D3DPRESENT_PARAMETERS   presentation;
-  D3DSURFACE_DESC         d3dsd;
-  D3DLOCKED_RECT          d3dlr;
-  D3DRASTER_STATUS        d3drs;
-  D3DCAPS9                d3dcaps;
-  LPDIRECT3DTEXTURE9      texture;
-  LPDIRECT3DSURFACE9      surface;
-  LPD3DXEFFECT            effect;
-  string                  shader_source_markup;
+  LPDIRECT3D9              lpd3d;
+  LPDIRECT3DDEVICE9        device;
+  LPDIRECT3DVERTEXBUFFER9  vertex_buffer;
+  LPDIRECT3DVERTEXBUFFER9* vertex_ptr;
+  D3DPRESENT_PARAMETERS    presentation;
+  D3DSURFACE_DESC          d3dsd;
+  D3DLOCKED_RECT           d3dlr;
+  D3DRASTER_STATUS         d3drs;
+  D3DCAPS9                 d3dcaps;
+  LPDIRECT3DTEXTURE9       texture;
+  LPDIRECT3DSURFACE9       surface;
+  LPD3DXEFFECT             effect;
+  string                   shader_source_markup;
 
   bool lost;
   unsigned iwidth, iheight;
@@ -170,11 +171,7 @@
     if(!device) return;
     if(lost && !recover()) return;
 
-    switch(settings.filter) { default:
-      case Video::FilterNearest: flags.filter = D3DTEXF_POINT;  break;
-      case Video::FilterLinear:  flags.filter = D3DTEXF_LINEAR; break;
-    }
-
+    flags.filter = (settings.filter == Video::FilterNearest ? D3DTEXF_POINT : D3DTEXF_LINEAR);
     device->SetSamplerState(0, D3DSAMP_MINFILTER, flags.filter);
     device->SetSamplerState(0, D3DSAMP_MAGFILTER, flags.filter);
   }
@@ -239,7 +236,7 @@
     }
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     if(lost && !recover()) return false;
 
     if(width != settings.width || height != settings.height) {
@@ -336,7 +333,7 @@
     if(device->Present(0, 0, 0, 0) == D3DERR_DEVICELOST) lost = true;
   }
 
-  void set_shader(const char *source) {
+  void set_shader(const char* source) {
     if(!caps.shader) return;
 
     if(effect) {
diff -ru higan_v092r07\ruby\video\directdraw.cpp higan_v092r08\ruby\video\directdraw.cpp
--- higan_v092r07\ruby\video\directdraw.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\directdraw.cpp	Thu May 02 05:48:03 2013
@@ -93,7 +93,7 @@
     raster->Blt(0, 0, 0, DDBLT_WAIT | DDBLT_COLORFILL, &fx);
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     if(width != settings.width || height != settings.height) {
       resize(settings.width = width, settings.height = height);
     }
@@ -123,7 +123,7 @@
     RECT rd, rs;
     SetRect(&rs, 0, 0, settings.width, settings.height);
 
-    POINT p = { 0, 0 };
+    POINT p = {0, 0};
     ClientToScreen(settings.handle, &p);
     GetClientRect(settings.handle, &rd);
     OffsetRect(&rd, p.x, p.y);
diff -ru higan_v092r07\ruby\video\gdi.cpp higan_v092r08\ruby\video\gdi.cpp
--- higan_v092r07\ruby\video\gdi.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\gdi.cpp	Thu May 02 05:48:03 2013
@@ -4,7 +4,7 @@
 
 class pVideoGDI {
 public:
-  uint32_t *buffer;
+  uint32_t* buffer;
   HBITMAP bitmap;
   HDC bitmapdc;
   BITMAPINFO bmi;
@@ -35,7 +35,7 @@
     return false;
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     settings.width  = width;
     settings.height = height;
 
diff -ru higan_v092r07\ruby\video\glx.cpp higan_v092r08\ruby\video\glx.cpp
--- higan_v092r07\ruby\video\glx.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\glx.cpp	Thu May 02 05:48:03 2013
@@ -5,7 +5,7 @@
 struct pVideoGLX : OpenGL {
   int (*glSwapInterval)(int);
 
-  Display *display;
+  Display* display;
   int screen;
   Window xwindow;
   Colormap colormap;
@@ -87,7 +87,7 @@
     return false;
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     OpenGL::size(width, height);
     return OpenGL::lock(data, pitch);
   }
@@ -140,10 +140,10 @@
     };
 
     int fbCount;
-    GLXFBConfig *fbConfig = glXChooseFBConfig(display, screen, attributeList, &fbCount);
+    GLXFBConfig* fbConfig = glXChooseFBConfig(display, screen, attributeList, &fbCount);
     if(fbCount == 0) return false;
 
-    XVisualInfo *vi = glXGetVisualFromFBConfig(display, fbConfig[0]);
+    XVisualInfo* vi = glXGetVisualFromFBConfig(display, fbConfig[0]);
 
     //Window settings.handle has already been realized, most likely with DefaultVisual.
     //GLX requires that the GL output window has the same Visual as the GLX context.
diff -ru higan_v092r07\ruby\video\opengl\main.hpp higan_v092r08\ruby\video\opengl\main.hpp
--- higan_v092r07\ruby\video\opengl\main.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\opengl\main.hpp	Thu May 02 05:48:03 2013
@@ -1,5 +1,5 @@
-void OpenGL::shader(const char *pathname) {
-  for(auto &program : programs) program.release();
+void OpenGL::shader(const char* pathname) {
+  for(auto& program : programs) program.release();
   programs.reset();
 
   format = GL_RGBA8;
@@ -10,7 +10,7 @@
 
   if(pathname) {
     auto document = Markup::Document(file::read({pathname, "manifest.bml"}));
-    for(auto &node : document.find("program")) {
+    for(auto& node : document.find("program")) {
       unsigned n = programs.size();
       programs(n).bind(this, node, pathname);
     }
@@ -19,13 +19,13 @@
   }
 }
 
-bool OpenGL::lock(uint32_t *&data, unsigned &pitch) {
+bool OpenGL::lock(uint32_t*& data, unsigned& pitch) {
   pitch = width * sizeof(uint32_t);
   return data = buffer;
 }
 
 void OpenGL::clear() {
-  for(auto &p : programs) {
+  for(auto& p : programs) {
     glUseProgram(p.program);
     glBindFramebuffer(GL_DRAW_FRAMEBUFFER, p.framebuffer);
     glClearColor(0, 0, 0, 1);
@@ -54,7 +54,7 @@
   unsigned sourceWidth = width, sourceHeight = height;
   history.prepend({texture, sourceWidth, sourceHeight, filter, wrap});
 
-  for(auto &p : programs) {
+  for(auto& p : programs) {
     unsigned targetWidth = p.absoluteWidth ? p.absoluteWidth : outputWidth;
     unsigned targetHeight = p.absoluteHeight ? p.absoluteHeight : outputHeight;
     if(p.relativeWidth) targetWidth = sourceWidth * p.relativeWidth;
@@ -73,7 +73,7 @@
   //glrUniform4f("outputActualSize", glrSize(outputWidth), glrSize(outputHeight), 1.0 / glrSize(outputWidth), 1.0 / glrSize(outputHeight));
 
     unsigned aid = 0;
-    for(auto &pixmap : history) {
+    for(auto& pixmap : history) {
       glrUniform1i({"source[", aid, "]"}, aid);
       glrUniform4f({"sourceSize[", aid, "]"}, pixmap.width, pixmap.height, 1.0 / pixmap.width, 1.0 / pixmap.height);
     //glrUniform4f({"sourceActualSize[", aid, "]"}, glrSize(pixmap.width), glrSize(pixmap.height), 1.0 / glrSize(pixmap.width), 1.0 / glrSize(pixmap.height));
@@ -83,7 +83,7 @@
     }
 
     unsigned bid = 0;
-    for(auto &pixmap : p.pixmaps) {
+    for(auto& pixmap : p.pixmaps) {
       glrUniform1i({"pixmap[", bid, "]"}, aid + bid);
       glrUniform4f({"pixmapSize[", bid, "]"}, pixmap.width, pixmap.height, 1.0 / pixmap.width, 1.0 / pixmap.height);
     //glrUniform4f({"pixmapActualSize[", bid, "]"}, glrSize(pixmap.width), glrSize(pixmap.height), 1.0 / glrSize(pixmap.width), 1.0 / glrSize(pixmap.height));
diff -ru higan_v092r07\ruby\video\opengl\opengl.hpp higan_v092r08\ruby\video\opengl\opengl.hpp
--- higan_v092r07\ruby\video\opengl\opengl.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\opengl\opengl.hpp	Thu May 02 05:48:03 2013
@@ -38,7 +38,7 @@
   GLuint vertex = 0;
   GLuint geometry = 0;
   GLuint fragment = 0;
-  uint32_t *buffer = nullptr;
+  uint32_t* buffer = nullptr;
 
   void allocate();
   void size(unsigned width, unsigned height);
@@ -56,7 +56,7 @@
   double relativeHeight = 0;
   vector<OpenGLTexture> pixmaps;
 
-  void bind(OpenGL *instance, const Markup::Node &node, const string &pathname);
+  void bind(OpenGL* instance, const Markup::Node& node, const string& pathname);
   void release();
 };
 
@@ -67,8 +67,8 @@
   unsigned outputWidth = 0;
   unsigned outputHeight = 0;
 
-  void shader(const char *pathname);
-  bool lock(uint32_t *&data, unsigned &pitch);
+  void shader(const char* pathname);
+  bool lock(uint32_t*& data, unsigned& pitch);
   void clear();
   void refresh();
   bool init();
diff -ru higan_v092r07\ruby\video\opengl\program.hpp higan_v092r08\ruby\video\opengl\program.hpp
--- higan_v092r07\ruby\video\opengl\program.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\opengl\program.hpp	Thu May 02 05:48:03 2013
@@ -1,4 +1,4 @@
-void OpenGLProgram::bind(OpenGL *instance, const Markup::Node &node, const string &pathname) {
+void OpenGLProgram::bind(OpenGL* instance, const Markup::Node& node, const string& pathname) {
   filter = glrFilter(node["filter"].text());
   wrap = glrWrap(node["wrap"].text());
   modulo = glrModulo(node["modulo"].integer());
@@ -37,7 +37,7 @@
     fragment = glrCreateShader(program, GL_FRAGMENT_SHADER, OpenGLFragmentShader);
   }
 
-  for(auto &leaf : node.find("pixmap")) {
+  for(auto& leaf : node.find("pixmap")) {
     nall::image image({pathname, leaf.text()});
     image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
     if(image.empty()) continue;
@@ -57,7 +57,7 @@
     if(leaf["wrap"].exists()) pixmaps(n).wrap = glrWrap(leaf["wrap"].text());
 
     unsigned w = glrSize(image.width), h = glrSize(image.height);
-    uint32_t *buffer = new uint32_t[w * h]();
+    uint32_t* buffer = new uint32_t[w * h]();
     glBindTexture(GL_TEXTURE_2D, texture);
     glTexImage2D(GL_TEXTURE_2D, 0, pixmaps(n).format, w, h, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, buffer);
     glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, image.width, image.height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, image.data);
@@ -70,7 +70,7 @@
 
 void OpenGLProgram::release() {
   OpenGLSurface::release();
-  for(auto &pixmap : pixmaps) glDeleteTextures(1, &pixmap.texture);
+  for(auto& pixmap : pixmaps) glDeleteTextures(1, &pixmap.texture);
   pixmaps.reset();
 
   width = 0;
diff -ru higan_v092r07\ruby\video\opengl\utility.hpp higan_v092r08\ruby\video\opengl\utility.hpp
--- higan_v092r07\ruby\video\opengl\utility.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\opengl\utility.hpp	Thu May 02 05:48:03 2013
@@ -3,7 +3,7 @@
 //return bit::round(size);  //return nearest power of two
 }
 
-static GLuint glrFormat(const string &format) {
+static GLuint glrFormat(const string& format) {
   if(format == "rgba8"  ) return GL_RGBA8;
   if(format == "rgb10a2") return GL_RGB10_A2;
   if(format == "rgba12" ) return GL_RGBA12;
@@ -13,13 +13,13 @@
   return GL_RGBA8;
 }
 
-static GLuint glrFilter(const string &filter) {
+static GLuint glrFilter(const string& filter) {
   if(filter == "nearest") return GL_NEAREST;
   if(filter == "linear" ) return GL_LINEAR;
   return GL_LINEAR;
 }
 
-static GLuint glrWrap(const string &wrap) {
+static GLuint glrWrap(const string& wrap) {
   if(wrap == "border") return GL_CLAMP_TO_BORDER;
   if(wrap == "edge"  ) return GL_CLAMP_TO_EDGE;
   if(wrap == "repeat") return GL_REPEAT;
@@ -37,17 +37,17 @@
   return program;
 }
 
-static void glrUniform1i(const string &name, GLint value) {
+static void glrUniform1i(const string& name, GLint value) {
   GLint location = glGetUniformLocation(glrProgram(), name);
   glUniform1i(location, value);
 }
 
-static void glrUniform4f(const string &name, GLfloat value0, GLfloat value1, GLfloat value2, GLfloat value3) {
+static void glrUniform4f(const string& name, GLfloat value0, GLfloat value1, GLfloat value2, GLfloat value3) {
   GLint location = glGetUniformLocation(glrProgram(), name);
   glUniform4f(location, value0, value1, value2, value3);
 }
 
-static void glrUniformMatrix4fv(const string &name, GLfloat *values) {
+static void glrUniformMatrix4fv(const string& name, GLfloat *values) {
   GLint location = glGetUniformLocation(glrProgram(), name);
   glUniformMatrix4fv(location, 1, GL_FALSE, values);
 }
@@ -59,7 +59,7 @@
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
 }
 
-static GLuint glrCreateShader(GLuint program, GLuint type, const char *source) {
+static GLuint glrCreateShader(GLuint program, GLuint type, const char* source) {
   GLuint shader = glCreateShader(type);
   glShaderSource(shader, 1, &source, 0);
   glCompileShader(shader);
diff -ru higan_v092r07\ruby\video\sdl.cpp higan_v092r08\ruby\video\sdl.cpp
--- higan_v092r07\ruby\video\sdl.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\sdl.cpp	Thu May 02 05:48:03 2013
@@ -7,10 +7,10 @@
 
 namespace ruby {
 
-class pVideoSDL {
-public:
-  Display *display;
-  SDL_Surface *screen, *buffer;
+struct pVideoSDL {
+  Display* display;
+  SDL_Surface* screen;
+  SDL_Surface* buffer;
   unsigned iwidth, iheight;
 
   struct {
@@ -52,7 +52,7 @@
     );
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     if(width != settings.width || height != settings.height) {
       resize(settings.width = width, settings.height = height);
     }
@@ -69,7 +69,7 @@
   void clear() {
     if(SDL_MUSTLOCK(buffer)) SDL_LockSurface(buffer);
     for(unsigned y = 0; y < iheight; y++) {
-      uint32_t *data = (uint32_t*)buffer->pixels + y * (buffer->pitch >> 2);
+      uint32_t* data = (uint32_t*)buffer->pixels + y * (buffer->pitch >> 2);
       for(unsigned x = 0; x < iwidth; x++) *data++ = 0xff000000;
     }
     if(SDL_MUSTLOCK(buffer)) SDL_UnlockSurface(buffer);
diff -ru higan_v092r07\ruby\video\wgl.cpp higan_v092r08\ruby\video\wgl.cpp
--- higan_v092r07\ruby\video\wgl.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\wgl.cpp	Thu May 02 05:48:03 2013
@@ -2,9 +2,8 @@
 
 namespace ruby {
 
-class pVideoWGL : public OpenGL {
-public:
-  BOOL (APIENTRY *glSwapInterval)(int);
+struct pVideoWGL : OpenGL {
+  BOOL (APIENTRY* glSwapInterval)(int);
 
   HDC display;
   HGLRC wglcontext;
@@ -66,7 +65,7 @@
     return false;
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     OpenGL::size(width, height);
     return OpenGL::lock(data, pitch);
   }
diff -ru higan_v092r07\ruby\video\xshm.cpp higan_v092r08\ruby\video\xshm.cpp
--- higan_v092r07\ruby\video\xshm.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\xshm.cpp	Thu May 02 05:48:03 2013
@@ -5,26 +5,26 @@
 
 struct pVideoXShm {
   struct {
-    Display *display;
+    Display* display;
     int screen;
     Visual *visual;
     int depth;
     Window window;
 
     XShmSegmentInfo shmInfo;
-    XImage *image;
-    uint32_t *buffer;
+    XImage* image;
+    uint32_t* buffer;
     unsigned width, height;
   } device;
 
   struct {
     uintptr_t handle;
 
-    uint32_t *buffer;
+    uint32_t* buffer;
     unsigned width, height;
   } settings;
 
-  bool cap(const string &name) {
+  bool cap(const string& name) {
     if(name == Video::Handle) return true;
     return false;
   }
@@ -41,7 +41,7 @@
     return false;
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     if(settings.buffer == nullptr || settings.width != width || settings.height != height) {
       if(settings.buffer) delete[] settings.buffer;
       settings.width = width, settings.height = height;
@@ -70,8 +70,8 @@
     float yRatio = (float)settings.height / (float)device.height;
     float yStep = 0;
     for(unsigned y = 0; y < device.height; y++) {
-      uint32_t *sp = settings.buffer + (unsigned)yStep * settings.width;
-      uint32_t *dp = device.buffer + y * device.width;
+      uint32_t* sp = settings.buffer + (unsigned)yStep * settings.width;
+      uint32_t* dp = device.buffer + y * device.width;
       yStep += yRatio;
       float xStep = 0;
       for(unsigned x = 0; x < device.width; x++) {
diff -ru higan_v092r07\ruby\video\xv.cpp higan_v092r08\ruby\video\xv.cpp
--- higan_v092r07\ruby\video\xv.cpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video\xv.cpp	Thu May 02 05:48:03 2013
@@ -8,10 +8,11 @@
 
 namespace ruby {
 
-class pVideoXv {
-public:
-  uint32_t *buffer;
-  uint8_t  *ytable, *utable, *vtable;
+struct pVideoXv {
+  uint32_t* buffer;
+  uint8_t* ytable;
+  uint8_t* utable;
+  uint8_t* vtable;
 
   enum XvFormat {
     XvFormatRGB32,
@@ -24,7 +25,7 @@
   };
 
   struct {
-    Display *display;
+    Display* display;
     GC gc;
     Window window;
     Colormap colormap;
@@ -34,7 +35,7 @@
     int depth;
     int visualid;
 
-    XvImage *image;
+    XvImage* image;
     XvFormat format;
     uint32_t fourcc;
 
@@ -71,7 +72,7 @@
     }
 
     if(name == Video::Synchronize) {
-      Display *display = XOpenDisplay(0);
+      Display* display = XOpenDisplay(0);
       Atom atom = XInternAtom(display, "XV_SYNC_TO_VBLANK", true);
       if(atom != None && device.port >= 0) {
         settings.synchronize = any_cast<bool>(value);
@@ -105,7 +106,7 @@
     buffer = new uint32_t[device.width * device.height];
   }
 
-  bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) {
+  bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) {
     if(width != settings.width || height != settings.height) {
       resize(settings.width = width, settings.height = height);
     }
@@ -169,7 +170,7 @@
 
     //find an appropriate Xv port
     device.port = -1;
-    XvAdaptorInfo *adaptor_info;
+    XvAdaptorInfo* adaptor_info;
     unsigned adaptor_count;
     XvQueryAdaptors(device.display, DefaultRootWindow(device.display), &adaptor_count, &adaptor_info);
     for(unsigned i = 0; i < adaptor_count; i++) {
@@ -230,7 +231,7 @@
     //find optimal rendering format
     device.format = XvFormatUnknown;
     signed format_count;
-    XvImageFormatValues *format = XvListImageFormats(device.display, device.port, &format_count);
+    XvImageFormatValues* format = XvListImageFormats(device.display, device.port, &format_count);
 
     if(device.format == XvFormatUnknown) for(signed i = 0; i < format_count; i++) {
       if(format[i].type == XvRGB && format[i].bits_per_pixel == 32) {
@@ -342,8 +343,8 @@
   }
 
   void render_rgb32(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint32_t *output = (uint32_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint32_t* output = (uint32_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       memcpy(output, input, width * 4);
@@ -353,8 +354,8 @@
   }
 
   void render_rgb24(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint8_t  *output = (uint8_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint8_t* output = (uint8_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       for(unsigned x = 0; x < width; x++) {
@@ -370,8 +371,8 @@
   }
 
   void render_rgb16(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint16_t *output = (uint16_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint16_t* output = (uint16_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       for(unsigned x = 0; x < width; x++) {
@@ -385,8 +386,8 @@
   }
 
   void render_rgb15(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint16_t *output = (uint16_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint16_t* output = (uint16_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       for(unsigned x = 0; x < width; x++) {
@@ -400,8 +401,8 @@
   }
 
   void render_yuy2(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint16_t *output = (uint16_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint16_t* output = (uint16_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       for(unsigned x = 0; x < width >> 1; x++) {
@@ -423,8 +424,8 @@
   }
 
   void render_uyvy(unsigned width, unsigned height) {
-    uint32_t *input  = (uint32_t*)buffer;
-    uint16_t *output = (uint16_t*)device.image->data;
+    uint32_t* input  = (uint32_t*)buffer;
+    uint16_t* output = (uint16_t*)device.image->data;
 
     for(unsigned y = 0; y < height; y++) {
       for(unsigned x = 0; x < width >> 1; x++) {
diff -ru higan_v092r07\ruby\video.hpp higan_v092r08\ruby\video.hpp
--- higan_v092r07\ruby\video.hpp	Fri Apr 12 16:38:14 2013
+++ higan_v092r08\ruby\video.hpp	Thu May 02 05:48:03 2013
@@ -1,9 +1,9 @@
 struct Video {
-  static const char *Handle;
-  static const char *Synchronize;
-  static const char *Depth;
-  static const char *Filter;
-  static const char *Shader;
+  static const char* Handle;
+  static const char* Synchronize;
+  static const char* Depth;
+  static const char* Filter;
+  static const char* Shader;
 
   static const unsigned FilterNearest;
   static const unsigned FilterLinear;
@@ -12,7 +12,7 @@
   virtual nall::any get(const nall::string& name) { return false; }
   virtual bool set(const nall::string& name, const nall::any& value) { return false; }
 
-  virtual bool lock(uint32_t *&data, unsigned &pitch, unsigned width, unsigned height) { return false; }
+  virtual bool lock(uint32_t*& data, unsigned& pitch, unsigned width, unsigned height) { return false; }
   virtual void unlock() {}
 
   virtual void clear() {}
diff -ru higan_v092r07\sfc\interface\interface.cpp higan_v092r08\sfc\interface\interface.cpp
--- higan_v092r07\sfc\interface\interface.cpp	Mon Jan 21 02:12:30 2013
+++ higan_v092r08\sfc\interface\interface.cpp	Thu May 02 06:00:27 2013
@@ -2,7 +2,7 @@
 
 namespace SuperFamicom {
 
-Interface *interface = nullptr;
+Interface* interface = nullptr;
 
 string Interface::title() {
   return cartridge.title();
@@ -103,12 +103,12 @@
 }
 
 void Interface::save() {
-  for(auto &memory : cartridge.memory) {
+  for(auto& memory : cartridge.memory) {
     saveRequest(memory.id, memory.name);
   }
 }
 
-void Interface::load(unsigned id, const stream &stream) {
+void Interface::load(unsigned id, const stream& stream) {
   if(id == ID::IPLROM) {
     stream.read(smp.iplrom, min(64u, stream.size()));
   }
@@ -219,7 +219,7 @@
   if(id == ID::SufamiTurboSlotBRAM) sufamiturboB.ram.read(stream);
 }
 
-void Interface::save(unsigned id, const stream &stream) {
+void Interface::save(unsigned id, const stream& stream) {
   if(id == ID::RAM) stream.write(cartridge.ram.data(), cartridge.ram.size());
   if(id == ID::EventRAM) stream.write(event.ram.data(), event.ram.size());
   if(id == ID::SA1IRAM) stream.write(sa1.iram.data(), sa1.iram.size());
@@ -305,17 +305,17 @@
   return system.serialize();
 }
 
-bool Interface::unserialize(serializer &s) {
+bool Interface::unserialize(serializer& s) {
   return system.unserialize(s);
 }
 
-void Interface::cheatSet(const lstring &list) {
+void Interface::cheatSet(const lstring& list) {
   //Super Game Boy
   if(cartridge.has_gb_slot()) {
     GameBoy::cheat.reset();
-    for(auto &code : list) {
+    for(auto& code : list) {
       lstring codelist = code.split("+");
-      for(auto &part : codelist) {
+      for(auto& part : codelist) {
         unsigned addr, data, comp;
         part.trim();
         if(GameBoy::Cheat::decode(part, addr, data, comp)) GameBoy::cheat.append({addr, data, comp});
@@ -327,9 +327,9 @@
 
   //Super Famicom, Broadcast Satellaview, Sufami Turbo
   cheat.reset();
-  for(auto &code : list) {
+  for(auto& code : list) {
     lstring codelist = code.split("+");
-    for(auto &part : codelist) {
+    for(auto& part : codelist) {
       unsigned addr, data;
       part.trim();
       if(Cheat::decode(part, addr, data)) cheat.append({addr, data});
@@ -491,8 +491,8 @@
   port.append({0, "Port 1"});
   port.append({1, "Port 2"});
 
-  for(auto &device : this->device) {
-    for(auto &port : this->port) {
+  for(auto& device : this->device) {
+    for(auto& port : this->port) {
       if(device.portmask & (1 << port.id)) {
         port.device.append(device);
       }
diff -ru higan_v092r07\sfc\interface\interface.hpp higan_v092r08\sfc\interface\interface.hpp
--- higan_v092r07\sfc\interface\interface.hpp	Mon Jan 21 01:57:20 2013
+++ higan_v092r08\sfc\interface\interface.hpp	Thu May 02 05:58:28 2013
@@ -98,8 +98,8 @@
   unsigned group(unsigned id);
   void load(unsigned id);
   void save();
-  void load(unsigned id, const stream &stream);
-  void save(unsigned id, const stream &stream);
+  void load(unsigned id, const stream& stream);
+  void save(unsigned id, const stream& stream);
   void unload();
 
   void connect(unsigned port, unsigned device);
@@ -127,7 +127,7 @@
   vector<Device> device;
 };
 
-extern Interface *interface;
+extern Interface* interface;
 
 #ifndef SFC_HPP
 }
diff -ru higan_v092r07\target-ethos\bootstrap.cpp higan_v092r08\target-ethos\bootstrap.cpp
--- higan_v092r07\target-ethos\bootstrap.cpp	Fri Mar 15 06:40:55 2013
+++ higan_v092r08\target-ethos\bootstrap.cpp	Thu May 02 06:04:05 2013
@@ -13,5 +13,5 @@
   emulator.append(new GameBoyAdvance::Interface);
 //emulator.append(new NintendoDS::Interface);
 
-  for(auto &system : emulator) system->bind = interface;
+  for(auto& system : emulator) system->bind = interface;
 }
diff -ru higan_v092r07\target-ethos\configuration\configuration.cpp higan_v092r08\target-ethos\configuration\configuration.cpp
--- higan_v092r07\target-ethos\configuration\configuration.cpp	Fri Apr 12 16:46:46 2013
+++ higan_v092r08\target-ethos\configuration\configuration.cpp	Thu May 02 06:04:31 2013
@@ -1,5 +1,5 @@
 #include "../ethos.hpp"
-ConfigurationSettings *config = nullptr;
+ConfigurationSettings* config = nullptr;
 
 ConfigurationSettings::ConfigurationSettings() {
   video.append(video.driver = ruby::video.default_driver(), "Driver");
diff -ru higan_v092r07\target-ethos\configuration\configuration.hpp higan_v092r08\target-ethos\configuration\configuration.hpp
--- higan_v092r07\target-ethos\configuration\configuration.hpp	Fri Apr 12 16:51:59 2013
+++ higan_v092r08\target-ethos\configuration\configuration.hpp	Thu May 02 06:04:23 2013
@@ -50,4 +50,4 @@
   ConfigurationSettings();
 };
 
-extern ConfigurationSettings *config;
+extern ConfigurationSettings* config;
diff -ru higan_v092r07\target-ethos\ethos.cpp higan_v092r08\target-ethos\ethos.cpp
--- higan_v092r07\target-ethos\ethos.cpp	Fri Apr 12 16:47:23 2013
+++ higan_v092r08\target-ethos\ethos.cpp	Thu May 02 06:03:54 2013
@@ -2,7 +2,7 @@
 #include "bootstrap.cpp"
 #include "resource/resource.cpp"
 
-Program *program = nullptr;
+Program* program = nullptr;
 DSP dspaudio;
 
 Emulator::Interface& system() {
@@ -14,7 +14,7 @@
   return config->input.focus.allow || presentation->focused();
 }
 
-string Program::path(const string &name) {
+string Program::path(const string& name) {
   string path = {basepath, name};
   if(file::exists(path) || directory::exists(path)) return path;
   path = {userpath, name};
@@ -38,7 +38,7 @@
   system().run();
 }
 
-Program::Program(int argc, char **argv) {
+Program::Program(int argc, char** argv) {
   ananke.open("ananke");
 
   program = this;
@@ -127,7 +127,7 @@
   ananke.close();
 }
 
-int main(int argc, char **argv) {
+int main(int argc, char** argv) {
   #if defined(PLATFORM_WINDOWS)
   utf8_args(argc, argv);
   #endif
diff -ru higan_v092r07\target-ethos\ethos.hpp higan_v092r08\target-ethos\ethos.hpp
--- higan_v092r07\target-ethos\ethos.hpp	Sat Apr 06 22:02:57 2013
+++ higan_v092r08\target-ethos\ethos.hpp	Thu May 02 06:03:16 2013
@@ -33,7 +33,7 @@
 
 struct Program {
   vector<Emulator::Interface*> emulator;
-  Emulator::Interface *active = nullptr;
+  Emulator::Interface* active = nullptr;
   library ananke;
 
   bool pause;
@@ -53,8 +53,8 @@
   string path(const string &filename);
   void main();
   void bootstrap();
-  Program(int argc, char **argv);
+  Program(int argc, char** argv);
 };
 
-extern Program *program;
+extern Program* program;
 extern DSP dspaudio;
diff -ru higan_v092r07\target-ethos\general\browser.cpp higan_v092r08\target-ethos\general\browser.cpp
--- higan_v092r07\target-ethos\general\browser.cpp	Fri Apr 12 16:50:11 2013
+++ higan_v092r08\target-ethos\general\browser.cpp	Thu May 02 06:06:20 2013
@@ -1,4 +1,4 @@
-Browser *browser = nullptr;
+Browser* browser = nullptr;
 
 Browser::Browser() {
   bootstrap();
@@ -52,7 +52,7 @@
 void Browser::synchronize() {
   openButton.setEnabled(fileList.selected());
   if(fileList.selected()) {
-    for(auto &folder : folderList) {
+    for(auto& folder : folderList) {
       if(folder.extension == extension) {
         folder.selection = fileList.selection();
       }
@@ -65,10 +65,10 @@
 }
 
 void Browser::bootstrap() {
-  for(auto &emulator : program->emulator) {
-    for(auto &media : emulator->media) {
+  for(auto& emulator : program->emulator) {
+    for(auto& media : emulator->media) {
       bool found = false;
-      for(auto &folder : folderList) {
+      for(auto& folder : folderList) {
         if(folder.extension == media.type) {
           found = true;
           break;
@@ -84,7 +84,7 @@
     }
   }
 
-  for(auto &folder : folderList) {
+  for(auto& folder : folderList) {
     Configuration::Node node;
     node.append(folder.path, "Path");
     node.append(folder.selection, "Selection");
@@ -95,12 +95,12 @@
   config.save(program->path("paths.bml"));
 }
 
-string Browser::select(const string &title, const string &extension) {
+string Browser::select(const string& title, const string& extension) {
   this->extension = extension;
 
   string path;
   unsigned selection = 0;
-  for(auto &folder : folderList) {
+  for(auto& folder : folderList) {
     if(folder.extension == extension) {
       path = folder.path;
       selection = folder.selection;
@@ -122,9 +122,9 @@
   return outputFilename;
 }
 
-void Browser::setPath(const string &path, unsigned selection) {
+void Browser::setPath(const string& path, unsigned selection) {
   //save path for next browser selection
-  for(auto &folder : folderList) {
+  for(auto& folder : folderList) {
     if(folder.extension == extension) folder.path = path;
   }
 
@@ -136,7 +136,7 @@
 
   lstring contents = directory::ifolders(path);
 
-  for(auto &filename : contents) {
+  for(auto& filename : contents) {
     string suffix = {".", this->extension, "/"};
     if(filename.endswith("/") && !filename.endswith(suffix)) {
       string name = filename;
@@ -147,7 +147,7 @@
     }
   }
 
-  for(auto &filename : contents) {
+  for(auto& filename : contents) {
     string suffix = {".", this->extension, "/"};
     if(filename.endswith(suffix)) {
       string name = filename;
diff -ru higan_v092r07\target-ethos\general\browser.hpp higan_v092r08\target-ethos\general\browser.hpp
--- higan_v092r07\target-ethos\general\browser.hpp	Fri Apr 12 16:48:58 2013
+++ higan_v092r08\target-ethos\general\browser.hpp	Thu May 02 06:05:09 2013
@@ -9,7 +9,7 @@
   Label filterLabel;
   Button openButton;
 
-  string select(const string &title, const string &extension);
+  string select(const string& title, const string& extension);
   void saveConfiguration();
   void synchronize();
   void bootstrap();
@@ -30,8 +30,8 @@
   string path;
   lstring filenameList;
 
-  void setPath(const string &path, unsigned selection = 0);
+  void setPath(const string& path, unsigned selection = 0);
   void fileListActivate();
 };
 
-extern Browser *browser;
+extern Browser* browser;
diff -ru higan_v092r07\target-ethos\general\dip-switches.cpp higan_v092r08\target-ethos\general\dip-switches.cpp
--- higan_v092r07\target-ethos\general\dip-switches.cpp	Fri Mar 15 06:48:56 2013
+++ higan_v092r08\target-ethos\general\dip-switches.cpp	Thu May 02 06:07:04 2013
@@ -1,4 +1,4 @@
-DipSwitches *dipSwitches = nullptr;
+DipSwitches* dipSwitches = nullptr;
 
 DipSwitch::DipSwitch() {
   append(name, {100, 0}, 5);
@@ -11,7 +11,7 @@
   accept.setText("Accept");
 
   append(layout);
-  for(auto &dipItem : dip) layout.append(dipItem, {~0, 0}, 5);
+  for(auto& dipItem : dip) layout.append(dipItem, {~0, 0}, 5);
   layout.append(controlLayout, {~0, 0});
     controlLayout.append(spacer, {~0, 0});
     controlLayout.append(accept, {80, 0});
@@ -24,8 +24,8 @@
   };
 }
 
-unsigned DipSwitches::run(const Markup::Node &node) {
-  for(auto &dipItem : dip) {
+unsigned DipSwitches::run(const Markup::Node& node) {
+  for(auto& dipItem : dip) {
     dipItem.name.setEnabled(false);
     dipItem.name.setText("(empty)");
     dipItem.value.setEnabled(false);
@@ -34,12 +34,12 @@
   }
 
   unsigned index = 0;
-  for(auto &setting : node) {
+  for(auto& setting : node) {
     if(setting.name != "setting") continue;
     dip[index].name.setEnabled();
     dip[index].name.setText(setting["name"].data);
     dip[index].value.setEnabled();
-    for(auto &option : setting) {
+    for(auto& option : setting) {
       if(option.name != "option") continue;
       dip[index].value.append(option["name"].data);
       dip[index].values.append(fixedpoint::parse(option["value"].data));
@@ -55,7 +55,7 @@
   setModal();
 
   unsigned result = 0;
-  for(auto &dipItem : dip) {
+  for(auto& dipItem : dip) {
     if(dipItem.value.enabled() == false) continue;
     result |= dipItem.values[dipItem.value.selection()];
   }
diff -ru higan_v092r07\target-ethos\general\dip-switches.hpp higan_v092r08\target-ethos\general\dip-switches.hpp
--- higan_v092r07\target-ethos\general\dip-switches.hpp	Fri Mar 15 07:18:43 2013
+++ higan_v092r08\target-ethos\general\dip-switches.hpp	Thu May 02 06:06:33 2013
@@ -15,8 +15,8 @@
     Widget spacer;
     Button accept;
 
-  unsigned run(const Markup::Node &node);
+  unsigned run(const Markup::Node& node);
   DipSwitches();
 };
 
-extern DipSwitches *dipSwitches;
+extern DipSwitches* dipSwitches;
diff -ru higan_v092r07\target-ethos\general\presentation.cpp higan_v092r08\target-ethos\general\presentation.cpp
--- higan_v092r07\target-ethos\general\presentation.cpp	Fri Apr 12 16:53:52 2013
+++ higan_v092r08\target-ethos\general\presentation.cpp	Thu May 02 06:10:36 2013
@@ -1,8 +1,8 @@
-Presentation *presentation = nullptr;
+Presentation* presentation = nullptr;
 
 void Presentation::synchronize() {
-  for(auto &emulator : emulatorList) emulator->menu.setVisible(false);
-  for(auto &emulator : emulatorList) {
+  for(auto& emulator : emulatorList) emulator->menu.setVisible(false);
+  for(auto& emulator : emulatorList) {
     if(emulator->interface == program->active) {
       active = emulator;
       emulator->menu.setVisible(true);
@@ -12,7 +12,7 @@
   shaderNone.setChecked();
   if(config->video.shader == "None") shaderNone.setChecked();
   if(config->video.shader == "Blur") shaderBlur.setChecked();
-  for(auto &shader : shaderList) {
+  for(auto& shader : shaderList) {
     string name = notdir(config->video.shader.split<1>(".shader/")(0));
     if(name == shader->text()) shader->setChecked();
   }
@@ -42,11 +42,11 @@
   }
 }
 
-void Presentation::setSystemName(const string &name) {
+void Presentation::setSystemName(const string& name) {
   if(active) active->menu.setText(name);
 }
 
-Presentation::Presentation() : active(nullptr) {
+Presentation::Presentation() {
   bootstrap();
   loadShaders();
   setGeometry({256, 256, 720, 480});
@@ -85,16 +85,16 @@
     synchronizeTime.setText("Synchronize Time");
 
   append(loadMenu);
-    for(auto &item : loadListSystem) loadMenu.append(*item);
+    for(auto& item : loadListSystem) loadMenu.append(*item);
     if(program->ananke.open()) loadMenu.append(loadSeparator, loadImport);
-  for(auto &systemItem : emulatorList) append(systemItem->menu);
+  for(auto& systemItem : emulatorList) append(systemItem->menu);
   append(settingsMenu);
     settingsMenu.append(videoMenu);
       videoMenu.append(centerVideo, scaleVideo, stretchVideo, *new Separator, aspectCorrection, maskOverscan);
     settingsMenu.append(shaderMenu);
       shaderMenu.append(shaderNone, shaderBlur);
       if(shaderList.size() > 0) shaderMenu.append(*new Separator);
-      for(auto &shader : shaderList) shaderMenu.append(*shader);
+      for(auto& shader : shaderList) shaderMenu.append(*shader);
     settingsMenu.append(*new Separator);
     settingsMenu.append(synchronizeVideo, synchronizeAudio, muteAudio);
     if(Intrinsics::platform() != Intrinsics::Platform::OSX) {
@@ -156,13 +156,13 @@
 }
 
 void Presentation::bootstrap() {
-  for(auto &emulator : program->emulator) {
+  for(auto& emulator : program->emulator) {
     auto iEmulator = new Emulator;
     iEmulator->interface = emulator;
 
-    for(auto &media : emulator->media) {
+    for(auto& media : emulator->media) {
       if(media.bootable == false) continue;
-      Item *item = new Item;
+      auto item = new Item;
       item->onActivate = [=, &media] {
         utility->loadMedia(iEmulator->interface, media);
       };
@@ -175,12 +175,12 @@
     iEmulator->reset.setText("Reset");
     iEmulator->unload.setText("Unload");
 
-    for(auto &port : emulator->port) {
+    for(auto& port : emulator->port) {
       auto iPort = new Emulator::Port;
       iPort->menu.setText(port.name);
       iEmulator->port.append(iPort);
 
-      for(auto &device : port.device) {
+      for(auto& device : port.device) {
         auto iDevice = new RadioItem;
         iDevice->setText(device.name);
         iDevice->onActivate = [=] { utility->connect(port.id, device.id); };
@@ -196,11 +196,11 @@
     iEmulator->menu.append(iEmulator->reset);
     iEmulator->menu.append(*new Separator);
     unsigned visiblePorts = 0;
-    for(auto &iPort : iEmulator->port) {
+    for(auto& iPort : iEmulator->port) {
       iEmulator->menu.append(iPort->menu);
       if(iPort->device.size() <= 1) iPort->menu.setVisible(false);
       else visiblePorts++;
-      for(auto &iDevice : iPort->device) {
+      for(auto& iDevice : iPort->device) {
         iPort->menu.append(*iDevice);
       }
     }
@@ -221,7 +221,7 @@
   if(config->video.driver == "OpenGL") {
     string pathname = program->path("Video Shaders/");
     lstring shaders = directory::folders(pathname, "*.shader");
-    for(auto &name : shaders) {
+    for(auto& name : shaders) {
       auto shader = new RadioItem;
       shader->setText(name.split<1>(".shader/")(0));
       shader->onActivate = [=] {
@@ -232,9 +232,9 @@
     }
   }
 
-  nall::group<RadioItem&> group;
+  nall::group<RadioItem> group;
   group.append(shaderNone);
   group.append(shaderBlur);
-  for(auto &shader : shaderList) group.append(*shader);
+  for(auto& shader : shaderList) group.append(*shader);
   RadioItem::group(group);
 }
diff -ru higan_v092r07\target-ethos\general\presentation.hpp higan_v092r08\target-ethos\general\presentation.hpp
--- higan_v092r07\target-ethos\general\presentation.hpp	Fri Apr 12 16:40:14 2013
+++ higan_v092r08\target-ethos\general\presentation.hpp	Thu May 02 06:08:23 2013
@@ -3,7 +3,7 @@
   Viewport viewport;
 
   struct Emulator {
-    ::Emulator::Interface *interface;
+    ::Emulator::Interface* interface;
 
     Menu menu;
       Item power;
@@ -12,13 +12,14 @@
       Separator controllerSeparator;
       struct Port {
         Menu menu;
-        nall::group<RadioItem&> group;
+        nall::group<RadioItem> group;
         vector<RadioItem*> device;
       };
       vector<Port*> port;
     function<void (string)> callback;
   };
   vector<Emulator*> emulatorList;
+  Emulator* active = nullptr;
 
   Menu loadMenu;
     vector<Item*> loadListSystem;
@@ -51,12 +52,10 @@
     Item synchronizeTime;
 
   void synchronize();
-  void setSystemName(const string &name);
+  void setSystemName(const string& name);
   void loadShaders();
   void bootstrap();
   Presentation();
-
-  Emulator *active;
 };
 
-extern Presentation *presentation;
+extern Presentation* presentation;
diff -ru higan_v092r07\target-ethos\input\hotkeys.cpp higan_v092r08\target-ethos\input\hotkeys.cpp
--- higan_v092r07\target-ethos\input\hotkeys.cpp	Fri Apr 12 16:59:36 2013
+++ higan_v092r08\target-ethos\input\hotkeys.cpp	Thu May 02 06:13:18 2013
@@ -142,14 +142,14 @@
   }
 
   Configuration::Node node;
-  for(auto &hotkey : hotkeyMap) {
+  for(auto& hotkey : hotkeyMap) {
     node.append(hotkey->mapping, string{hotkey->name}.replace(" ", ""));
   }
   config.append(node, "Hotkey");
 }
 
 void InputManager::pollHotkeys() {
-  for(auto &hotkey : hotkeyMap) {
+  for(auto& hotkey : hotkeyMap) {
     bool state = hotkey->poll();
     if(hotkey->state == 0 && state == 1) if(hotkey->press) hotkey->press();
     if(hotkey->state == 1 && state == 0) if(hotkey->release) hotkey->release();
diff -ru higan_v092r07\target-ethos\input\input.cpp higan_v092r08\target-ethos\input\input.cpp
--- higan_v092r07\target-ethos\input\input.cpp	Fri Apr 12 17:03:11 2013
+++ higan_v092r08\target-ethos\input\input.cpp	Thu May 02 06:12:54 2013
@@ -1,12 +1,12 @@
 #include "../ethos.hpp"
 #include "hotkeys.cpp"
-InputManager *inputManager = nullptr;
+InputManager* inputManager = nullptr;
 
 void AbstractInput::bind() {
   inputList.reset();
   lstring list = mapping.split(",");
 
-  for(auto &mapping : list) {
+  for(auto& mapping : list) {
     Input::Type type;
          if(mapping.endswith(".Up")) type = Input::Type::HatUp;
     else if(mapping.endswith(".Down")) type = Input::Type::HatDown;
@@ -27,7 +27,7 @@
   }
 }
 
-bool AbstractInput::append(const string &encode) {
+bool AbstractInput::append(const string& encode) {
   if(mapping.position(encode)) return true;  //mapping already bound
   if(mapping.empty() || mapping == "None") mapping = encode;  //remove "None"
   else mapping.append(",", encode);  //add to existing mapping list
@@ -81,7 +81,7 @@
   if(program->focused() == false) return 0;
   bool result = logic;
 
-  for(auto &item : inputList) {
+  for(auto& item : inputList) {
     int16_t value = inputManager->poll(item.scancode);
     bool output = logic;
     switch(item.type) {
@@ -125,7 +125,7 @@
   if(program->focused() == false) return 0;
   int16_t result = 0;
 
-  for(auto &item : inputList) {
+  for(auto& item : inputList) {
     int16_t value = inputManager->poll(item.scancode);
     switch(item.type) {
     case Input::Type::MouseAxis: value = input.acquired() ? value : 0; break;
@@ -195,7 +195,7 @@
     position.y = max(-32767, min(+32767, py));
   }
 
-  for(auto &item : inputList) {
+  for(auto& item : inputList) {
     if(item.scancode == mouse(0)[Mouse::Xaxis]) {
       result = position.x;
     }
@@ -218,8 +218,8 @@
 //
 
 void InputManager::bind() {
-  for(auto &input : inputMap) input->bind();
-  for(auto &input : hotkeyMap) input->bind();
+  for(auto& input : inputMap) input->bind();
+  for(auto& input : hotkeyMap) input->bind();
 }
 
 void InputManager::poll() {
@@ -256,19 +256,19 @@
 
 void InputManager::bootstrap() {
   unsigned guid = 0;
-  for(auto &emulator : program->emulator) {
+  for(auto& emulator : program->emulator) {
     Configuration::Node emulatorNode;
 
-    for(auto &port : emulator->port) {
+    for(auto& port : emulator->port) {
       Configuration::Node portNode;
 
-      for(auto &device : port.device) {
+      for(auto& device : port.device) {
         Configuration::Node deviceNode;
 
-        for(auto &number : device.order) {
-          auto &input = device.input[number];
+        for(auto& number : device.order) {
+          auto& input = device.input[number];
 
-          AbstractInput *abstract = nullptr;
+          AbstractInput* abstract = nullptr;
           if(input.type == 0) abstract = new DigitalInput;
           if(input.type == 1) abstract = new RelativeInput;
           if(input.type == 2) abstract = new AbsoluteInput;
diff -ru higan_v092r07\target-ethos\input\input.hpp higan_v092r08\target-ethos\input\input.hpp
--- higan_v092r07\target-ethos\input\input.hpp	Fri Apr 12 16:50:42 2013
+++ higan_v092r08\target-ethos\input\input.hpp	Thu May 02 06:11:09 2013
@@ -11,7 +11,7 @@
   vector<Input> inputList;
 
   void bind();
-  bool append(const string &mapping);
+  bool append(const string& mapping);
   virtual bool bind(unsigned scancode, int16_t value) = 0;
   virtual int16_t poll() = 0;
   AbstractInput();
@@ -62,4 +62,4 @@
   Configuration::Document config;
 };
 
-extern InputManager *inputManager;
+extern InputManager* inputManager;
diff -ru higan_v092r07\target-ethos\interface\interface.cpp higan_v092r08\target-ethos\interface\interface.cpp
--- higan_v092r07\target-ethos\interface\interface.cpp	Fri Apr 12 16:52:28 2013
+++ higan_v092r08\target-ethos\interface\interface.cpp	Thu May 02 06:14:40 2013
@@ -1,15 +1,15 @@
 #include "../ethos.hpp"
-Interface *interface = nullptr;
+Interface* interface = nullptr;
 
-void Interface::loadRequest(unsigned id, const string &name, const string &type) {
+void Interface::loadRequest(unsigned id, const string &name, const string& type) {
   return utility->loadRequest(id, name, type);
 }
 
-void Interface::loadRequest(unsigned id, const string &path) {
+void Interface::loadRequest(unsigned id, const string& path) {
   return utility->loadRequest(id, path);
 }
 
-void Interface::saveRequest(unsigned id, const string &path) {
+void Interface::saveRequest(unsigned id, const string& path) {
   return utility->saveRequest(id, path);
 }
 
@@ -51,8 +51,8 @@
   return 0u;
 }
 
-void Interface::videoRefresh(const uint32_t *data, unsigned pitch, unsigned width, unsigned height) {
-  uint32_t *output;
+void Interface::videoRefresh(const uint32_t* data, unsigned pitch, unsigned width, unsigned height) {
+  uint32_t* output;
   unsigned outputPitch;
 
   if(video.lock(output, outputPitch, width, height)) {
@@ -107,7 +107,7 @@
   return inputManager->inputMap[guid]->poll();
 }
 
-unsigned Interface::dipSettings(const Markup::Node &node) {
+unsigned Interface::dipSettings(const Markup::Node& node) {
   return dipSwitches->run(node);
 }
 
@@ -123,6 +123,6 @@
   };
 }
 
-void Interface::notify(const string &text) {
+void Interface::notify(const string& text) {
   MessageWindow().setParent(*presentation).setText(text).information();
 }
diff -ru higan_v092r07\target-ethos\interface\interface.hpp higan_v092r08\target-ethos\interface\interface.hpp
--- higan_v092r07\target-ethos\interface\interface.hpp	Mon Oct 29 18:03:55 2012
+++ higan_v092r08\target-ethos\interface\interface.hpp	Thu May 02 06:13:54 2013
@@ -1,15 +1,15 @@
 struct Interface : Emulator::Interface::Bind {
-  void loadRequest(unsigned id, const string &name, const string &type);
-  void loadRequest(unsigned id, const string &path);
-  void saveRequest(unsigned id, const string &path);
+  void loadRequest(unsigned id, const string& name, const string& type);
+  void loadRequest(unsigned id, const string& path);
+  void saveRequest(unsigned id, const string& path);
   uint32_t videoColor(unsigned source, uint16_t red, uint16_t green, uint16_t blue);
-  void videoRefresh(const uint32_t *data, unsigned pitch, unsigned width, unsigned height);
+  void videoRefresh(const uint32_t* data, unsigned pitch, unsigned width, unsigned height);
   void audioSample(int16_t lsample, int16_t rsample);
   int16_t inputPoll(unsigned port, unsigned device, unsigned input);
-  unsigned dipSettings(const Markup::Node &node);
+  unsigned dipSettings(const Markup::Node& node);
   string path(unsigned group);
   string server();
-  void notify(const string &text);
+  void notify(const string& text);
 };
 
-extern Interface *interface;
+extern Interface* interface;
diff -ru higan_v092r07\target-ethos\settings\advanced.cpp higan_v092r08\target-ethos\settings\advanced.cpp
--- higan_v092r07\target-ethos\settings\advanced.cpp	Fri Apr 12 17:15:34 2013
+++ higan_v092r08\target-ethos\settings\advanced.cpp	Thu May 02 06:15:23 2013
@@ -1,4 +1,4 @@
-AdvancedSettings *advancedSettings = nullptr;
+AdvancedSettings* advancedSettings = nullptr;
 
 AdvancedSettings::AdvancedSettings() {
   driverTitle.setFont(program->titleFont);
diff -ru higan_v092r07\target-ethos\settings\advanced.hpp higan_v092r08\target-ethos\settings\advanced.hpp
--- higan_v092r07\target-ethos\settings\advanced.hpp	Fri Mar 15 07:19:02 2013
+++ higan_v092r08\target-ethos\settings\advanced.hpp	Thu May 02 06:15:09 2013
@@ -20,4 +20,4 @@
   AdvancedSettings();
 };
 
-extern AdvancedSettings *advancedSettings;
+extern AdvancedSettings* advancedSettings;
diff -ru higan_v092r07\target-ethos\settings\audio.cpp higan_v092r08\target-ethos\settings\audio.cpp
--- higan_v092r07\target-ethos\settings\audio.cpp	Fri Mar 15 07:12:57 2013
+++ higan_v092r08\target-ethos\settings\audio.cpp	Thu May 02 06:15:46 2013
@@ -1,4 +1,4 @@
-AudioSettings *audioSettings = nullptr;
+AudioSettings* audioSettings = nullptr;
 
 AudioSlider::AudioSlider() {
   append(name, {75, 0});
diff -ru higan_v092r07\target-ethos\settings\audio.hpp higan_v092r08\target-ethos\settings\audio.hpp
--- higan_v092r07\target-ethos\settings\audio.hpp	Fri Mar 15 07:20:18 2013
+++ higan_v092r08\target-ethos\settings\audio.hpp	Thu May 02 06:15:34 2013
@@ -21,4 +21,4 @@
   AudioSettings();
 };
 
-extern AudioSettings *audioSettings;
+extern AudioSettings* audioSettings;
diff -ru higan_v092r07\target-ethos\settings\hotkey.cpp higan_v092r08\target-ethos\settings\hotkey.cpp
--- higan_v092r07\target-ethos\settings\hotkey.cpp	Fri Mar 15 07:15:02 2013
+++ higan_v092r08\target-ethos\settings\hotkey.cpp	Thu May 02 06:16:26 2013
@@ -1,6 +1,6 @@
-HotkeySettings *hotkeySettings = nullptr;
+HotkeySettings* hotkeySettings = nullptr;
 
-HotkeySettings::HotkeySettings() : activeInput(nullptr) {
+HotkeySettings::HotkeySettings() {
   title.setFont(program->titleFont);
   title.setText("Hotkey Bindings");
 
@@ -18,7 +18,7 @@
   inputList.onActivate = {&HotkeySettings::assignInput, this};
   eraseButton.onActivate = {&HotkeySettings::eraseInput, this};
 
-  for(auto &hotkey : inputManager->hotkeyMap) inputList.append("", "");
+  for(auto& hotkey : inputManager->hotkeyMap) inputList.append("", "");
   refresh();
 }
 
@@ -28,7 +28,7 @@
 
 void HotkeySettings::refresh() {
   unsigned index = 0;
-  for(auto &hotkey : inputManager->hotkeyMap) {
+  for(auto& hotkey : inputManager->hotkeyMap) {
     string mapping = hotkey->mapping;
     mapping.replace("KB0::", "");
     mapping.replace("MS0::", "Mouse::");
diff -ru higan_v092r07\target-ethos\settings\hotkey.hpp higan_v092r08\target-ethos\settings\hotkey.hpp
--- higan_v092r07\target-ethos\settings\hotkey.hpp	Sat May 05 19:26:37 2012
+++ higan_v092r08\target-ethos\settings\hotkey.hpp	Thu May 02 06:15:59 2013
@@ -13,7 +13,7 @@
   HotkeySettings();
 
 private:
-  HotkeyInput *activeInput;
+  HotkeyInput* activeInput = nullptr;
 };
 
-extern HotkeySettings *hotkeySettings;
+extern HotkeySettings* hotkeySettings;
diff -ru higan_v092r07\target-ethos\settings\input.cpp higan_v092r08\target-ethos\settings\input.cpp
--- higan_v092r07\target-ethos\settings\input.cpp	Fri Apr 12 16:55:29 2013
+++ higan_v092r08\target-ethos\settings\input.cpp	Thu May 02 06:18:06 2013
@@ -1,6 +1,6 @@
-InputSettings *inputSettings = nullptr;
+InputSettings* inputSettings = nullptr;
 
-InputSettings::InputSettings() : activeInput(nullptr) {
+InputSettings::InputSettings() {
   title.setFont(program->titleFont);
   title.setText("Input Settings");
   focusLabel.setText("When Focus is Lost:");
@@ -29,7 +29,7 @@
     controlLayout.append(resetButton, {80, 0}, 5);
     controlLayout.append(eraseButton, {80, 0});
 
-  for(auto &emulator : program->emulator) {
+  for(auto& emulator : program->emulator) {
     systemList.append(emulator->information.name);
   }
 
@@ -60,7 +60,7 @@
     assign[2].setVisible(false);
   } else {
     unsigned number = activeDevice().order[inputList.selection()];
-    auto &input = activeDevice().input[number];
+    auto& input = activeDevice().input[number];
     auto selectedInput = inputManager->inputMap[input.guid];
 
     if(dynamic_cast<DigitalInput*>(selectedInput)) {
@@ -99,7 +99,7 @@
 
 void InputSettings::systemChanged() {
   portList.reset();
-  for(auto &port : activeSystem().port) {
+  for(auto& port : activeSystem().port) {
     portList.append(port.name);
   }
   portChanged();
@@ -107,7 +107,7 @@
 
 void InputSettings::portChanged() {
   deviceList.reset();
-  for(auto &device : activePort().device) {
+  for(auto& device : activePort().device) {
     deviceList.append(device.name);
   }
   deviceChanged();
@@ -123,7 +123,7 @@
 void InputSettings::inputChanged() {
   unsigned index = 0;
   for(unsigned number : activeDevice().order) {
-    auto &input = activeDevice().input[number];
+    auto& input = activeDevice().input[number];
     auto abstract = inputManager->inputMap(input.guid);
     string mapping = abstract->mapping;
     mapping.replace("KB0::", "");
@@ -137,7 +137,7 @@
   if(MessageWindow().setParent(*settings).setText("All inputs will be erased. Are you sure you want to do this?")
   .question() == MessageWindow::Response::No) return;
 
-  auto &device = activeDevice();
+  auto& device = activeDevice();
   unsigned length = device.input.size();
   for(unsigned n = 0; n < length; n++) {
     activeInput = inputManager->inputMap[device.input[n].guid];
@@ -147,14 +147,14 @@
 
 void InputSettings::eraseInput() {
   unsigned number = activeDevice().order[inputList.selection()];
-  auto &input = activeDevice().input[number];
+  auto& input = activeDevice().input[number];
   activeInput = inputManager->inputMap[input.guid];
   inputEvent(Scancode::None, 1);
 }
 
 void InputSettings::assignInput() {
   unsigned number = activeDevice().order[inputList.selection()];
-  auto &input = activeDevice().input[number];
+  auto& input = activeDevice().input[number];
   activeInput = inputManager->inputMap[input.guid];
 
   settings->setStatusText({"Set assignment for [", activeDevice().name, "::", input.name, "] ..."});
@@ -164,7 +164,7 @@
 
 void InputSettings::assignMouseInput(unsigned n) {
   unsigned number = activeDevice().order[inputList.selection()];
-  auto &input = activeDevice().input[number];
+  auto& input = activeDevice().input[number];
   activeInput = inputManager->inputMap[input.guid];
 
   if(dynamic_cast<DigitalInput*>(activeInput)) {
diff -ru higan_v092r07\target-ethos\settings\input.hpp higan_v092r08\target-ethos\settings\input.hpp
--- higan_v092r07\target-ethos\settings\input.hpp	Fri Mar 15 07:19:27 2013
+++ higan_v092r08\target-ethos\settings\input.hpp	Thu May 02 06:16:41 2013
@@ -33,7 +33,7 @@
   InputSettings();
 
 private:
-  AbstractInput *activeInput;
+  AbstractInput* activeInput = nullptr;
 };
 
-extern InputSettings *inputSettings;
+extern InputSettings* inputSettings;
diff -ru higan_v092r07\target-ethos\settings\server.cpp higan_v092r08\target-ethos\settings\server.cpp
--- higan_v092r07\target-ethos\settings\server.cpp	Fri Mar 15 07:14:50 2013
+++ higan_v092r08\target-ethos\settings\server.cpp	Thu May 02 06:18:37 2013
@@ -1,4 +1,4 @@
-ServerSettings *serverSettings = nullptr;
+ServerSettings* serverSettings = nullptr;
 
 ServerSettings::ServerSettings() {
   title.setFont(program->titleFont);
diff -ru higan_v092r07\target-ethos\settings\server.hpp higan_v092r08\target-ethos\settings\server.hpp
--- higan_v092r07\target-ethos\settings\server.hpp	Mon Oct 29 17:49:05 2012
+++ higan_v092r08\target-ethos\settings\server.hpp	Thu May 02 06:18:28 2013
@@ -12,4 +12,4 @@
   ServerSettings();
 };
 
-extern ServerSettings *serverSettings;
+extern ServerSettings* serverSettings;
diff -ru higan_v092r07\target-ethos\settings\settings.cpp higan_v092r08\target-ethos\settings\settings.cpp
--- higan_v092r07\target-ethos\settings\settings.cpp	Fri Mar 15 07:15:14 2013
+++ higan_v092r08\target-ethos\settings\settings.cpp	Thu May 02 06:19:10 2013
@@ -8,7 +8,7 @@
 #include "advanced.cpp"
 Settings *settings = nullptr;
 
-void SettingsLayout::append(Sizable &sizable, const Size &size, unsigned spacing) {
+void SettingsLayout::append(Sizable& sizable, const Size& size, unsigned spacing) {
   layout.append(sizable, size, spacing);
 }
 
diff -ru higan_v092r07\target-ethos\settings\settings.hpp higan_v092r08\target-ethos\settings\settings.hpp
--- higan_v092r07\target-ethos\settings\settings.hpp	Mon Jan 21 02:32:32 2013
+++ higan_v092r08\target-ethos\settings\settings.hpp	Thu May 02 06:18:49 2013
@@ -2,7 +2,7 @@
   Widget spacer;
   VerticalLayout layout;
 
-  void append(Sizable &widget, const Size &size, unsigned spacing = 0);
+  void append(Sizable& widget, const Size &size, unsigned spacing = 0);
   SettingsLayout();
 };
 
@@ -22,4 +22,4 @@
   Settings();
 };
 
-extern Settings *settings;
+extern Settings* settings;
diff -ru higan_v092r07\target-ethos\settings\timing.cpp higan_v092r08\target-ethos\settings\timing.cpp
--- higan_v092r07\target-ethos\settings\timing.cpp	Fri Mar 15 07:15:38 2013
+++ higan_v092r08\target-ethos\settings\timing.cpp	Thu May 02 06:20:18 2013
@@ -1,4 +1,4 @@
-TimingSettings *timingSettings = nullptr;
+TimingSettings* timingSettings = nullptr;
 
 TimingAdjustment::TimingAdjustment() {
   assign.setEnabled(false);
@@ -52,7 +52,7 @@
   videoAdjust.stop.setEnabled(true);
   analyzeStart();
   do {
-    uint32_t *output;
+    uint32_t* output;
     unsigned pitch;
     if(video.lock(output, pitch, 16, 16)) {
       pitch >>= 2;
@@ -91,7 +91,7 @@
   analysis.systemTime = time(0);
 }
 
-bool TimingSettings::analyzeTick(const string &type) {
+bool TimingSettings::analyzeTick(const string& type) {
   analysis.counter++;
 
   time_t systemTime = time(0);
@@ -104,7 +104,7 @@
     } else {
       analysis.sample.append(analysis.counter);
       uintmax_t sum = 0;
-      for(auto &point : analysis.sample) sum += point;
+      for(auto& point : analysis.sample) sum += point;
       settings->setStatusText({
         type, " sample rate: ", (double)sum / analysis.sample.size(), "hz",
         " (", analysis.sample.size(), " sample points)"
diff -ru higan_v092r07\target-ethos\settings\timing.hpp higan_v092r08\target-ethos\settings\timing.hpp
--- higan_v092r07\target-ethos\settings\timing.hpp	Mon May 07 13:46:47 2012
+++ higan_v092r08\target-ethos\settings\timing.hpp	Thu May 02 06:19:40 2013
@@ -18,7 +18,7 @@
   void analyzeAudioFrequency();
 
   void analyzeStart();
-  bool analyzeTick(const string &type);
+  bool analyzeTick(const string& type);
   void analyzeStop();
 
   TimingSettings();
@@ -32,4 +32,4 @@
   } analysis;
 };
 
-extern TimingSettings *timingSettings;
+extern TimingSettings* timingSettings;
diff -ru higan_v092r07\target-ethos\settings\video.cpp higan_v092r08\target-ethos\settings\video.cpp
--- higan_v092r07\target-ethos\settings\video.cpp	Fri Apr 12 16:55:06 2013
+++ higan_v092r08\target-ethos\settings\video.cpp	Thu May 02 06:20:36 2013
@@ -1,4 +1,4 @@
-VideoSettings *videoSettings = nullptr;
+VideoSettings* videoSettings = nullptr;
 
 VideoSlider::VideoSlider() {
   append(name, {75, 0});
diff -ru higan_v092r07\target-ethos\settings\video.hpp higan_v092r08\target-ethos\settings\video.hpp
--- higan_v092r07\target-ethos\settings\video.hpp	Thu May 03 11:55:31 2012
+++ higan_v092r08\target-ethos\settings\video.hpp	Thu May 02 06:20:26 2013
@@ -20,4 +20,4 @@
   VideoSettings();
 };
 
-extern VideoSettings *videoSettings;
+extern VideoSettings* videoSettings;
diff -ru higan_v092r07\target-ethos\tools\cheat-database.cpp higan_v092r08\target-ethos\tools\cheat-database.cpp
--- higan_v092r07\target-ethos\tools\cheat-database.cpp	Mon Mar 18 08:57:51 2013
+++ higan_v092r08\target-ethos\tools\cheat-database.cpp	Thu May 02 06:21:06 2013
@@ -1,4 +1,4 @@
-CheatDatabase *cheatDatabase = nullptr;
+CheatDatabase* cheatDatabase = nullptr;
 
 CheatDatabase::CheatDatabase() {
   setGeometry({256, 256, 600, 360});
@@ -35,12 +35,12 @@
   cheat.reset();
 
   auto document = Markup::Document(string::read(program->path("cheats.bml")));
-  for(auto &node : document) {
+  for(auto& node : document) {
     if(node.name != "cartridge") continue;
     if(node["sha256"].text() != sha256) continue;
 
     setTitle(node["name"].text());
-    for(auto &cheat : node) {
+    for(auto& cheat : node) {
       if(cheat.name != "cheat") continue;
       cheatList.append(cheat["description"].text());
       this->cheat.append({cheat["code"].text(), cheat["description"].text()});
diff -ru higan_v092r07\target-ethos\tools\cheat-database.hpp higan_v092r08\target-ethos\tools\cheat-database.hpp
--- higan_v092r07\target-ethos\tools\cheat-database.hpp	Sat May 05 18:43:30 2012
+++ higan_v092r08\target-ethos\tools\cheat-database.hpp	Thu May 02 06:20:48 2013
@@ -19,4 +19,4 @@
   vector<Cheat> cheat;
 };
 
-extern CheatDatabase *cheatDatabase;
+extern CheatDatabase* cheatDatabase;
diff -ru higan_v092r07\target-ethos\tools\cheat-editor.cpp higan_v092r08\target-ethos\tools\cheat-editor.cpp
--- higan_v092r07\target-ethos\tools\cheat-editor.cpp	Mon Mar 18 08:55:57 2013
+++ higan_v092r08\target-ethos\tools\cheat-editor.cpp	Thu May 02 06:22:23 2013
@@ -1,4 +1,4 @@
-CheatEditor *cheatEditor = nullptr;
+CheatEditor* cheatEditor = nullptr;
 
 CheatEditor::CheatEditor() {
   setGeometry({128, 128, 600, 360});
@@ -124,13 +124,13 @@
   refresh();
 }
 
-bool CheatEditor::load(const string &filename) {
+bool CheatEditor::load(const string& filename) {
   string data = string::read(filename);
   if(data.empty()) return false;
 
   unsigned n = 0;
   auto document = Markup::Document(data);
-  for(auto &node : document["cartridge"]) {
+  for(auto& node : document["cartridge"]) {
     if(node.name != "cheat") continue;
     cheatList.setChecked(n, node["enabled"].exists());
     cheat[n].code = node["code"].text();
@@ -143,7 +143,7 @@
   return true;
 }
 
-bool CheatEditor::save(const string &filename) {
+bool CheatEditor::save(const string& filename) {
   signed lastSave = -1;
   for(signed n = 127; n >= 0; n--) {
     if(!cheat[n].code.empty() || !cheat[n].desc.empty()) {
@@ -171,7 +171,7 @@
   return true;
 }
 
-bool CheatEditor::import(const string &code, const string &desc) {
+bool CheatEditor::import(const string& code, const string& desc) {
   for(unsigned n = 0; n < Codes; n++) {
     if(cheat[n].code.empty() && cheat[n].desc.empty()) {
       cheatList.setChecked(n, false);
diff -ru higan_v092r07\target-ethos\tools\cheat-editor.hpp higan_v092r08\target-ethos\tools\cheat-editor.hpp
--- higan_v092r07\target-ethos\tools\cheat-editor.hpp	Sat May 05 18:18:17 2012
+++ higan_v092r08\target-ethos\tools\cheat-editor.hpp	Thu May 02 06:21:32 2013
@@ -18,9 +18,9 @@
   void updateCode();
   void updateDesc();
 
-  bool load(const string &filename);
-  bool save(const string &filename);
-  bool import(const string &code, const string &desc);
+  bool load(const string& filename);
+  bool save(const string& filename);
+  bool import(const string& code, const string& desc);
 
   void update();
   void refresh();
@@ -36,4 +36,4 @@
   Cheat cheat[Codes];
 };
 
-extern CheatEditor *cheatEditor;
+extern CheatEditor* cheatEditor;
diff -ru higan_v092r07\target-ethos\tools\state-manager.cpp higan_v092r08\target-ethos\tools\state-manager.cpp
--- higan_v092r07\target-ethos\tools\state-manager.cpp	Mon Mar 18 08:56:22 2013
+++ higan_v092r08\target-ethos\tools\state-manager.cpp	Thu May 02 06:23:39 2013
@@ -1,4 +1,4 @@
-StateManager *stateManager = nullptr;
+StateManager* stateManager = nullptr;
 
 StateManager::StateManager() {
   setGeometry({128, 128, 600, 360});
@@ -65,13 +65,13 @@
 }
 
 void StateManager::reset() {
-  for(auto &slot : this->slot) slot = serializer();
+  for(auto& slot : this->slot) slot = serializer();
   synchronize();
   refresh();
 }
 
-bool StateManager::load(const string &filename, unsigned revision) {
-  for(auto &slot : this->slot) slot = serializer();
+bool StateManager::load(const string& filename, unsigned revision) {
+  for(auto& slot : this->slot) slot = serializer();
   synchronize();
 
   file fp;
@@ -81,7 +81,7 @@
     for(auto &slot : this->slot) {
       if(fp.read() == false) continue;  //slot is empty
       unsigned size = fp.readl(4);
-      uint8_t *data = new uint8_t[size];
+      uint8_t* data = new uint8_t[size];
       fp.read(data, size);
       slot = serializer(data, size);
       delete[] data;
@@ -93,9 +93,9 @@
   return true;
 }
 
-bool StateManager::save(const string &filename, unsigned revision) {
+bool StateManager::save(const string& filename, unsigned revision) {
   bool hasSave = false;
-  for(auto &slot : this->slot) hasSave |= slot.capacity() > 0;
+  for(auto& slot : this->slot) hasSave |= slot.capacity() > 0;
   if(hasSave == false) {
     file::remove(filename);
     return true;
@@ -108,7 +108,7 @@
 
   fp.writel(0x31415342, 4);  //'BSA1'
   fp.writel(revision, 4);
-  for(auto &slot : this->slot) {
+  for(auto& slot : this->slot) {
     fp.write(slot.capacity() > 0);
     if(slot.capacity()) {
       fp.writel(slot.capacity(), 4);
diff -ru higan_v092r07\target-ethos\tools\state-manager.hpp higan_v092r08\target-ethos\tools\state-manager.hpp
--- higan_v092r07\target-ethos\tools\state-manager.hpp	Sat May 05 19:25:00 2012
+++ higan_v092r08\target-ethos\tools\state-manager.hpp	Thu May 02 06:22:38 2013
@@ -12,8 +12,8 @@
     Button eraseButton;
 
   void reset();
-  bool load(const string &filename, unsigned revision);
-  bool save(const string &filename, unsigned revision);
+  bool load(const string& filename, unsigned revision);
+  bool save(const string& filename, unsigned revision);
 
   void slotLoad();
   void slotSave();
@@ -34,4 +34,4 @@
   serializer slot[Slots];
 };
 
-extern StateManager *stateManager;
+extern StateManager* stateManager;
diff -ru higan_v092r07\target-ethos\utility\utility.cpp higan_v092r08\target-ethos\utility\utility.cpp
--- higan_v092r07\target-ethos\utility\utility.cpp	Fri Apr 12 16:53:01 2013
+++ higan_v092r08\target-ethos\utility\utility.cpp	Thu May 02 06:26:13 2013
@@ -1,8 +1,8 @@
 #include "../ethos.hpp"
 
-Utility *utility = nullptr;
+Utility* utility = nullptr;
 
-void Utility::setInterface(Emulator::Interface *emulator) {
+void Utility::setInterface(Emulator::Interface* emulator) {
   program->active = emulator;
   presentation->synchronize();
 }
@@ -26,8 +26,8 @@
   string type = extension(pathname);
 
   //determine type by comparing extension against all emulation cores
-  for(auto &emulator : program->emulator) {
-    for(auto &media : emulator->media) {
+  for(auto& emulator : program->emulator) {
+    for(auto& media : emulator->media) {
       if(media.bootable == false) continue;
       if(type != media.type) continue;
       return loadMedia(emulator, media, {pathname, "/"});
@@ -38,14 +38,14 @@
 }
 
 //load menu option selected
-void Utility::loadMedia(Emulator::Interface *emulator, Emulator::Interface::Media &media) {
+void Utility::loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media) {
   string pathname = browser->select({"Load ", media.name}, media.type);
   if(!directory::exists(pathname)) return;
   return loadMedia(emulator, media, pathname);
 }
 
 //load base cartridge
-void Utility::loadMedia(Emulator::Interface *emulator, Emulator::Interface::Media &media, const string &pathname) {
+void Utility::loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media, const string& pathname) {
   unload();
   setInterface(emulator);
   path(0) = program->path({media.name, ".sys/"});
@@ -61,7 +61,7 @@
 }
 
 //request from emulation core to load non-volatile media folder
-void Utility::loadRequest(unsigned id, const string &name, const string &type) {
+void Utility::loadRequest(unsigned id, const string& name, const string& type) {
   string pathname = browser->select({"Load ", name}, type);
   if(pathname.empty()) return;
   path(id) = pathname;
@@ -71,7 +71,7 @@
 }
 
 //request from emulation core to load non-volatile media file
-void Utility::loadRequest(unsigned id, const string &path) {
+void Utility::loadRequest(unsigned id, const string& path) {
   string pathname = {this->path(system().group(id)), path};
   if(file::exists(pathname) == false) return;
   mmapstream stream(pathname);
@@ -79,7 +79,7 @@
 }
 
 //request from emulation core to save non-volatile media file
-void Utility::saveRequest(unsigned id, const string &path) {
+void Utility::saveRequest(unsigned id, const string& path) {
   string pathname = {this->path(system().group(id)), path};
   filestream stream(pathname, file::mode::write);
   return system().save(id, stream);
@@ -294,11 +294,11 @@
   }
 }
 
-void Utility::setStatusText(const string &text) {
+void Utility::setStatusText(const string& text) {
   statusText = text;
 }
 
-void Utility::showMessage(const string &message) {
+void Utility::showMessage(const string& message) {
   statusTime = time(0);
   statusMessage = message;
 }
diff -ru higan_v092r07\target-ethos\utility\utility.hpp higan_v092r08\target-ethos\utility\utility.hpp
--- higan_v092r07\target-ethos\utility\utility.hpp	Sat Jan 12 17:36:35 2013
+++ higan_v092r08\target-ethos\utility\utility.hpp	Thu May 02 06:24:30 2013
@@ -1,13 +1,13 @@
 struct Utility {
-  void setInterface(Emulator::Interface *emulator);
+  void setInterface(Emulator::Interface* emulator);
 
   void loadMedia(string pathname);
-  void loadMedia(Emulator::Interface *emulator, Emulator::Interface::Media &media);
-  void loadMedia(Emulator::Interface *emulator, Emulator::Interface::Media &media, const string &pathname);
+  void loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media);
+  void loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media, const string& pathname);
 
-  void loadRequest(unsigned id, const string &name, const string &type);
-  void loadRequest(unsigned id, const string &path);
-  void saveRequest(unsigned id, const string &path);
+  void loadRequest(unsigned id, const string& name, const string& type);
+  void loadRequest(unsigned id, const string& path);
+  void saveRequest(unsigned id, const string& path);
 
   void connect(unsigned port, unsigned device);
   void power();
@@ -27,8 +27,8 @@
   void toggleFullScreen();
 
   void updateStatus();
-  void setStatusText(const string &text);
-  void showMessage(const string &message);
+  void setStatusText(const string& text);
+  void showMessage(const string& message);
 
   Utility();
 
@@ -42,4 +42,4 @@
   time_t statusTime;
 };
 
-extern Utility *utility;
+extern Utility* utility;
